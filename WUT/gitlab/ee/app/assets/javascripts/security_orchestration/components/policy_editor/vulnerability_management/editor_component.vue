<script>
import { GlButton, GlTooltipDirective, GlAlert, GlSprintf } from '@gitlab/ui';
import { s__, sprintf, n__ } from '~/locale';
import glFeatureFlagsMixin from '~/vue_shared/mixins/gl_feature_flags_mixin';
import { extractPolicyContent } from 'ee/security_orchestration/components/utils';
import {
  policyBodyToYaml,
  policyToYaml,
} from 'ee/security_orchestration/components/policy_editor/utils';
import {
  RULES_LABEL,
  ADD_RULE_LABEL,
  ACTIONS_LABEL,
  EDITOR_MODE_RULE,
  EDITOR_MODE_YAML,
  SECURITY_POLICY_ACTIONS,
  MAX_ALLOWED_RULES_LENGTH,
  ACTION_SECTION_DISABLE_ERROR,
  RULES_SECTION_DISABLE_ERROR,
} from '../constants';
import EditorLayout from '../editor_layout.vue';
import DisabledSection from '../disabled_section.vue';
import { DEFAULT_VULNERABILITY_MANAGEMENT_POLICY } from './constants';
import { createPolicyObject, buildDefaultNoLongerDetectedRule } from './utils';
import RuleSection from './rule/rule_section.vue';
import ActionSection from './action/action_section.vue';

export default {
  SECURITY_POLICY_ACTIONS,
  EDITOR_MODE_RULE,
  EDITOR_MODE_YAML,
  i18n: {
    ACTION_SECTION_DISABLE_ERROR,
    RULES_SECTION_DISABLE_ERROR,
    RULES_LABEL,
    ADD_RULE_LABEL,
    ACTIONS_LABEL,
    limit: s__(
      'SecurityOrchestration|In each pipeline, a %{boldStart}maximum of 1000%{boldEnd} vulnerabilities that are %{italicStart}no longer detected%{italicEnd} will be set to status %{italicStart}Resolved%{italicEnd} until all have been auto-resolved.',
    ),
    exceedingRulesMessage: s__(
      'SecurityOrchestration|You can add a maximum of %{rulesCount} %{rules}.',
    ),
  },
  components: {
    GlButton,
    GlAlert,
    GlSprintf,
    EditorLayout,
    RuleSection,
    ActionSection,
    DisabledSection,
  },
  directives: { GlTooltip: GlTooltipDirective },
  mixins: [glFeatureFlagsMixin()],
  inject: ['namespacePath'],
  props: {
    existingPolicy: {
      type: Object,
      required: false,
      default: null,
    },
    isCreating: {
      type: Boolean,
      required: true,
    },
    isDeleting: {
      type: Boolean,
      required: true,
    },
    isEditing: {
      type: Boolean,
      required: true,
    },
    selectedPolicyType: {
      type: String,
      required: true,
    },
  },
  data() {
    let yamlEditorValue;

    if (this.existingPolicy) {
      yamlEditorValue = policyToYaml(this.existingPolicy, this.selectedPolicyType);
    } else {
      yamlEditorValue = DEFAULT_VULNERABILITY_MANAGEMENT_POLICY;
    }

    const { policy, parsingError } = createPolicyObject(yamlEditorValue);

    return {
      mode: EDITOR_MODE_RULE,
      policy,
      yamlEditorValue,
      parsingError,
    };
  },
  computed: {
    hasNewSplitView() {
      return this.glFeatures.securityPoliciesSplitView;
    },
    canAddRule() {
      return this.policy.rules?.length < MAX_ALLOWED_RULES_LENGTH;
    },
    addRuleTitle() {
      const rules = n__('rule', 'rules', this.policy.rules?.length);
      return sprintf(this.$options.i18n.exceedingRulesMessage, {
        rulesCount: MAX_ALLOWED_RULES_LENGTH,
        rules,
      });
    },
  },
  methods: {
    areManifestsEqual(manifest) {
      const policyManifest = policyToYaml(this.policy, this.selectedPolicyType);
      return policyManifest === manifest && this.hasNewSplitView;
    },
    changeEditorMode(mode) {
      this.mode = mode;
    },
    async handleModifyPolicy(action) {
      /**
       * backend only accepts the old format
       * policy body is extracted
       * and policy type is added to a policy body
       */
      const policy = extractPolicyContent({
        manifest: this.yamlEditorValue,
        type: this.selectedPolicyType,
        withType: true,
      });

      this.$emit('save', {
        action,
        policy: policyBodyToYaml(policy),
      });
    },
    handleUpdateProperty(property, value) {
      this.policy[property] = value;
      this.updateYamlEditorValue(this.policy);
    },
    handleUpdateYaml(manifest) {
      if (this.areManifestsEqual(manifest)) {
        return;
      }

      const { policy, parsingError } = createPolicyObject(manifest);
      this.yamlEditorValue = manifest;
      this.parsingError = parsingError;
      this.policy = policy;
    },
    updateYamlEditorValue(policy) {
      this.yamlEditorValue = policyToYaml(policy, this.selectedPolicyType);
    },
    addRule() {
      this.policy.rules.push(buildDefaultNoLongerDetectedRule());
      this.updateYamlEditorValue(this.policy);
    },
    updateRule(index, values) {
      this.policy.rules.splice(index, 1, values);
      this.updateYamlEditorValue(this.policy);
    },
    removeRule(index) {
      this.policy.rules.splice(index, 1);
      this.updateYamlEditorValue(this.policy);
    },
  },
};
</script>
<template>
  <editor-layout
    :policy="policy"
    :yaml-editor-value="yamlEditorValue"
    :is-editing="isEditing"
    :is-removing-policy="isDeleting"
    :is-updating-policy="isCreating"
    @remove-policy="handleModifyPolicy($options.SECURITY_POLICY_ACTIONS.REMOVE)"
    @save-policy="handleModifyPolicy"
    @update-editor-mode="changeEditorMode"
    @update-property="handleUpdateProperty"
    @update-yaml="handleUpdateYaml"
  >
    <template #rules>
      <disabled-section
        :disabled="parsingError.rules"
        :error="$options.i18n.RULES_SECTION_DISABLE_ERROR"
        data-testid="disabled-rule"
      >
        <template #title>
          <h4>
            {{ $options.i18n.RULES_LABEL }}
          </h4>
        </template>

        <template #disabled>
          <div class="gl-rounded-base gl-bg-subtle gl-p-6"></div>
        </template>

        <gl-alert variant="info" :dismissible="false" class="gl-mb-4">
          <gl-sprintf :message="$options.i18n.limit">
            <template #bold="{ content }">
              <strong>{{ content }}</strong>
            </template>
            <template #italic="{ content }">
              <em>{{ content }}</em>
            </template>
          </gl-sprintf>
        </gl-alert>

        <rule-section
          v-for="(rule, index) in policy.rules"
          :key="rule.id"
          :rule="rule"
          :index="index"
          @changed="updateRule(index, $event)"
          @remove="removeRule(index)"
        />

        <div class="security-policies-bg-subtle gl-mb-5 gl-rounded-base gl-p-5">
          <span
            v-gl-tooltip="{
              disabled: canAddRule,
              title: addRuleTitle,
            }"
            data-testid="add-rule-wrapper"
          >
            <gl-button
              variant="link"
              data-testid="add-rule"
              :disabled="!canAddRule"
              @click="addRule"
            >
              {{ $options.i18n.ADD_RULE_LABEL }}
            </gl-button>
          </span>
        </div>
      </disabled-section>
    </template>
    <template #actions>
      <disabled-section
        :disabled="parsingError.actions"
        :error="$options.i18n.ACTION_SECTION_DISABLE_ERROR"
        data-testid="disabled-action"
      >
        <template #title>
          <h4>{{ $options.i18n.ACTIONS_LABEL }}</h4>
        </template>

        <template #disabled>
          <div class="gl-rounded-base gl-bg-subtle gl-p-6"></div>
        </template>

        <action-section :actions="policy.actions" />
      </disabled-section>
    </template>
  </editor-layout>
</template>
