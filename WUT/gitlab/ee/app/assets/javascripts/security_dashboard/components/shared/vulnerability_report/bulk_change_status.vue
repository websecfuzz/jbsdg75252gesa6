<script>
import { GlButton, GlCollapsibleListbox, GlFormInput, GlFormGroup } from '@gitlab/ui';
import * as Sentry from '~/sentry/sentry_browser_wrapper';
import { __, s__, n__ } from '~/locale';
import toast from '~/vue_shared/plugins/global_toast';
import { VULNERABILITY_STATE_OBJECTS, DISMISSAL_REASONS } from 'ee/vulnerabilities/constants';
import vulnerabilitiesDismiss from 'ee/security_dashboard/graphql/mutations/vulnerabilities_dismiss.mutation.graphql';
import { DASHBOARD_TYPE_PIPELINE } from 'ee/security_dashboard/constants';

export default {
  components: {
    GlButton,
    GlCollapsibleListbox,
    GlFormInput,
    GlFormGroup,
  },
  inject: {
    vulnerabilitiesQuery: {
      required: true,
    },
    vulnerabilitiesCountsQuery: {
      required: false,
      default: null,
    },
    dismissalDescriptions: {
      required: true,
    },
    dashboardType: {
      required: true,
    },
  },
  props: {
    selectedVulnerabilities: {
      type: Array,
      required: true,
    },
  },
  data() {
    return {
      isSubmitting: false,
      selectedStatus: null,
      selectedDismissalReason: null,
      comment: null,
      statusInvalid: false,
      dismissalReasonInvalid: false,
      commentInvalid: false,
    };
  },
  computed: {
    selectedStatusObject() {
      return VULNERABILITY_STATE_OBJECTS[this.selectedStatus];
    },
    statusToggleText() {
      return this.selectedStatusObject?.dropdownText || this.$options.i18n.statusTogglePlaceholder;
    },
    dismissalReasonToggleText() {
      return (
        DISMISSAL_REASONS[this.selectedDismissalReason] ||
        this.$options.i18n.dismissalReasonTogglePlaceholder
      );
    },
    commentPlaceholder() {
      return this.isDismissedStatus
        ? this.$options.i18n.requiredCommentPlaceholder
        : this.$options.i18n.commentPlaceholder;
    },
    statusItems() {
      const items = Object.values(VULNERABILITY_STATE_OBJECTS).map((item) => ({
        ...item,
        value: item.state,
      }));

      if (!this.isPipeline) {
        return items;
      }

      return items.filter((item) => Boolean(item.findingMutation));
    },
    dismissalReasonItems() {
      return Object.entries(DISMISSAL_REASONS).map(([reason, text]) => ({
        value: reason,
        text,
        description: this.dismissalDescriptions[reason],
      }));
    },
    isDismissedStatus() {
      return this.selectedStatus === 'dismissed';
    },
    commentAndDismissalReason() {
      const { comment, selectedDismissalReason } = this;

      return {
        comment,
        ...(selectedDismissalReason && { dismissalReason: selectedDismissalReason.toUpperCase() }),
      };
    },
    isPipeline() {
      return this.dashboardType === DASHBOARD_TYPE_PIPELINE;
    },
    idKey() {
      return this.isPipeline ? 'uuid' : 'id';
    },
  },
  methods: {
    cancel() {
      this.$emit('cancel');
      this.resetState();
    },
    resetInvalidInputs() {
      this.statusInvalid = false;
      this.dismissalReasonInvalid = false;
      this.commentInvalid = false;
    },
    resetState() {
      this.selectedStatus = null;
      this.selectedDismissalReason = null;
      this.comment = null;
      this.resetInvalidInputs();
    },
    updateStatus() {
      this.resetInvalidInputs();
      this.selectedDismissalReason = null;
      this.comment = null;
    },
    async dismissMultipleVulnerabilities() {
      const { selectedVulnerabilities } = this;
      const ids = selectedVulnerabilities.map((vulnerability) => vulnerability.id);

      try {
        const {
          data: {
            vulnerabilitiesDismiss: { errors },
          },
        } = await this.$apollo.mutate({
          mutation: vulnerabilitiesDismiss,
          variables: {
            ids,
            ...this.commentAndDismissalReason,
          },
          refetchQueries: [this.vulnerabilitiesQuery, this.vulnerabilitiesCountsQuery],
          awaitRefetchQueries: true,
        });

        if (errors.length > 0) {
          throw new Error(errors.join(','));
        }

        this.isSubmitting = false;

        this.$emit('vulnerabilities-updated', ids);

        this.handleUpdateStateSuccess(ids.length);
      } catch (error) {
        Sentry.captureException(error);
        // the mutation works like a transaction, if there is an error, nothing will be dismissed
        this.$emit('update-rejected', selectedVulnerabilities);
      }
    },
    setInvalidInputs() {
      if (!this.selectedStatus) {
        this.statusInvalid = true;
      } else if (this.isDismissedStatus) {
        if (!this.selectedDismissalReason) {
          this.dismissalReasonInvalid = true;
        }
        if (!this.comment) {
          this.commentInvalid = true;
        }
      }
    },
    handleSubmit() {
      this.setInvalidInputs();

      if (this.statusInvalid || this.dismissalReasonInvalid || this.commentInvalid) {
        return false;
      }

      this.isSubmitting = true;
      this.$emit('clear-rejected');

      // Only use bulk dismissal mutation for non-pipeline dashboard type
      if (this.isDismissedStatus && !this.isPipeline) {
        return this.dismissMultipleVulnerabilities();
      }

      let fulfilledCount = 0;

      const mutation = this.isPipeline
        ? this.selectedStatusObject.findingMutation
        : this.selectedStatusObject.mutation;

      const promises = this.selectedVulnerabilities.map((vulnerability) => {
        return this.$apollo
          .mutate({
            mutation,
            variables: {
              [this.idKey]: vulnerability.id,
              ...this.commentAndDismissalReason,
            },
            refetchQueries: [this.vulnerabilitiesQuery, this.vulnerabilitiesCountsQuery],
            awaitRefetchQueries: true,
          })
          .then(({ data }) => {
            const [queryName] = Object.keys(data);

            if (data[queryName].errors?.length > 0) {
              throw data[queryName].errors;
            }

            fulfilledCount += 1;
            this.$emit('vulnerabilities-updated', [vulnerability.id]);
          })
          .catch(() => {
            this.$emit('update-rejected', [vulnerability]);
          });
      });

      return Promise.all(promises).then(async () => {
        this.isSubmitting = false;

        if (fulfilledCount > 0) {
          await this.handleUpdateStateSuccess(fulfilledCount);
        }
      });
    },
    handleUpdateStateSuccess(updatedVulnerabilitiesCount) {
      toast(
        this.$options.i18n.statusChanged(
          this.selectedStatusObject.action,
          updatedVulnerabilitiesCount,
        ),
      );
      this.resetState();

      // ensure that previously made queries with status filters will be freshly fetched, to not show stale data
      return this.$apollo.getClient().clearStore();
    },
  },
  i18n: {
    cancel: __('Cancel'),
    selected: s__('SecurityReports|%{count} Selected'),
    statusTogglePlaceholder: s__('SecurityReports|Select status'),
    dismissalReasonTogglePlaceholder: s__('SecurityReports|Select dismissal reason'),
    commentPlaceholder: s__('SecurityReports|Add a comment'),
    requiredCommentPlaceholder: s__('SecurityReports|Add a comment (required)'),
    requiredSelection: s__('SecurityReports|This selection is required.'),
    requiredComment: s__('SecurityReports|A comment is required when dismissing.'),
    changeStatus: s__('SecurityReports|Change status'),
    statusChanged: (status, count) =>
      ({
        confirm: n__(
          '%d vulnerability set to confirmed',
          '%d vulnerabilities set to confirmed',
          count,
        ),
        resolve: n__(
          '%d vulnerability set to resolved',
          '%d vulnerabilities set to resolved',
          count,
        ),
        dismiss: n__(
          '%d vulnerability set to dismissed',
          '%d vulnerabilities set to dismissed',
          count,
        ),
        revert: n__(
          '%d vulnerability set to needs triage',
          '%d vulnerabilities set to needs triage',
          count,
        ),
      })[status],
    vulnerabilitiesUpdateFailed: s__(
      'SecurityReports|Failed updating vulnerabilities with the following IDs: %{ids}',
    ),
  },
};
</script>

<template>
  <form
    class="gl-flex gl-flex-grow gl-flex-wrap gl-items-start gl-gap-3"
    @submit.prevent="handleSubmit"
  >
    <gl-form-group
      label-class="gl-hidden"
      :state="!statusInvalid"
      :invalid-feedback="$options.i18n.requiredSelection"
      class="gl-mb-0"
      data-testid="status-form-group"
    >
      <gl-collapsible-listbox
        v-model="selectedStatus"
        :items="statusItems"
        :toggle-text="statusToggleText"
        :disabled="isSubmitting"
        :aria-invalid="statusInvalid"
        :variant="statusInvalid ? 'danger' : 'default'"
        :category="statusInvalid ? 'secondary' : 'primary'"
        block
        :class="{ 'is-invalid gl-mb-3': statusInvalid }"
        data-testid="status-listbox"
        @select="updateStatus"
      >
        <template #list-item="{ item }">
          <span class="gl-flex gl-flex-col" :data-testid="item.action">
            <span class="gl-whitespace-nowrap gl-font-bold">{{ item.dropdownText }}</span>
            <span class="gl-text-subtle"> {{ item.dropdownDescription }}</span>
          </span>
        </template>
      </gl-collapsible-listbox>
    </gl-form-group>

    <gl-form-group
      v-if="isDismissedStatus"
      label-class="gl-hidden"
      :state="!dismissalReasonInvalid"
      :invalid-feedback="$options.i18n.requiredSelection"
      class="gl-mb-0"
      data-testid="dismissal-reason-form-group"
    >
      <gl-collapsible-listbox
        v-model="selectedDismissalReason"
        :items="dismissalReasonItems"
        :toggle-text="dismissalReasonToggleText"
        :disabled="isSubmitting"
        :variant="dismissalReasonInvalid ? 'danger' : 'default'"
        :category="dismissalReasonInvalid ? 'secondary' : 'primary'"
        :aria-invalid="dismissalReasonInvalid"
        block
        :class="{ 'is-invalid gl-mb-3': dismissalReasonInvalid }"
        data-testid="dismissal-reason-listbox"
        @select="dismissalReasonInvalid = false"
      >
        <template #list-item="{ item }">
          <span class="gl-flex gl-flex-col">
            <span class="gl-whitespace-nowrap gl-font-bold">{{ item.text }}</span>
            <span class="gl-text-sm gl-text-subtle"> {{ item.description }}</span>
          </span>
        </template>
      </gl-collapsible-listbox>
    </gl-form-group>

    <gl-form-group
      v-if="selectedStatus"
      label-class="gl-hidden"
      :state="!commentInvalid"
      :invalid-feedback="$options.i18n.requiredComment"
      class="gl-mb-0 gl-min-w-20 gl-grow gl-basis-0"
      data-testid="comment-form-group"
    >
      <gl-form-input
        v-model="comment"
        :placeholder="commentPlaceholder"
        :disabled="isSubmitting"
        :state="!commentInvalid"
        data-testid="change-status-comment-textbox"
        @input="commentInvalid = false"
      />
    </gl-form-group>

    <gl-button
      class="gl-ml-auto"
      :disabled="isSubmitting"
      data-testid="cancel-button"
      @click="cancel"
    >
      {{ $options.i18n.cancel }}
    </gl-button>
    <gl-button
      data-testid="change-status-button"
      type="submit"
      variant="confirm"
      :loading="isSubmitting"
      class="js-no-auto-disable"
    >
      {{ $options.i18n.changeStatus }}
    </gl-button>
  </form>
</template>
