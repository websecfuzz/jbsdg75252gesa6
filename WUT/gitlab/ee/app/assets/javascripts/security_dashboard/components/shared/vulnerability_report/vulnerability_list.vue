<script>
import {
  GlFormCheckbox,
  GlLink,
  GlSprintf,
  GlSkeletonLoader,
  GlTooltipDirective,
  GlTable,
  GlTruncate,
  GlPopover,
  GlFriendlyWrap,
} from '@gitlab/ui';
import { Portal } from 'portal-vue';
import glAbilitiesMixin from '~/vue_shared/mixins/gl_abilities_mixin';
import glFeatureFlagsMixin from '~/vue_shared/mixins/gl_feature_flags_mixin';
import { s__, sprintf } from '~/locale';
import DashboardHasNoVulnerabilities from 'ee/security_dashboard/components/shared/empty_states/dashboard_has_no_vulnerabilities.vue';
import FiltersProducedNoResults from 'ee/security_dashboard/components/shared/empty_states/filters_produced_no_results.vue';
import SeverityBadge from 'ee/vue_shared/security_reports/components/severity_badge.vue';
import convertReportType from 'ee/vue_shared/security_reports/store/utils/convert_report_type';
import getPrimaryIdentifier from 'ee/vue_shared/security_reports/store/utils/get_primary_identifier';
import FalsePositiveBadge from 'ee/vulnerabilities/components/false_positive_badge.vue';
import ResolutionBadge from 'ee/vulnerabilities/components/resolution_badge.vue';
import ArchivalBadge from 'ee/vulnerabilities/components/archival_badge.vue';
import { DASHBOARD_TYPE_PIPELINE } from 'ee/security_dashboard/constants';
import { formatDate } from '~/lib/utils/datetime_utility';
import MergeRequestBadge from '../merge_request_badge.vue';
import IssuesBadge from '../issues_badge.vue';
import SolutionBadge from '../solution_badge.vue';
import AiResolutionBadge from '../ai_resolution_badge.vue';
import VulnerabilityCommentIcon from '../vulnerability_comment_icon.vue';
import VulnerabilityPath from './vulnerability_path.vue';
import SelectionSummary from './selection_summary.vue';
import VulnerabilityListStatus from './vulnerability_list_status.vue';
import SecurityScores from './security_scores.vue';
import { FIELDS } from './constants';

export default {
  components: {
    ArchivalBadge,
    GlFormCheckbox,
    GlLink,
    GlFriendlyWrap,
    GlSkeletonLoader,
    GlSprintf,
    GlTable,
    GlTruncate,
    GlPopover,
    IssuesBadge,
    MergeRequestBadge,
    ResolutionBadge,
    FalsePositiveBadge,
    SelectionSummary,
    SeverityBadge,
    SecurityScores,
    VulnerabilityCommentIcon,
    VulnerabilityPath,
    VulnerabilityListStatus,
    FiltersProducedNoResults,
    DashboardHasNoVulnerabilities,
    Portal,
    SolutionBadge,
    AiResolutionBadge,
  },
  directives: {
    GlTooltip: GlTooltipDirective,
  },
  mixins: [glAbilitiesMixin(), glFeatureFlagsMixin()],
  inject: {
    hasVulnerabilities: {
      default: false,
    },
    canAdminVulnerability: {
      default: false,
    },
    hasJiraVulnerabilitiesIntegrationEnabled: {
      default: false,
    },
    dashboardType: {},
  },
  props: {
    fields: {
      type: Array,
      required: true,
    },
    vulnerabilities: {
      type: Array,
      required: true,
    },
    isLoading: {
      type: Boolean,
      required: false,
      default: false,
    },
    shouldShowProjectNamespace: {
      type: Boolean,
      required: false,
      default: false,
    },
    portalName: {
      type: String,
      required: true,
    },
    pageSize: {
      type: Number,
      required: true,
    },
    sort: {
      type: Object,
      required: false,
      default: () => ({
        sortBy: FIELDS.SEVERITY.key,
        sortDesc: true,
      }),
    },
  },
  data() {
    return {
      selectedVulnerabilities: {},
    };
  },
  i18n: {
    image: s__('Vulnerability|Image: %{linkStart}%{image}%{linkEnd}'),
  },
  computed: {
    displayFields() {
      // Add the checkbox field if the user can use the bulk select feature.
      return this.canAdminVulnerability ? [FIELDS.CHECKBOX, ...this.fields] : this.fields;
    },
    hasAnyScannersOtherThanGitLab() {
      return this.vulnerabilities.some(
        (v) => v.scanner?.vendor !== 'GitLab' && v.scanner?.vendor !== '',
      );
    },
    hasSelectedSomeVulnerabilities() {
      // Whether the user has selected at least 1, but not all vulnerabilities.
      return this.numOfSelectedVulnerabilities > 0 && !this.hasSelectedAllVulnerabilities;
    },
    hasSelectedAllVulnerabilities() {
      if (!this.vulnerabilities.length) {
        return false;
      }
      return this.numOfSelectedVulnerabilities === this.vulnerabilities.length;
    },
    numOfSelectedVulnerabilities() {
      return Object.keys(this.selectedVulnerabilities).length;
    },
    shouldShowSelectionSummary() {
      return this.numOfSelectedVulnerabilities > 0;
    },
    shouldShowTable() {
      return this.isLoading || this.vulnerabilities.length;
    },
  },
  watch: {
    vulnerabilities() {
      const ids = new Set(this.vulnerabilities.map((v) => v.id));

      Object.keys(this.selectedVulnerabilities).forEach((vulnerabilityId) => {
        if (!ids.has(vulnerabilityId)) {
          this.deleteVulnerability(vulnerabilityId);
        }
      });
    },
  },
  methods: {
    getScannerItemTooltip(item) {
      const scannerName = item?.scanner?.name || 'unknown';
      return sprintf(s__('Vulnerability|Scanner: %{scannerName}'), { scannerName });
    },
    deleteVulnerability(vulnerabilityId) {
      const copy = { ...this.selectedVulnerabilities };
      delete copy[vulnerabilityId];
      this.selectedVulnerabilities = copy;
    },
    setVulnerability(vulnerabilityId, vulnerability) {
      const copy = { ...this.selectedVulnerabilities };
      copy[vulnerabilityId] = vulnerability;
      this.selectedVulnerabilities = copy;
    },
    hasCluster(item) {
      return item.location.kubernetesResource?.agent;
    },
    clusterName(item) {
      return item.location.kubernetesResource?.agent?.name;
    },
    clusterUrl(item) {
      return item.location.kubernetesResource?.agent?.webPath;
    },
    deselectVulnerabilities(vulnerabilityIds) {
      vulnerabilityIds.forEach((id) => {
        this.deleteVulnerability(id);
      });
    },
    deselectAllVulnerabilities() {
      this.selectedVulnerabilities = {};
    },
    extraIdentifierCount(identifiers) {
      return identifiers.length - 1;
    },
    primaryIdentifier(identifiers) {
      return getPrimaryIdentifier(identifiers, 'externalType');
    },
    isSelected(vulnerability = {}) {
      return Boolean(this.selectedVulnerabilities[vulnerability.id]);
    },
    selectAllVulnerabilities() {
      this.selectedVulnerabilities = this.vulnerabilities.reduce((acc, curr) => {
        acc[curr.id] = curr;
        return acc;
      }, {});
    },
    shouldShowExtraIdentifierCount(identifiers) {
      return identifiers?.length > 1;
    },
    toggleAllVulnerabilities() {
      if (this.hasSelectedAllVulnerabilities) {
        this.deselectAllVulnerabilities();
      } else {
        this.selectAllVulnerabilities();
      }
    },
    toggleVulnerability(vulnerability) {
      // If the user can't use the bulk select feature (like the auditor user), don't do anything.
      if (!this.canAdminVulnerability) {
        return;
      }

      if (this.selectedVulnerabilities[vulnerability.id]) {
        this.deleteVulnerability(vulnerability.id);
      } else {
        this.setVulnerability(vulnerability.id, vulnerability);
      }
    },
    gitlabIssues(item) {
      return item.issueLinks?.nodes || [];
    },
    externalIssues(item) {
      if (this.dashboardType === DASHBOARD_TYPE_PIPELINE) {
        return item.vulnerability?.externalIssueLinks?.nodes || [];
      }
      return item.externalIssueLinks?.nodes || [];
    },
    jiraIssues(item) {
      return this.externalIssues(item).filter(({ issue }) => issue?.externalTracker === 'jira');
    },
    badgeIssues(item) {
      return this.hasJiraVulnerabilitiesIntegrationEnabled
        ? this.jiraIssues(item)
        : this.gitlabIssues(item);
    },
    formatDate(item) {
      return formatDate(item.detectedAt, 'yyyy-mm-dd');
    },
    formatDateTooltip(item) {
      return formatDate(item.detectedAt);
    },
    hasComments(item) {
      return item.userNotesCount > 0;
    },
    useConvertReportType(reportType) {
      return convertReportType(reportType);
    },
    handleSortChange({ sortBy, sortDesc }) {
      this.$emit('update:sort', { sortBy, sortDesc });
    },
    containerImageAndTag(item) {
      return item.location?.image;
    },
    containerImageAndTagUrl(item) {
      return item.location?.containerRepositoryUrl;
    },
    getImageText(item) {
      return sprintf(this.$options.i18n.image, {
        image: this.containerImageAndTag(item),
      });
    },
    getLastSeverityOverride(item) {
      return item?.nodes?.[0] || {};
    },
  },
};
</script>

<template>
  <div>
    <portal :to="portalName">
      <selection-summary
        :selected-vulnerabilities="Object.values(selectedVulnerabilities)"
        :visible="shouldShowSelectionSummary"
        @cancel-selection="deselectAllVulnerabilities"
        @vulnerabilities-updated="deselectVulnerabilities"
      />
    </portal>

    <gl-table
      v-if="shouldShowTable"
      class="vulnerability-list"
      :busy="isLoading"
      :fields="displayFields"
      :items="vulnerabilities"
      :thead-class="{
        'below-selection-summary': shouldShowSelectionSummary,
        'gl-bg-default': true,
      }"
      :sort-desc="sort.sortDesc"
      :sort-by="sort.sortBy"
      no-local-sorting
      stacked="sm"
      hover
      primary-key="id"
      :tbody-tr-class="{ 'gl-cursor-pointer': canAdminVulnerability }"
      head-variant="white"
      @sort-changed="handleSortChange"
      @row-clicked="toggleVulnerability"
    >
      <template #head(checkbox)>
        <gl-form-checkbox
          class="gl-table-cell gl-min-h-0"
          data-testid="vulnerability-checkbox-all"
          :checked="hasSelectedAllVulnerabilities"
          :indeterminate="hasSelectedSomeVulnerabilities"
          @change="toggleAllVulnerabilities"
        >
          <span class="gl-sr-only">{{ __('Select all vulnerabilities on current page') }}</span>
        </gl-form-checkbox>
      </template>

      <template #cell(checkbox)="{ item }">
        <gl-form-checkbox
          class="vulnerability-status-checkbox gl-pointer-events-none gl-inline"
          data-testid="vulnerability-checkbox"
          :checked="isSelected(item)"
          @change="toggleVulnerability(item)"
        >
          <span class="gl-sr-only">{{ __('Select vulnerability') }}</span>
        </gl-form-checkbox>
      </template>

      <template #cell(detected)="{ item }">
        <time v-gl-tooltip :data-testid="`detected-${item.id}`" :title="formatDateTooltip(item)">
          {{ formatDate(item) }}
        </time>
      </template>

      <template #cell(state)="{ item }">
        <vulnerability-list-status
          class="gl-justify-end"
          :state="item.state"
          :dismissal-reason="item.dismissalReason"
          :data-qa-status-description="item.title || item.name"
          data-testid="vulnerability-status-content"
        />
      </template>

      <template #cell(severity)="{ item }">
        <severity-badge
          class="js-severity"
          :severity="item.severity"
          :severity-override="getLastSeverityOverride(item.severityOverrides)"
          :show-severity-overrides="true"
        />
        <security-scores
          :cve-enrichment="item.cveEnrichment"
          :cvss="item.cvss"
          :reachability="item.reachability"
          :data-testid="`security-scores-${item.id}`"
        />
      </template>

      <template #cell(title)="{ item }">
        <div
          class="gl-align-items-end gl-flex gl-flex-col sm:!gl-flex-row sm:gl-items-center"
          :data-testid="`title-${item.id}`"
        >
          <gl-link
            class="vulnerability-title js-description gl-text-default"
            :href="item.vulnerabilityPath"
            :data-qa-vulnerability-description="item.title || item.name"
            data-testid="vulnerability"
            @click="$emit('vulnerability-clicked', item)"
          >
            {{ item.title || item.name }}
          </gl-link>
          <vulnerability-comment-icon v-if="hasComments(item)" :vulnerability="item" />
        </div>
        <div
          v-if="item.location"
          :data-testid="`location-${item.id}`"
          class="gl-text-sm gl-text-subtle"
        >
          <div v-if="shouldShowProjectNamespace">
            {{ item.project.nameWithNamespace }}
          </div>
          <vulnerability-path :location="item.location" />
        </div>
      </template>

      <template #cell(identifier)="{ item }">
        <div data-testid="vulnerability-identifier">
          {{ primaryIdentifier(item.identifiers) }}
        </div>
        <div
          v-if="shouldShowExtraIdentifierCount(item.identifiers)"
          data-testid="vulnerability-more-identifiers"
          class="gl-text-gray-300"
        >
          <gl-sprintf :message="__('+ %{count} more')">
            <template #count>
              {{ extraIdentifierCount(item.identifiers) }}
            </template>
          </gl-sprintf>
        </div>
      </template>

      <template #cell(reportType)="{ item }">
        <div
          :id="`vulnerability-scanner-name-tooltip-${item.id}`"
          data-testid="vulnerability-report-type"
          :class="{ 'gl-capitalize': item.reportType !== 'GENERIC' }"
        >
          <span
            v-if="glFeatures.vulnerabilityReportTypeScannerFilter"
            v-gl-tooltip
            :title="getScannerItemTooltip(item)"
            data-testid="vulnerability-scanner-name-tooltip"
          >
            {{ useConvertReportType(item.reportType) }}
          </span>
          <span v-else>
            {{ useConvertReportType(item.reportType) }}
          </span>
        </div>
        <div
          v-if="
            !glFeatures.vulnerabilityReportTypeScannerFilter &&
            hasAnyScannersOtherThanGitLab &&
            item.scanner
          "
          data-testid="vulnerability-vendor"
          class="gl-text-gray-300"
        >
          {{ item.scanner.vendor }}
        </div>
      </template>

      <template #cell(cluster)="{ item }">
        <gl-link
          v-if="hasCluster(item)"
          :data-testid="`cluster-${item.id}`"
          :href="clusterUrl(item)"
        >
          {{ clusterName(item) }}
        </gl-link>
      </template>

      <template #cell(activity)="{ item }">
        <div class="gl-flex gl-justify-end gl-gap-3">
          <archival-badge
            v-if="item.archivalInformation && item.archivalInformation.aboutToBeArchived"
            :expected-date="item.archivalInformation.expectedToBeArchivedOn"
          />
          <resolution-badge
            v-if="item.resolvedOnDefaultBranch"
            data-testid="vulnerability-resolution-badge-content"
            :data-qa-activity-description="item.title || item.name"
          />
          <issues-badge
            v-if="badgeIssues(item).length > 0"
            :issues="badgeIssues(item)"
            :is-jira="hasJiraVulnerabilitiesIntegrationEnabled"
            data-testid="vulnerability-issue-created-badge-content"
            :data-qa-badge-description="item.title || item.name"
          />
          <merge-request-badge v-if="item.mergeRequest" :merge-request="item.mergeRequest" />
          <false-positive-badge
            v-if="item.falsePositive"
            data-testid="false-positive-vulnerability"
          />
          <solution-badge v-if="item.hasRemediations" />
          <ai-resolution-badge
            v-if="
              item.aiResolutionAvailable &&
              item.aiResolutionEnabled &&
              glAbilities.resolveVulnerabilityWithAi
            "
          />
        </div>
      </template>

      <template #cell(imageAndTag)="{ item }">
        <gl-truncate
          v-if="containerImageAndTag(item)"
          :id="`image-and-tag-${item.id}-popover-target`"
          :data-testid="`image-and-tag-${item.id}`"
          :text="containerImageAndTag(item)"
          position="middle"
        />
        <gl-popover
          triggers="hover focus"
          :show-close-button="false"
          placement="top"
          :target="`image-and-tag-${item.id}-popover-target`"
          :data-testid="`image-and-tag-${item.id}-popover`"
        >
          <gl-sprintf :message="getImageText(item)">
            <template #link="{ content }">
              <gl-link :href="containerImageAndTagUrl(item)" target="_blank">
                <gl-friendly-wrap :text="content" />
              </gl-link>
            </template>
          </gl-sprintf>
        </gl-popover>
      </template>

      <template #table-busy>
        <gl-skeleton-loader v-for="n in pageSize" :key="n" :lines="2" />
      </template>
    </gl-table>

    <filters-produced-no-results v-else-if="hasVulnerabilities" />
    <dashboard-has-no-vulnerabilities v-else />
  </div>
</template>
