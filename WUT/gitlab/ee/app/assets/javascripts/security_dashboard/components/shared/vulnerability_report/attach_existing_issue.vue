<script>
import { GlButton } from '@gitlab/ui';
import { sprintf, s__ } from '~/locale';
import RelatedIssuableInput from '~/related_issues/components/related_issuable_input.vue';
import createVulnerabilityIssueLinkMutation from 'ee/security_dashboard/graphql/mutations/vulnerability_issue_link_create.mutation.graphql';
import workItemsByReferencesQuery from '~/work_items/graphql/work_items_by_references.query.graphql';
import toast from '~/vue_shared/plugins/global_toast';
import * as Sentry from '~/sentry/sentry_browser_wrapper';

export default {
  components: {
    RelatedIssuableInput,
    GlButton,
  },
  inject: {
    vulnerabilitiesQuery: {
      required: true,
    },
    vulnerabilitiesCountsQuery: {
      required: false,
      default: null,
    },
    fullPath: {
      required: true,
    },
  },
  props: {
    selectedVulnerabilities: {
      type: Array,
      required: true,
    },
  },
  data() {
    return {
      isSubmitting: false,
      value: '',
      pendingReferences: [],
    };
  },
  computed: {
    autoCompleteSources() {
      return gl.GfmAutoComplete?.dataSources;
    },
    vulnerabilityIds() {
      return this.selectedVulnerabilities.map((vuln) => vuln.id);
    },
  },
  methods: {
    async handleSubmit() {
      if (this.pendingReferences.length === 0) {
        return;
      }

      try {
        this.isSubmitting = true;
        // we need to use a constant here, because by the time we are at handleToast, refetchQueries will
        // have caused VulnerabilityList to already update the selected vulnerabilities.
        const nrVulnerabilities = this.vulnerabilityIds.length;
        this.$emit('clear-rejected');

        const workItems = await this.fetchWorkItems();
        await this.linkVulnerabilitiesToWorkItems(workItems);

        this.handleToast(nrVulnerabilities, workItems.length);
        this.resetForm();
      } catch (error) {
        this.handleError(error);
      } finally {
        this.isSubmitting = false;
      }
    },
    async fetchWorkItems() {
      const { data } = await this.$apollo.query({
        query: workItemsByReferencesQuery,
        variables: {
          contextNamespacePath: this.fullPath,
          refs: this.pendingReferences,
        },
      });
      return data.workItemsByReference.nodes;
    },
    async linkVulnerabilitiesToWorkItems(workItems) {
      const linkPromises = workItems.map(async ({ id: issueId }) => {
        const { data } = await this.$apollo.mutate({
          mutation: createVulnerabilityIssueLinkMutation,
          variables: {
            vulnerabilityIds: this.vulnerabilityIds,
            issueId,
          },
          refetchQueries: [this.vulnerabilitiesQuery, this.vulnerabilitiesCountsQuery],
          awaitRefetchQueries: true,
        });

        const { errors } = data.vulnerabilityIssueLinkCreate;
        if (errors?.length > 0) {
          throw errors;
        }
      });
      await Promise.all(linkPromises);
      this.$emit('vulnerabilities-updated', this.vulnerabilityIds);
    },
    resetForm() {
      this.value = '';
      this.pendingReferences = [];
    },
    handleError(error) {
      Sentry.captureException(error);
      this.$emit('update-rejected', this.selectedVulnerabilities);
    },
    onInput({ untouchedRawReferences, touchedReference }) {
      const issues = this.pendingReferences.concat(untouchedRawReferences);
      this.pendingReferences = issues.filter((ref, index) => issues.indexOf(ref) === index);

      this.formatInput(touchedReference);
    },
    onRemove(indexToRemove) {
      this.pendingReferences = this.pendingReferences.filter(
        (_ref, index) => index !== indexToRemove,
      );
    },
    formatInput(touchedReference = '') {
      const startsWithNumber = /^\d/.test(touchedReference);

      if (startsWithNumber) {
        this.value = `${this.$options.pathIdSeparator}${touchedReference}`;
      } else {
        this.value = touchedReference;
      }
    },
    handleToast(nrVulnerabilities, nrIssues) {
      let message = s__('SecurityReports|1 vulnerability attached to 1 issue');
      if (nrVulnerabilities > 1 && nrIssues === 1) {
        message = s__('SecurityReports|%{nrVulnerabilities} vulnerabilities attached to 1 issue');
      } else if (nrIssues > 1 && nrVulnerabilities === 1) {
        message = s__('SecurityReports|1 vulnerability attached to %{nrIssues} issues');
      } else if (nrIssues > 1 && nrVulnerabilities > 1) {
        message = s__(
          'SecurityReports|%{nrVulnerabilities} vulnerabilities attached to %{nrIssues} issues',
        );
      }

      toast(sprintf(message, { nrVulnerabilities, nrIssues }));
    },
  },
  autoCompleteOptions: {
    issues: true,
  },
  pathIdSeparator: '#',
};
</script>

<template>
  <form
    class="gl-flex gl-flex-grow gl-flex-wrap gl-items-start gl-gap-3"
    @submit.prevent="handleSubmit"
  >
    <related-issuable-input
      input-id="existing_issue_attach_vulnerability"
      :input-value="value"
      :references="pendingReferences"
      :auto-complete-sources="autoCompleteSources"
      focus-on-mount
      inline
      :auto-complete-options="$options.autoCompleteOptions"
      :path-id-separator="$options.pathIdSeparator"
      class="gl-mb-0 gl-flex-grow"
      @addIssuableFormInput="onInput"
      @pendingIssuableRemoveRequest="onRemove"
    />
    <gl-button
      class="gl-ml-auto"
      :disabled="isSubmitting"
      data-testid="cancel-add-to-existing-button"
      @click="$emit('cancel')"
    >
      {{ __('Cancel') }}
    </gl-button>
    <gl-button
      data-testid="add-to-existing-button"
      type="submit"
      variant="confirm"
      :loading="isSubmitting"
      class="js-no-auto-disable"
    >
      {{ __('Add') }}
    </gl-button>
  </form>
</template>
