# frozen_string_literal: true

module EE
  module Vulnerability
    include Todoable
    extend ActiveSupport::Concern

    RETENTION_PERIOD = 12.months

    prepended do
      include ::Ai::Model
      include ::CacheMarkdownField
      include ::Redactable
      include ::StripAttribute
      include ::Noteable
      include ::Mentionable
      include ::Awardable
      include ::Referable
      include ::Presentable
      include ::Gitlab::SQL::Pattern
      include ::VulnerabilityScopes
      include ::Gitlab::Utils::StrongMemoize
      include ::Elastic::ApplicationVersionedSearch

      extend ::Gitlab::Utils::Override

      ACTIVE_STATES = %w[detected confirmed].freeze
      PASSIVE_STATES = %w[dismissed resolved].freeze
      # Manually resolvable report types cannot be considered fixed once removed from the
      # target branch due to requiring active triage, such as rotation of an exposed token.
      REPORT_TYPES_REQUIRING_MANUAL_RESOLUTION = %w[generic secret_detection].freeze
      SUMMARY_DELIMITER = '|'
      REGEX_CAPTURING_STATUS = /\A[\w+\s]+to\s(?<status>\w+)/

      after_commit :trigger_webhook_event, on: [:create, :destroy]

      attribute :detected_at, :datetime, default: Time.current

      cache_markdown_field :title, pipeline: :single_line
      cache_markdown_field :description, issuable_reference_expansion_enabled: true

      strip_attributes! :title

      redact_field :description

      belongs_to :project # keep this association named 'project' for correct work of markdown cache
      belongs_to :author, class_name: 'User' # keep this association named 'author' for correct work of markdown cache
      belongs_to :resolved_by, class_name: 'User'
      belongs_to :dismissed_by, class_name: 'User'
      belongs_to :confirmed_by, class_name: 'User'

      has_one :group, through: :project
      has_one :vulnerability_read, class_name: '::Vulnerabilities::Read', inverse_of: :vulnerability
      has_one :representation_information, class_name: '::Vulnerabilities::RepresentationInformation'

      belongs_to :vulnerability_finding, class_name: '::Vulnerabilities::Finding',
        foreign_key: :finding_id, inverse_of: :one_vulnerability, optional: false

      has_many :findings, class_name: '::Vulnerabilities::Finding', inverse_of: :vulnerability
      has_many :dismissed_findings, -> { dismissed }, class_name: '::Vulnerabilities::Finding', inverse_of: :vulnerability
      has_many :merge_request_links, class_name: '::Vulnerabilities::MergeRequestLink', inverse_of: :vulnerability
      has_many :merge_requests, disable_joins: true, through: :merge_request_links
      has_many :external_issue_links, class_name: '::Vulnerabilities::ExternalIssueLink', inverse_of: :vulnerability
      has_many :issue_links, class_name: '::Vulnerabilities::IssueLink', inverse_of: :vulnerability
      has_many :related_issues, through: :issue_links, source: :issue, disable_joins: true
      has_many :state_transitions, class_name: '::Vulnerabilities::StateTransition', inverse_of: :vulnerability
      has_many :severity_overrides, class_name: '::Vulnerabilities::SeverityOverride', inverse_of: :vulnerability
      has_one  :latest_severity_override, -> { latest }, class_name: 'Vulnerabilities::SeverityOverride', inverse_of: :vulnerability

      has_many :notes, as: :noteable
      has_many :user_mentions, class_name: 'VulnerabilityUserMention'

      has_many :sbom_occurrences_vulnerabilities,
        class_name: 'Sbom::OccurrencesVulnerability',
        foreign_key: :vulnerability_id,
        inverse_of: :vulnerability

      has_many :sbom_occurrences, through: :sbom_occurrences_vulnerabilities, class_name: 'Sbom::Occurrence', source: :occurrence

      enum :state, ::Enums::Vulnerability.vulnerability_states
      enum :severity, ::Enums::Vulnerability.severity_levels, prefix: :severity
      enum :report_type, ::Enums::Vulnerability.report_types

      validates :project, :author, :title, :severity, :report_type, presence: true

      # at this stage Vulnerability is not an Issuable, has some important attributes (and their constraints) in common
      validates :title, length: { maximum: ::Issuable::TITLE_LENGTH_MAX }
      validates :description, length: { maximum: ::Issuable::DESCRIPTION_LENGTH_MAX }, allow_blank: true

      scope :with_latest_severity_override, -> { includes(:latest_severity_override) }

      scope :joins_vulnerability_read, -> { joins(:vulnerability_read) }
      scope :with_dismissal_reason, ->(dismissal_reason) { joins_vulnerability_read.where(vulnerability_reads: { dismissal_reason: dismissal_reason }) }
      scope :with_author, -> { preload(:author) }
      scope :with_author_and_project, -> { includes(:author, :project) }
      scope :with_findings, -> { includes(:findings) }
      scope :with_triaging_users, -> { preload(:resolved_by, :dismissed_by, :confirmed_by) }
      scope :with_state_transitions, -> { includes(:state_transitions) }
      scope :with_findings_by_uuid, ->(uuid) { with_findings.where(findings: { uuid: uuid }) }
      scope :with_findings_by_uuid_and_state, ->(uuid, state) { with_findings.where(findings: { uuid: uuid }, state: state) }
      scope :with_findings_excluding_uuid, ->(uuid) { joins(:findings).merge(Vulnerabilities::Finding.excluding_uuids(uuid)) }
      scope :with_findings_scanner_and_identifiers, -> { includes(findings: [:scanner, :identifiers, { finding_identifiers: :identifier }]) }
      scope :with_findings_scanner_identifiers_and_notes, -> { with_findings_scanner_and_identifiers.includes(:notes) }
      scope :with_report_types, ->(report_types) { where(report_type: report_types) }
      scope :with_severities, ->(severities) { where(severity: severities) }
      scope :without_severities, ->(severities) { where.not(severity: severities) }
      scope :with_states, ->(states) { where(state: states) }
      scope :with_project, ->(project_id) { where(project: project_id) }
      scope :with_projects_and_routes, -> { includes(project: [:route, { project_namespace: :route }, { namespace: :route }]) }
      scope :with_scanner_external_ids, ->(scanner_external_ids) { joins(findings: :scanner).merge(::Vulnerabilities::Scanner.with_external_id(scanner_external_ids)) }
      scope :grouped_by_severity, -> { reorder(severity: :desc).group(:severity) }
      scope :by_primary_identifier_ids, ->(identifier_ids) do
        joins(findings: :primary_identifier)
          .where(
            findings: {
              vulnerability_identifiers: {
                id: identifier_ids
              }
            }
          )
      end
      scope :by_scanner_ids, ->(scanner_ids) { joins(:findings).merge(::Vulnerabilities::Finding.by_scanners(scanner_ids)) }
      scope :created_in_time_range, ->(from: nil, to: nil) { where(created_at: from..to) }
      scope :with_resolution, ->(has_resolution = true) { where(resolved_on_default_branch: has_resolution) }
      scope :with_issues, ->(has_issues = true) do
        exist_query = has_issues ? 'EXISTS (?)' : 'NOT EXISTS (?)'
        issue_links = ::Vulnerabilities::IssueLink.arel_table

        where(exist_query, ::Vulnerabilities::IssueLink.select(1).where(issue_links[:vulnerability_id].eq(arel_table[:id])))
      end

      scope :autocomplete_search, ->(query) do
        return self if query.blank?

        id_as_text = Arel::Nodes::NamedFunction.new('CAST', [arel_table[:id].as('TEXT')])

        fuzzy_search(query, [:title])
          .or(where(id_as_text.matches("%#{sanitize_sql_like(query.squish)}%")))
      end

      scope :order_severity_asc, -> { reorder(severity: :asc, id: :desc) }
      scope :order_severity_desc, -> { reorder(severity: :desc, id: :desc) }
      scope :order_created_at_asc, -> { reorder(created_at: :asc, id: :desc) }
      scope :order_created_at_desc, -> { reorder(created_at: :desc, id: :desc) }
      scope :order_id_desc, -> { reorder(id: :desc) }

      scope :with_limit, ->(maximum) { limit(maximum) }
      scope :with_container_image, ->(images) do
        joins(:findings).merge(Vulnerabilities::Finding.by_location_image(images))
      end
      scope :with_cluster_ids, ->(cluster_ids) do
        joins(:findings).merge(Vulnerabilities::Finding.by_location_cluster(cluster_ids))
      end
      scope :with_cluster_agent_ids, ->(agent_ids) do
        joins(:findings).merge(Vulnerabilities::Finding.by_location_cluster_agent(agent_ids))
      end
      scope :with_false_positive, ->(false_positive = true) do
        joins(:findings).merge(Vulnerabilities::Finding.with_false_positive(false_positive))
      end
      scope :with_fix_available, ->(fix_available = true) do
        joins(:findings).merge(Vulnerabilities::Finding.with_fix_available(fix_available))
      end

      scope :for_default_branch, ->(present_on_default_branch = true) { where(present_on_default_branch: present_on_default_branch) }
      scope :present_on_default_branch, -> { where('present_on_default_branch IS TRUE') }

      scope :by_ids, ->(ids) { where(id: ids) }
      scope :by_age, ->(operator, days) do
        case operator
        when :greater_than then created_before(days.days.ago)
        when :less_than then created_after(days.days.ago)
        end
      end

      scope :created_after, ->(days_ago) { where(model.arel_table[:created_at].gteq(days_ago)) }
      scope :created_before, ->(days_ago) { where(model.arel_table[:created_at].lteq(days_ago)) }

      scope :with_latest_state_transition, -> do
        last_state_transition = Vulnerabilities::StateTransition.where(arel_table[:id].eq(Vulnerabilities::StateTransition.arel_table[:vulnerability_id])).order(id: :desc).limit(1)
        includes(:state_transitions).where(state_transitions: { id: last_state_transition })
      end

      scope :preload_transition_author, -> { includes(state_transitions: :author) }

      scope :in_optimization_array_mapping_scope, ->(id_expression) { where(arel_table[:project_id].eq(id_expression)) }
      scope :in_optimization_finder_query, ->(_, id_expression) { where(arel_table[:id].eq(id_expression)) }

      scope :not_requiring_manual_resolution, -> { where.not(requiring_manual_resolution.where_values_hash) }
      scope :requiring_manual_resolution, -> { where(report_type: REPORT_TYPES_REQUIRING_MANUAL_RESOLUTION) }

      scope :last_updated_before, ->(date) { where(updated_at: ...date) }
      scope :with_archival_related_entities, -> { includes(:vulnerability_read, :notes, findings: [:identifiers, :scanner]) }
      scope :with_mrs_and_issues, -> { includes(:merge_requests, :related_issues) }

      delegate :scanner_name, :scanner_external_id, :scanner_id, :metadata, :description, :description_html, :details, :uuid,
        to: :finding, prefix: true, allow_nil: true
      delegate :initial_finding_pipeline, :latest_finding_pipeline, to: :finding, allow_nil: true

      delegate :default_branch, :name, to: :project, prefix: true, allow_nil: true
      delegate :name, to: :group, prefix: true, allow_nil: true

      delegate :solution, :identifiers, :links, :remediations, :file,
        :cve_value, :cwe_value, :other_identifier_values, :location,
        to: :finding, allow_nil: true

      delegate :file, to: :finding, prefix: true, private: true

      delegate :dismissal_reason, to: :vulnerability_read, prefix: true, allow_nil: true
      delegate :vulnerability_archival_enabled?, to: :project

      def archive?(date)
        present_on_default_branch? && updated_at <= date && !has_mr_or_issue_updated_after?(date)
      end

      def about_to_be_archived?
        vulnerability_archival_enabled? && updated_at <= (RETENTION_PERIOD - 1.month).ago
      end

      def expected_to_be_archived_on
        return unless vulnerability_archival_enabled?

        expected_archival_date = (updated_at + RETENTION_PERIOD).next_month.beginning_of_month

        return expected_archival_date if expected_archival_date.future?

        Time.zone.now.next_month.beginning_of_month
      end

      def cvss_vectors_with_vendor
        cvss.map { |cvss| "#{cvss['vendor']}=#{cvss['vector']}" }
      end

      def full_path
        "#{project.full_path}/#{id}"
      end

      def to_reference(from = nil, full: false)
        project
          .to_reference_base(from, full: full)
          .then { |reference_base| reference_base.present? ? "#{reference_base}/" : nil }
          .then { |reference_base| "#{self.class.reference_prefix}#{reference_base}#{id}#{self.class.reference_postfix}" }
      end

      # There will only be one finding associated with a vulnerability for the foreseeable future
      def finding
        findings.first
      end

      def has_remediations?
        remediations&.any? || false
      end

      def sbom_occurrences_with_dependency_paths_data(limit:)
        sbom_occurrences.with_dependency_paths_existence.order_by_id.limit(limit)
      end

      def resource_parent
        project
      end

      def discussions_rendered_on_frontend?
        true
      end

      def user_notes_count
        user_notes_count_service.count
      end

      def after_note_changed(note)
        user_notes_count_service.delete_cache unless note.system?
      end
      alias_method :after_note_created,   :after_note_changed
      alias_method :after_note_destroyed, :after_note_changed

      def stat_diff
        ::Vulnerabilities::StatDiff.new(self)
      end

      def blob_path
        return unless finding_file

        ::Gitlab::Routing.url_helpers.project_blob_path(project, File.join(finding.sha, finding_file))
      end

      def execute_hooks
        project.execute_integrations(integration_data, :vulnerability_hooks)
        trigger_webhook_event
      end

      def notes_summary
        @notes_summary ||= discussions_for_summary.map do |discussion|
          status = extracted_status(discussion.notes.first.note)
          discussion.notes.map do |note|
            note_as_string(note.last_edited_at.utc, note.updated_by_or_author.username, status, note.note)
          end
        end.join('; ')
      end

      def latest_state_transition
        @latest_state_transition ||= state_transitions.last
      end

      def latest_state_transition_if_dismissed
        latest_state_transition if dismissed?
      end

      # There is no attribute called `traversal_ids` for the vulnerability
      # model. We need to override this AR method to return the value from
      # associated vulnerability_read object.
      # This is used by `Gitlab::Pagination::Keyset::Order`.
      def read_attribute(attribute_name)
        return super if attribute_name.to_s != 'traversal_ids'

        vulnerability_read.traversal_ids
      end

      def trigger_webhook_event
        return unless project.has_active_hooks?(:vulnerability_hooks)

        hook_data = ::Gitlab::DataBuilder::Vulnerability.build(self)
        project.execute_hooks(hook_data, :vulnerability_hooks)
      end

      def reachability
        return unless dependency_scanning?
        return ::Enums::Sbom::IN_USE if sbom_occurrences.filter_by_reachability(:in_use).exists?
        return ::Enums::Sbom::NOT_FOUND if sbom_occurrences.filter_by_reachability(:not_found).exists?

        ::Enums::Sbom::UNKNOWN
      end

      # Can return nil if the Vulnerabilities::Read has not yet been ingested,
      # meaning the `vulnerability_read` association is not present.
      # In this context, nil indicates undefined.
      def ai_resolution_enabled?
        vulnerability_read&.has_vulnerability_resolution
      end

      # NOTE:
      # 1. For On-premise, post MVC. We may have to honour the setting of skipping indexing for selected projects. Tracked in https://gitlab.com/gitlab-org/gitlab/-/issues/525484.
      # 2. For updates, unlike Vulnerabilities::Read we always call track! since `updated_at` is an indexed field.
      override :use_elasticsearch?
      def use_elasticsearch?
        ::Search::Elastic::VulnerabilityIndexingHelper.vulnerability_indexing_allowed?
      end

      def elastic_reference
        ::Search::Elastic::References::Vulnerability.new(id,
          Vulnerabilities::Read.generate_es_parent(project)).serialize
      end

      private

      def has_mr_or_issue_updated_after?(date)
        (merge_requests + related_issues).any? { |mr_or_issue| mr_or_issue.updated_at >= date }
      end

      def discussions_for_summary
        # Notable#discussions has inc_relations_for_view which
        # preloads a bunch of associations that we don't use.
        Discussion.build_collection(notes, self)
          .each { |discussion| discussion.notes.sort_by!(&:id) }
          .sort_by { |discussion| discussion.first_note.id }
      end

      def note_as_string(time, username, status, text)
        CSV.generate(col_sep: SUMMARY_DELIMITER) do |csv|
          csv << [time, username, status, text]
        end
      end

      def extracted_status(note)
        match_data = note.match(REGEX_CAPTURING_STATUS)
        return '' unless match_data

        match_data[:status]
      end

      def integration_data
        @integration_data ||= ::Gitlab::DataBuilder::Vulnerability.build(self)
      end

      def user_notes_count_service
        @user_notes_count_service ||= ::Vulnerabilities::UserNotesCountService.new(self)
      end
    end

    class_methods do
      def reference_pattern
        @reference_pattern ||= %r{
          #{Regexp.escape(reference_prefix)}(#{::Project.reference_pattern}\/)?(?<vulnerability>\d+)#{Regexp.escape(reference_postfix)}
        }x
      end

      def link_reference_pattern
        %r{
          (?<url>
            #{Regexp.escape(::Gitlab.config.gitlab.url)}
            \/#{::Project.reference_pattern}
            (?:\/\-)
            \/security\/vulnerabilities
            \/(?<vulnerability>\d+)
            (?<path>
              (\/[a-z0-9_=-]+)*\/*
            )?
            (?<anchor>\#[a-z0-9_-]+)?
          )
        }x
      end

      def parent_class
        ::Project
      end

      def to_ability_name
        model_name.singular
      end

      def report_type_order
        report_types
          .sort
          .to_h
          .values
          .each
          .with_index
          .reduce(Arel::Nodes::Case.new(arel_table[:report_type])) do |node, (value, index)|
          node.when(value).then(index)
        end
      end

      def state_order
        Arel::Nodes::NamedFunction.new(
          'ARRAY_POSITION',
          [
            Arel.sql("ARRAY#{states.values}::smallint[]"),
            arel_table[:state]
          ]
        )
      end

      def active_states
        ACTIVE_STATES
      end

      def passive_states
        PASSIVE_STATES
      end

      def active_state_values
        states.values_at(*active_states)
      end

      def order_by(method)
        case method.to_s
        when 'severity_desc' then order_severity_desc
        when 'severity_asc' then order_severity_asc
        when 'detected_desc' then order_created_at_desc
        when 'detected_asc' then order_created_at_asc
        else
          order_severity_desc
        end
      end

      def with_keyset_order(arel_function, name, direction, tie_breaker_direction = nil)
        raise "unknown sort direction given: #{direction}" unless %i[asc desc].include?(direction)

        if tie_breaker_direction.present? && %i[asc desc].exclude?(tie_breaker_direction)
          raise "unknown tie breaker sort direction given: #{tie_breaker_direction}"
        end

        ::Gitlab::Pagination::Keyset::Order.build(
          [
            ::Gitlab::Pagination::Keyset::ColumnOrderDefinition.new(
              attribute_name: name,
              order_expression: arel_function.public_send(direction), # rubocop: disable GitlabSecurity/PublicSend
              nullable: :not_nullable,
              order_direction: direction,
              add_to_projections: true
            ),
            ::Gitlab::Pagination::Keyset::ColumnOrderDefinition.new(
              attribute_name: 'id',
              order_expression: arel_table[:id].public_send(tie_breaker_direction || direction), # rubocop: disable GitlabSecurity/PublicSend
              nullable: :not_nullable
            )
          ])
      end
    end
  end
end
