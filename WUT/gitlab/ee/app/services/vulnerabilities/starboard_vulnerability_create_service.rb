# frozen_string_literal: true

module Vulnerabilities
  class StarboardVulnerabilityCreateService < CreateServiceBase
    include Gitlab::Allowable

    CLUSTER_IMAGE_SCANNING_REPORT_TYPE = ::Enums::Vulnerability.report_types[:cluster_image_scanning]
    METADATA_VERSION = "cluster_image_scanning:1.0"

    attr_reader :agent

    def initialize(agent, params:)
      super(agent.project, agent.created_by_user, params: params)

      @agent = agent
    end

    def execute
      raise Gitlab::Access::AccessDeniedError unless authorized?

      vulnerability_hash = @params[:vulnerability]
      vulnerability = initialize_vulnerability(vulnerability_hash)
      identifiers = initialize_identifiers(@params.dig(:vulnerability, :identifiers))
      scanner = initialize_scanner(@params[:scanner])
      finding = initialize_finding(
        vulnerability: vulnerability,
        identifiers: identifiers,
        scanner: scanner,
        description: vulnerability_hash[:description],
        solution: vulnerability_hash[:solution]
      )

      existing_vulnerability = Vulnerability.with_findings_by_uuid(finding.uuid).first
      return handle_existing_vulnerability(existing_vulnerability) if existing_vulnerability

      unless validate_quota!
        return ServiceResponse.error(
          message: "Vulnerability count has passed its limit. Vulnerabilities cannot be created."
        )
      end

      vulnerability_service_response = Vulnerability.transaction do
        finding.save!
        vulnerability.vulnerability_finding = finding
        vulnerability.save!
        finding.update!(vulnerability_id: vulnerability.id)

        vulnerability.vulnerability_read.update!(traversal_ids: project.namespace.traversal_ids)
        update_security_statistics!

        Vulnerabilities::StatisticsUpdateService.update_for(vulnerability)

        ServiceResponse.success(payload: { vulnerability: vulnerability })
      end

      Project.transaction do
        agent.update!(has_vulnerabilities: true) unless agent.has_vulnerabilities?
        project.mark_as_vulnerable!
      end

      process_archival_and_traversal_ids_changes if vulnerability_service_response&.success?

      vulnerability_service_response
    rescue ActiveRecord::RecordInvalid => e
      ServiceResponse.error(message: e.message)
    end

    private

    def report_type
      CLUSTER_IMAGE_SCANNING_REPORT_TYPE
    end

    def metadata_version
      METADATA_VERSION
    end

    def location_fingerprint(location_hash)
      kubernetes_resource = location_hash[:kubernetes_resource]
      fingerprint_data = [
        @agent.id,
        kubernetes_resource[:namespace],
        kubernetes_resource[:kind],
        kubernetes_resource[:name],
        kubernetes_resource[:container],
        location_hash.dig(:dependency, :package, :name)
      ].join(':')

      Digest::SHA1.hexdigest(fingerprint_data)
    end

    def initialize_vulnerability(vulnerability_hash)
      vulnerability_hash[:state] = :detected
      super(vulnerability_hash)
    end

    def handle_existing_vulnerability(vulnerability)
      return ServiceResponse.success(payload: { vulnerability: vulnerability }) unless vulnerability.resolved?

      reverted_vulnerability = Vulnerabilities::RevertToDetectedService.new(author, vulnerability, "").execute

      if reverted_vulnerability.detected?
        ServiceResponse.success(payload: { vulnerability: reverted_vulnerability })
      else
        ServiceResponse.error(message: "Failed to revert vulnerability status",
          payload: { vulnerability: vulnerability })
      end
    end
  end
end
