# frozen_string_literal: true

module Security
  module Ingestion
    module Tasks
      # Ingests the data for the `Vulnerabilities::Statistic` model.
      #
      # This ingestion task is neither `BulkInsertable` nor `BulkUpdatable` like
      # the rest of the ingestion tasks.
      # The data stored in the `vulnerability_statistics` table is incremental
      # therefore we need a different type of UPSERT query which is not supported
      # by ActiveRecord yet.
      class IngestVulnerabilityStatistics < AbstractTask
        TARGET_VALUES = "(TARGET.critical, TARGET.unknown, TARGET.high, TARGET.medium, TARGET.low)"
        EXCLUDED_VALUES = "(EXCLUDED.critical, EXCLUDED.unknown, EXCLUDED.high, EXCLUDED.medium, EXCLUDED.low)"
        UPSERT_SQL_TEMPLATE = <<~SQL
          INSERT INTO #{Vulnerabilities::Statistic.table_name}
            AS target (project_id, archived, traversal_ids, letter_grade, created_at, updated_at, %{insert_attributes})
            %{values_sql}
          ON CONFLICT (project_id)
            DO UPDATE SET
              %{update_values},
              letter_grade = (#{Vulnerabilities::Statistic.letter_grade_sql_for(TARGET_VALUES, EXCLUDED_VALUES)}),
              updated_at = now()
        SQL

        def execute
          return unless severity_counts.present?

          connection.execute(upsert_sql)
        end

        private

        delegate :connection, to: ::Vulnerabilities::Statistic, private: true
        delegate :quote_column_name, to: :connection, private: true

        def upsert_sql
          format(
            UPSERT_SQL_TEMPLATE,
            insert_attributes: insert_attributes,
            values_sql: values_sql,
            update_values: update_values
          )
        end

        def values_sql
          Arel::Nodes::ValuesList.new(insert_values).to_sql
        end

        def insert_attributes
          severity_levels.map { |key| quote_column_name(key) }.join(', ')
        end

        def insert_values
          severity_counts.map do |project, counts|
            [
              project.id,
              project.archived,
              "{#{project.namespace.traversal_ids_as_sql}}",
              letter_grade(counts),
              Arel.sql('now()'),
              Arel.sql('now()')
            ].concat(severity_levels.map { |sev| counts[sev] })
          end
        end

        def update_values
          severity_levels.map do |severity|
            safe_severity = quote_column_name(severity)
            "#{safe_severity} = TARGET.#{safe_severity} + EXCLUDED.#{safe_severity}"
          end.join(', ')
        end

        # We have a `before_save` callback in `Vulnerabilities::Statistic` model
        # but the `before_save` callbacks are not invocated by the `BulkInsertSafe` module
        # so we have to calculate it here.
        def letter_grade(counts)
          Vulnerabilities::Statistic.letter_grade_for(counts)
        end

        def severity_levels
          @severity_levels ||= ::Enums::Vulnerability.severity_levels.keys.map(&:to_s).prepend("total")
        end

        def severity_counts
          @severity_counts ||= finding_maps
            .select(&:new_or_transitioned_to_detected?)
            .group_by(&:project)
            .transform_values { |finding_maps| fill_in_zeros(finding_maps.map(&:severity).tally) }
        end

        def fill_in_zeros(counts)
          severity_levels.each do |key|
            counts[key] ||= 0
          end

          counts["total"] = counts.values.sum
          counts
        end
      end
    end
  end
end
