# frozen_string_literal: true

module Security
  module Ingestion
    module Tasks
      class IngestVulnerabilityReads
        # Updates the existing vulnerability_reads records
        # by using a single database query.
        class Update < AbstractTask
          include Gitlab::Ingestion::BulkUpdatableTask

          self.model = Vulnerabilities::Read

          private

          def attributes
            @attributes ||= finding_maps.filter_map do |finding_map|
              attributes = {
                vulnerability_id: finding_map.vulnerability_id,
                has_vulnerability_resolution: has_ai_resolution?(finding_map),
                traversal_ids: finding_map.project.namespace.traversal_ids,
                archived: finding_map.project.archived,
                owasp_top_10: ::Vulnerabilities::Read::OWASP_TOP_10_DEFAULT,
                identifier_names: identifier_names(finding_map),
                scanner_id: finding_map.scanner_id
              }

              append_owasp_identifier_to(attributes, finding_map)

              next unless has_changes?(attributes)

              attributes
            end
          end

          def has_ai_resolution?(finding_map)
            report_type = finding_map.report_finding.report_type.to_s
            cwe_value = finding_map.identifiers.find(&:cwe?)&.name
            return false unless cwe_value

            ::Vulnerabilities::Finding::AI_ALLOWED_REPORT_TYPES.include?(report_type) &&
              ::Vulnerabilities::Finding::HIGH_CONFIDENCE_AI_RESOLUTION_CWES.include?(cwe_value&.upcase)
          end

          def append_owasp_identifier_to(attributes, finding_map)
            owasp_identifier = finding_map.identifiers.find do |identifier|
              identifier.external_type.casecmp?('owasp')
            end

            return unless owasp_identifier.present?

            attributes.merge!({ owasp_top_10: map_owasp_external_id(owasp_identifier.external_id) })
          end

          def identifier_names(finding_map)
            finding_map.identifiers.each_with_object([]) do |id, result|
              name = id.name
              result << name if name.present?
            end.sort
          end

          # The maximum set of observed external_id is having the label, year without the name. Eg: 'A5:2017'.
          # See: https://gitlab.com/gitlab-org/gitlab/-/issues/423557#note_1539490082
          def map_owasp_external_id(external_id)
            default_value = ::Vulnerabilities::Read::OWASP_TOP_10_DEFAULT

            return default_value unless valid_owasp_external_id?(external_id)

            ::Enums::Vulnerability.owasp_top_10.keys.find { |key| key.include?(external_id) } ||
              default_value
          end

          def valid_owasp_external_id?(external_id)
            arr = external_id.split(':')

            priority_label = arr.first
            year = arr.second ? arr.second[0..3] : nil

            return false if year.nil? || ::Enums::Vulnerability.owasp_years.exclude?(year)

            Enums::Vulnerability.owasp_categories.include?(priority_label)
          end

          def has_changes?(attributes)
            vulnerability_read = grouped_vulnerability_reads.fetch(attributes[:vulnerability_id])
            existing_attributes = vulnerability_read.attributes.symbolize_keys.slice(*attributes.keys)

            # Work around since the model_object.attributes return only human readable key value of AR Enum.
            if existing_attributes[:owasp_top_10] == 'undefined'
              existing_attributes[:owasp_top_10] = ::Vulnerabilities::Read::OWASP_TOP_10_DEFAULT
            end

            attributes != existing_attributes
          end

          def grouped_vulnerability_reads
            @grouped_vulnerability_reads ||= Vulnerabilities::Read.by_vulnerabilities(vulnerability_ids)
                                                                  .index_by(&:vulnerability_id)
          end

          def vulnerability_ids
            finding_maps.map(&:vulnerability_id)
          end
        end
      end
    end
  end
end
