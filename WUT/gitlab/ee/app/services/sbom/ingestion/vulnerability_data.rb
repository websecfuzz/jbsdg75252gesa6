# frozen_string_literal: true

module Sbom
  module Ingestion
    # VulnerabilityData fetches and caches vulnerability information,
    # needed in various sbom ingestion tasks, for a given set of
    # occurrence maps.
    #
    # The vulnerability information is fetched from the database using
    # a custom SQL query that involves building a CTE table from all
    # of the occurrence maps, which is then joined with the
    # vulnerability findings. The query results are memoized to
    # prevent additional database calls.
    #
    # Usage:
    #   vulnerability_data = VulnerabilityData.new(occurrence_maps, project)
    #   vulnerability_info = vulnerability_data.for(occurrence_map)
    #
    #   vulnerability_info.count # => 2                   defaults to 0
    #   vulnerability_info.highest_severity # => 3        defaults to nil
    #   vulnerability_info.vulnerability_ids # => [1, 2]  defaults to []
    class VulnerabilityData
      CONTAINER_IMAGE_PREFIX = "container-image:"

      def initialize(occurrence_maps, project)
        @occurrence_maps = occurrence_maps
        @project = project
      end

      def for(occurrence_map)
        key = key_for(occurrence_map)
        VulnerabilityInfo.new(vulnerabilities_info[key])
      end

      private

      attr_reader :occurrence_maps, :project

      def key_for(occurrence_map)
        [
          occurrence_map&.name,
          occurrence_map&.version,
          occurrence_map&.input_file_path&.delete_prefix(CONTAINER_IMAGE_PREFIX)
        ]
      end

      def vulnerabilities_info
        @vulnerabilities_info ||= fetch_vulnerabilities_info
      end

      def fetch_vulnerabilities_info
        # rubocop:disable CodeReuse/ActiveRecord -- highly customized query
        occurrence_maps_values = occurrence_maps.map { |om| key_for(om) }
        as_values = Arel::Nodes::ValuesList.new(occurrence_maps_values).to_sql

        # We don't use Gitlab::SQL::CTE (or Arel directly) because
        # this table is coming from a VALUES list
        cte_sql = "WITH occurrence_maps (name, version, path) AS (#{as_values})"

        select_sql = <<-SQL
           occurrence_maps.name,
           occurrence_maps.version,
           occurrence_maps.path,
           array_to_json(array_agg(vulnerability_occurrences.vulnerability_id)) as vulnerability_ids,
           MAX(vulnerability_occurrences.severity) as highest_severity,
           COUNT(vulnerability_occurrences.id) as vulnerability_count
        SQL

        join_sql = <<-SQL
          JOIN occurrence_maps
          ON occurrence_maps.name = (vulnerability_occurrences.location -> 'dependency' -> 'package' ->> 'name')::text
          AND occurrence_maps.version = (vulnerability_occurrences.location -> 'dependency' ->> 'version')::text
          AND occurrence_maps.path = COALESCE(
            vulnerability_occurrences.location ->> 'file',
            vulnerability_occurrences.location ->> 'image'
          )::text
        SQL

        query = ::Vulnerabilities::Finding
                  .select(select_sql)
                  .joins(join_sql)
                  .by_report_types(%i[container_scanning dependency_scanning])
                  .by_projects(project)
                  .group("occurrence_maps.name, occurrence_maps.version, occurrence_maps.path")

        full_query = [cte_sql, query.to_sql].join("\n")
        results = ::Vulnerabilities::Finding.connection.execute(full_query)

        results.each_with_object({}) do |row, result|
          key = row.values_at('name', 'version', 'path')
          value = {
            highest_severity: row['highest_severity'],
            vulnerability_count: row['vulnerability_count'],
            vulnerability_ids: ::Gitlab::Json.parse(row['vulnerability_ids']).filter_map do |id|
              id_i = id.to_i
              id_i if id_i > 0
            end
          }
          result[key] = value
        end
        # rubocop:enable CodeReuse/ActiveRecord
      end

      class VulnerabilityInfo
        def initialize(data)  = @data = data || {}
        def count             = @data[:vulnerability_count] || 0
        def highest_severity  = @data[:highest_severity]
        def vulnerability_ids = @data[:vulnerability_ids] || []
      end
    end
  end
end
