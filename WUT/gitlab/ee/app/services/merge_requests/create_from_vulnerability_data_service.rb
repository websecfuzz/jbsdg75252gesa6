# frozen_string_literal: true

module MergeRequests
  class CreateFromVulnerabilityDataService < ::BaseService
    include Gitlab::Utils::StrongMemoize

    START_OLD_CODE = '<old_code>'
    END_OLD_CODE = '</old_code>'
    START_NEW_CODE = '<new_code>'
    END_NEW_CODE = '</new_code>'

    InvalidLlmPatch = Class.new(StandardError)
    LlmRemediationFailure = Class.new(StandardError)
    MergeRequestCreationFailure = Class.new(StandardError)

    def initialize(project, vulnerability, user = nil, params = {})
      super(project, user, params)

      @vulnerability = vulnerability

      # rubocop: disable CodeReuse/Presenter -- Presenter methods are used in ERB presentation.
      @finding_presenter = Vulnerabilities::FindingPresenter.new(@vulnerability.finding)
      # rubocop: enable CodeReuse/Presenter
    end

    def execute
      return error("User is not permitted to create merge request") unless can_create_merge_request?
      return error("No remediations available for merge request") if no_remediations_available?

      service_response = if llm_patch.nil?
                           create_resolution_from_human_patch
                         else
                           validate_llm_patch!
                           create_resolution_from_llm_patch
                         end

      case service_response.to_h
      in status: :success
        # maybe log a success or workflow checkpoint?
        resolution_mr(source_branch, target_branch)
      else
        project.repository.delete_branch(source_branch)
        error('Unable to apply patch')
      end
    rescue MergeRequestCreationFailure => e
      project.repository.delete_branch(source_branch)
      error(e.message)
    rescue InvalidLlmPatch => e
      Gitlab::ErrorTracking.log_exception(e)
      error('Response unreadable', pass_back: { unreadable_response: true })
    end

    private

    attr_reader :vulnerability, :finding_presenter

    def can_create_merge_request?
      can?(@current_user, :create_merge_request_in, project) &&
        can?(@current_user, :create_merge_request_from, project)
    end

    def validate_llm_patch!
      raise InvalidLlmPatch, 'Patch from LLM is blank' if llm_patch.blank?
      raise InvalidLlmPatch, 'code tags not correct in response' unless llm_patch.include?(START_OLD_CODE)
      raise InvalidLlmPatch, 'code tags not correct in response' unless extract_changes_from_blocks.flatten.all?

      true
    end

    def create_resolution_from_human_patch
      Commits::CommitPatchService.new(
        project,
        @current_user,
        branch_name: source_branch,
        start_branch: target_branch,
        patches: [
          render_commit(
            vulnerability.remediations.map { |remediation| Base64.decode64(remediation.with_indifferent_access[:diff]) },
            head_commit,
            vulnerability
          )
        ]
      ).execute

    rescue StandardError => e
      Gitlab::ErrorTracking.log_exception(e)
      error(e.message)
    end

    def create_resolution_from_llm_patch
      Commits::CommitPatchService.new(
        project,
        @current_user,
        branch_name: source_branch,
        start_branch: target_branch,
        patches: [
          render_commit(
            [prepend_diff_structure(create_llm_diff_from_blocks)],
            head_commit,
            vulnerability
          )
        ]
      ).execute
    rescue StandardError => e
      Gitlab::ErrorTracking.log_exception(e)
      error(e.message)
    end

    def extract_changes_from_blocks
      old_code_regex = /(?<=#{Regexp.escape(START_OLD_CODE)}).*?(?=#{Regexp.escape(END_OLD_CODE)})/mo
      old_code_match_data = llm_patch.scan(old_code_regex)
      new_code_regex = /(?<=#{Regexp.escape(START_NEW_CODE)}).*?(?=#{Regexp.escape(END_NEW_CODE)})/mo
      new_code_match_data = llm_patch.scan(new_code_regex)

      old_code_match_data.zip(new_code_match_data)
    end
    strong_memoize_attr :extract_changes_from_blocks

    def resolution_mr(source_branch, target_branch)
      merge_request = MergeRequests::CreateService.new(
        project: project,
        current_user: @current_user,
        params: {
          title: "Resolve vulnerability: #{finding_presenter.name}",
          description: render_description(vulnerability),
          source_branch: source_branch,
          target_branch: target_branch,
          force_remove_source_branch: "1"
        }
      ).execute

      merge_request.valid? ? success(merge_request) : error(merge_request.errors)
    rescue StandardError => e
      Gitlab::ErrorTracking.log_exception(e)
      raise MergeRequestCreationFailure, e.message
    end

    def create_llm_diff_from_blocks
      changes = extract_changes_from_blocks
      fixed_code = finding_presenter.source_code.dup

      changes.each do |old_code, new_code|
        apply_remediation_service = ::Vulnerabilities::ApplyLlmRemediationService.new(old_code.strip, new_code.strip, fixed_code)

        case apply_remediation_service.execute.to_h
        in status: :success, patched_content: patched_source_code
          fixed_code = patched_source_code
        in status: :error, message: error_message
          raise LlmRemediationFailure, error_message
        end
      end

      # Diffy expects fixed_code to include a trailing newline
      # since we're stripping the newlines above, we add it here.
      create_llm_diff_from_given_code("#{fixed_code}\n")
    end

    def create_llm_diff_from_given_code(fixed_code)
      source_code = finding_presenter.source_code

      Diffy::Diff.new(source_code, fixed_code, include_diff_info: true, context: 2).to_s(:text).lines[2..].join
    end

    def prepend_diff_structure(diff)
      diff.prepend("+++ b/#{finding_presenter.file}\n")
      diff.prepend("--- a/#{finding_presenter.file}\n")
      diff.prepend("diff --git a/#{finding_presenter.file} b/#{finding_presenter.file}\n")

      diff
    end

    def render_description(vulnerability)
      ApplicationController.render(
        template: 'vulnerabilities/merge_request_description',
        formats: :md,
        locals: {
          vulnerability: vulnerability,
          llm_patch: llm_patch,
          finding: finding_presenter,
          description_options: params[:description_options]
        }
      )
    end

    def render_commit(diffs, head_commit, vulnerability)
      git_user = Gitlab::Git::User.from_gitlab(@current_user)

      ApplicationController.render(
        template: 'vulnerabilities/remediation',
        formats: :patch,
        locals: {
          diff: diffs.first,
          head_commit: head_commit,
          user: git_user,
          vulnerability: vulnerability,
          ai_generated: llm_patch.present?
        }
      )
    end

    def no_remediations_available?
      vulnerability.remediations.blank? && llm_patch.blank?
    end

    def llm_patch
      @llm_patch ||= params[:llm_patch]
    end

    def title_slug
      @title_slug ||= Gitlab::Utils.slugify(finding_presenter.name || "")
    end

    def source_branch
      @source_branch ||= "remediate/%s-%s" % [title_slug[0..74], Time.current.strftime("D%Y%m%dT%H%M%S")]
    end

    def target_branch
      @target_branch ||= params[:target_branch] || project.default_branch
    end

    def head_commit
      @head_commit ||= project.repository.find_branch(target_branch).dereferenced_target
    end

    def success(merge_request)
      super(merge_request: merge_request)
    end
  end
end
