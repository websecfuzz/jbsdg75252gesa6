# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Vulnerability, feature_category: :vulnerability_management do
  let(:state_values) { { detected: 1, dismissed: 2, resolved: 3, confirmed: 4 } }
  let(:severity_values) { { info: 1, unknown: 2, low: 4, medium: 5, high: 6, critical: 7 } }

  let(:report_types) do
    {
      sast: 0,
      dependency_scanning: 1,
      container_scanning: 2,
      dast: 3,
      secret_detection: 4,
      coverage_fuzzing: 5,
      api_fuzzing: 6,
      cluster_image_scanning: 7,
      container_scanning_for_registry: 8,
      generic: 99
    }
  end

  let_it_be(:project) { create(:project) }
  let_it_be(:user) { create(:user) }
  let_it_be(:vulnerability) { create(:vulnerability, :sast, :confirmed, :low, :with_state_transition, project: project) }
  let_it_be(:finding) { create(:vulnerabilities_finding, vulnerability: vulnerability) }

  it_behaves_like 'vulnerability and finding shared examples' do
    let(:transformer_method) { :itself }
  end

  describe 'enums' do
    it { is_expected.to define_enum_for(:state).with_values(state_values) }
    it { is_expected.to define_enum_for(:severity).with_values(severity_values).with_prefix(:severity) }
    it { is_expected.to define_enum_for(:report_type).with_values(report_types) }

    it_behaves_like 'having unique enum values'
  end

  describe 'associations' do
    subject { build(:vulnerability) }

    it { is_expected.to belong_to(:project) }
    it { is_expected.to have_many(:findings).class_name('Vulnerabilities::Finding').inverse_of(:vulnerability) }
    it { is_expected.to have_many(:dismissed_findings).class_name('Vulnerabilities::Finding').inverse_of(:vulnerability) }
    it { is_expected.to have_many(:merge_request_links).class_name('Vulnerabilities::MergeRequestLink').inverse_of(:vulnerability) }
    it { is_expected.to have_many(:merge_requests).through(:merge_request_links) }
    it { is_expected.to have_many(:external_issue_links).class_name('Vulnerabilities::ExternalIssueLink').inverse_of(:vulnerability) }
    it { is_expected.to have_many(:issue_links).class_name('Vulnerabilities::IssueLink').inverse_of(:vulnerability) }
    it { is_expected.to have_many(:related_issues).through(:issue_links).source(:issue) }
    it { is_expected.to have_many(:state_transitions).class_name('Vulnerabilities::StateTransition').inverse_of(:vulnerability) }
    it { is_expected.to belong_to(:author).class_name('User') }
    it { is_expected.to belong_to(:resolved_by).class_name('User') }
    it { is_expected.to belong_to(:dismissed_by).class_name('User') }
    it { is_expected.to belong_to(:confirmed_by).class_name('User') }

    it { is_expected.to have_one(:group).through(:project) }
    it { is_expected.to have_one(:vulnerability_read) }

    it { is_expected.to have_many(:findings).class_name('Vulnerabilities::Finding').dependent(false) }
    it { is_expected.to have_many(:user_mentions).class_name('VulnerabilityUserMention') }
    it { is_expected.to have_many(:state_transitions).class_name('Vulnerabilities::StateTransition') }
    it { is_expected.to have_many(:severity_overrides).class_name('Vulnerabilities::SeverityOverride') }
  end

  describe 'validations' do
    subject { build(:vulnerability) }

    it { is_expected.to validate_presence_of(:project) }
    it { is_expected.to validate_presence_of(:author) }
    it { is_expected.to validate_presence_of(:title) }
    it { is_expected.to validate_presence_of(:severity) }
    it { is_expected.to validate_presence_of(:report_type) }

    it { is_expected.to validate_length_of(:title).is_at_most(::Issuable::TITLE_LENGTH_MAX) }
    it { is_expected.to validate_length_of(:description).is_at_most(::Issuable::DESCRIPTION_LENGTH_MAX).allow_nil }
  end

  describe 'text fields' do
    let_it_be(:vulnerability) { create(:vulnerability, title: '_My title_ ', description: '**Hello `world`**') }

    describe '#title_html' do
      let(:expected_title) { '_My title_' } # no markdown rendering because it's a single line field

      subject { vulnerability.title_html }

      it { is_expected.to eq(expected_title) }
    end

    describe '#description_html' do
      let(:expected_description) { '<p dir="auto"><strong>Hello <code>world</code></strong></p>' }

      subject { vulnerability.description_html }

      it { is_expected.to eq_no_sourcepos(expected_description) }
    end

    describe 'redactable fields' do
      before do
        stub_commonmark_sourcepos_disabled
      end

      it_behaves_like 'model with redactable field' do
        let(:model) { build(:vulnerability) }
        let(:field) { :description }
      end
    end
  end

  describe '.with_limit' do
    subject(:limited_vulnerabilities) { described_class.with_limit(1) }

    before do
      # There is already a vulnerability created before
      # so this will make the total of 2 vulnerabilities.
      create(:vulnerability, project: project)
    end

    it 'returns vulnerabilities limited by provided value' do
      expect(limited_vulnerabilities.count).to eq(1)
    end
  end

  describe '.autocomplete_search' do
    using RSpec::Parameterized::TableSyntax

    let_it_be(:vulnerability_1) { create(:vulnerability, title: 'Predictable pseudorandom number generator') }
    let_it_be(:vulnerability_2) { create(:vulnerability, title: 'Use of pseudorandom MD2, MD4, or MD5 hash function.') }

    subject { described_class.autocomplete_search(search) }

    where(:search, :filtered_vulnerabilities) do
      'PSEUDORANDOM'             | [:vulnerability_1, :vulnerability_2]
      'Predictable PSEUDORANDOM' | [:vulnerability_1]
      'mD2'                      | [:vulnerability_2]
    end

    with_them do
      it 'returns the vulnerabilities filtered' do
        expect(subject).to match_array(filtered_vulnerabilities.map { |name| public_send(name) })
      end
    end

    context 'when id is used in search params' do
      let(:search) { vulnerability_1.id.to_s }

      it { is_expected.to match_array([vulnerability_1]) }
    end

    context 'when query is empty' do
      let(:search) { '' }

      it { is_expected.to match_array([vulnerability, vulnerability_1, vulnerability_2]) }
    end
  end

  describe '.with_report_types' do
    let!(:dast_vulnerability) { create(:vulnerability, :dast) }
    let!(:dependency_scanning_vulnerability) { create(:vulnerability, :dependency_scanning) }
    let(:sast_vulnerability) { vulnerability }
    let(:report_types) { %w[sast dast] }

    subject { described_class.with_report_types(report_types) }

    it 'returns vulnerabilities matching the given report_types' do
      is_expected.to contain_exactly(sast_vulnerability, dast_vulnerability)
    end
  end

  describe '.with_severities' do
    let!(:high_vulnerability) { create(:vulnerability, :high) }
    let!(:medium_vulnerability) { create(:vulnerability, :medium) }
    let(:low_vulnerability) { vulnerability }
    let(:severities) { %w[medium low] }

    subject { described_class.with_severities(severities) }

    it 'returns vulnerabilities matching the given severities' do
      is_expected.to contain_exactly(medium_vulnerability, low_vulnerability)
    end
  end

  describe '.without_severities' do
    let!(:vuln_low) { create(:vulnerability, severity: :low) }
    let!(:vuln_high) { create(:vulnerability, severity: :high) }

    it 'returns vulnerabilities excluding the given severity' do
      result = described_class.without_severities(:low)

      expect(result).to contain_exactly(vuln_high)
    end

    it 'returns all vulnerabilities if severity does not match any' do
      result = described_class.without_severities(:critical)

      expect(result).to contain_exactly(vuln_low, vuln_high, vulnerability)
    end
  end

  describe '.with_states' do
    let!(:detected_vulnerability) { create(:vulnerability, :detected) }
    let!(:dismissed_vulnerability) { create(:vulnerability, :dismissed) }
    let(:confirmed_vulnerability) { vulnerability }
    let(:states) { %w[detected confirmed] }

    subject { described_class.with_states(states) }

    it 'returns vulnerabilities matching the given states' do
      is_expected.to contain_exactly(detected_vulnerability, confirmed_vulnerability)
    end
  end

  describe '.with_projects_and_routes' do
    let_it_be(:project_with_route) { create(:project) }
    let_it_be(:vulnerability) { create(:vulnerability, project: project_with_route) }

    it 'eager-loads routes for both namespaces' do
      result = described_class.with_projects_and_routes

      expect(result).to include(vulnerability)

      expect do
        result.each do |v|
          v.project.route.path
          v.project.project_namespace.route&.path
          v.project.namespace.route.path
        end
      end.not_to exceed_query_limit(7)
    end
  end

  describe '.with_scanner_external_ids' do
    let!(:vulnerability_1) { create(:vulnerability, :with_findings) }
    let!(:vulnerability_2) { create(:vulnerability, :with_findings) }
    let(:vulnerability_3) { vulnerability }
    let(:scanner_external_ids) { [vulnerability_1.finding_scanner_external_id, vulnerability_3.finding_scanner_external_id] }

    subject { described_class.with_scanner_external_ids(scanner_external_ids) }

    it 'returns vulnerabilities matching the given scanner external IDs' do
      is_expected.to contain_exactly(vulnerability_1, vulnerability_3)
    end
  end

  describe '.order_severity_' do
    let_it_be(:low_vulnerability) { vulnerability }
    let_it_be(:critical_vulnerability) { create(:vulnerability, :critical) }
    let_it_be(:medium_vulnerability) { create(:vulnerability, :medium) }

    describe 'ascending' do
      subject { described_class.order_severity_asc }

      it { is_expected.to eq([low_vulnerability, medium_vulnerability, critical_vulnerability]) }
    end

    describe 'descending' do
      subject { described_class.order_severity_desc }

      it { is_expected.to eq([critical_vulnerability, medium_vulnerability, low_vulnerability]) }
    end
  end

  describe '.order_created_at_' do
    let_it_be(:old_vulnerability) { create(:vulnerability, created_at: 2.weeks.ago) }
    let_it_be(:very_old_vulnerability) { vulnerability }
    let_it_be(:fresh_vulnerability) { create(:vulnerability, created_at: 3.days.ago) }

    before_all do
      vulnerability.update_column(:created_at, 1.year.ago)
    end

    describe 'ascending' do
      subject { described_class.order_created_at_asc }

      it 'returns vulnerabilities ordered by created_at' do
        is_expected.to eq([very_old_vulnerability, old_vulnerability, fresh_vulnerability])
      end
    end

    describe 'descending' do
      subject { described_class.order_created_at_desc }

      it 'returns vulnerabilities ordered by created_at' do
        is_expected.to eq([fresh_vulnerability, old_vulnerability, very_old_vulnerability])
      end
    end
  end

  describe '.order_id_desc' do
    subject { described_class.order_id_desc }

    before do
      create_list(:vulnerability, 2)
    end

    it 'returns vulnerabilities ordered by id' do
      is_expected.to be_sorted(:id, :desc)
    end
  end

  describe '.with_resolution' do
    let_it_be(:vulnerability_with_resolution) { create(:vulnerability, resolved_on_default_branch: true) }
    let_it_be(:vulnerability_without_resolution) { vulnerability }

    subject { described_class.with_resolution(with_resolution) }

    before_all do
      vulnerability.update!(resolved_on_default_branch: false)
    end

    context 'when no argument is provided' do
      subject { described_class.with_resolution }

      it { is_expected.to eq([vulnerability_with_resolution]) }
    end

    context 'when the argument is provided' do
      context 'when the given argument is `true`' do
        let(:with_resolution) { true }

        it { is_expected.to eq([vulnerability_with_resolution]) }
      end

      context 'when the given argument is `false`' do
        let(:with_resolution) { false }

        it { is_expected.to eq([vulnerability_without_resolution]) }
      end
    end
  end

  describe '.with_issues' do
    let_it_be(:vulnerability_with_issues) { create(:vulnerability, :with_issue_links) }
    let_it_be(:vulnerability_without_issues) { vulnerability }

    subject { described_class.with_issues(with_issues) }

    context 'when no argument is provided' do
      subject { described_class.with_issues }

      it { is_expected.to eq([vulnerability_with_issues]) }
    end

    context 'when the argument is provided' do
      context 'when the given argument is `true`' do
        let(:with_issues) { true }

        it { is_expected.to eq([vulnerability_with_issues]) }
      end

      context 'when the given argument is `false`' do
        let(:with_issues) { false }

        it { is_expected.to eq([vulnerability_without_issues]) }
      end
    end
  end

  describe '.order_by' do
    let_it_be(:low_vulnerability) { vulnerability }
    let_it_be(:critical_vulnerability) { create(:vulnerability, :critical) }
    let_it_be(:medium_vulnerability) { create(:vulnerability, :medium) }

    subject { described_class.order_by(method) }

    context 'when ordered by severity_desc' do
      let(:method) { :severity_desc }

      it { is_expected.to eq([critical_vulnerability, medium_vulnerability, low_vulnerability]) }
    end

    context 'when ordered by severity_asc' do
      let(:method) { :severity_asc }

      it { is_expected.to eq([low_vulnerability, medium_vulnerability, critical_vulnerability]) }
    end
  end

  describe '.active_state_values' do
    let(:expected_values) { ::Vulnerability.states.values_at('detected', 'confirmed') }

    subject { described_class.active_state_values }

    it { is_expected.to match_array(expected_values) }
  end

  describe '.grouped_by_severity' do
    before do
      # There is already a vulnerability created with `low`
      # severity therefore we are not creating one with `low` severity here.
      create_list(:vulnerability, 2, :critical)
      create_list(:vulnerability, 1, :high)
      create_list(:vulnerability, 1, :medium)
      create_list(:vulnerability, 1, :info)
      create_list(:vulnerability, 1, :unknown)
    end

    subject { described_class.grouped_by_severity.count }

    it { is_expected.to eq('critical' => 2, 'high' => 1, 'info' => 1, 'low' => 1, 'medium' => 1, 'unknown' => 1) }
  end

  describe '.by_primary_identifier_ids' do
    it 'returns matching vulnerabilities' do
      create(:vulnerability)
      create(
        :vulnerabilities_finding_identifier,
        finding: vulnerability.finding,
        identifier: vulnerability.finding.primary_identifier
      )

      expect(
        described_class.by_primary_identifier_ids(vulnerability.finding.primary_identifier_id)
      ).to match_array([vulnerability])
    end
  end

  describe '.by_scanner_ids' do
    it 'returns matching vulnerabilities' do
      vulnerability1 = vulnerability
      create(:vulnerability, :with_findings)

      result = described_class.by_scanner_ids(vulnerability1.finding_scanner_id)

      expect(result).to match_array([vulnerability1])
    end
  end

  describe '.reference_prefix' do
    subject { described_class.reference_prefix }

    it { is_expected.to eq('[vulnerability:') }
  end

  describe '.reference_postfix' do
    subject { described_class.reference_postfix }

    it { is_expected.to eq(']') }
  end

  describe '.reference_pattern' do
    subject { described_class.reference_pattern }

    it { is_expected.to match('[vulnerability:123]') }
    it { is_expected.to match('[vulnerability:gitlab-foss/123]') }
    it { is_expected.to match('[vulnerability:gitlab-org/gitlab-foss/123]') }
  end

  describe '.link_reference_pattern' do
    subject { described_class.link_reference_pattern }

    it { is_expected.to match("#{Gitlab.config.gitlab.url}/gitlab-org/gitlab-foss/-/security/vulnerabilities/123") }
    it { is_expected.not_to match("#{Gitlab.config.gitlab.url}/gitlab-org/gitlab-foss/security/vulnerabilities/123") }
    it { is_expected.not_to match("#{Gitlab.config.gitlab.url}/gitlab-org/gitlab-foss/issues/123") }
    it { is_expected.not_to match("gitlab-org/gitlab-foss/milestones/123") }
  end

  describe '.with_container_image' do
    let_it_be(:vulnerability) { create(:vulnerability, project: project, report_type: 'cluster_image_scanning') }
    let_it_be(:finding) { create(:vulnerabilities_finding, :with_cluster_image_scanning_scanning_metadata, vulnerability: vulnerability) }
    let_it_be(:image) { finding.location['image'] }

    before do
      finding_with_different_image = create(
        :vulnerabilities_finding,
        :with_cluster_image_scanning_scanning_metadata,
        vulnerability: create(:vulnerability, report_type: 'cluster_image_scanning')
      )
      finding_with_different_image.location['image'] = 'alpine:latest'
      finding_with_different_image.save!
    end

    subject(:cluster_vulnerabilities) { described_class.with_container_image(image) }

    it 'returns vulnerabilities with given image' do
      expect(cluster_vulnerabilities).to contain_exactly(vulnerability)
    end
  end

  describe '.with_cluster_ids' do
    let_it_be(:vulnerability) { create(:vulnerability, project: project, report_type: 'cluster_image_scanning') }
    let_it_be(:cluster_agent) { create(:cluster_agent, project: project) }
    let_it_be(:finding) { create(:vulnerabilities_finding, :with_cluster_image_scanning_scanning_metadata, agent_id: cluster_agent.id, vulnerability: vulnerability) }
    let_it_be(:cluster_ids) { [finding.location['kubernetes_resource']['cluster_id']] }

    before do
      finding_with_different_cluster_id = create(
        :vulnerabilities_finding,
        :with_cluster_image_scanning_scanning_metadata,
        agent_id: cluster_agent.id.to_s,
        vulnerability: create(:vulnerability, report_type: 'cluster_image_scanning')
      )
      finding_with_different_cluster_id.location['kubernetes_resource']['cluster_id'] = '2'
      finding_with_different_cluster_id.save!

      finding_without_cluster_id = create(
        :vulnerabilities_finding,
        :with_cluster_image_scanning_scanning_metadata,
        agent_id: cluster_agent.id.to_s,
        vulnerability: create(:vulnerability, report_type: 'cluster_image_scanning')
      )
      finding_without_cluster_id.location['kubernetes_resource']['cluster_id'] = nil
      finding_without_cluster_id.save!
    end

    subject(:cluster_vulnerabilities) { described_class.with_cluster_ids(cluster_ids) }

    it 'returns vulnerabilities with given cluster_id' do
      expect(cluster_vulnerabilities).to contain_exactly(vulnerability)
    end
  end

  describe '.with_cluster_agent_ids' do
    let_it_be(:vulnerability) { create(:vulnerability, project: project, report_type: 'cluster_image_scanning') }
    let_it_be(:cluster_agent) { create(:cluster_agent, project: project) }
    let_it_be(:other_cluster_agent) { create(:cluster_agent, project: project) }
    let_it_be(:finding) { create(:vulnerabilities_finding, :with_cluster_image_scanning_scanning_metadata, agent_id: cluster_agent.id.to_s, vulnerability: vulnerability) }
    let_it_be(:finding_with_different_agent_id) { create(:vulnerabilities_finding, :with_cluster_image_scanning_scanning_metadata, agent_id: other_cluster_agent.id.to_s, vulnerability: vulnerability) }
    let_it_be(:finding_without_agent_id) { create(:vulnerabilities_finding, :with_cluster_image_scanning_scanning_metadata, agent_id: nil, vulnerability: vulnerability) }
    let_it_be(:cluster_agent_ids) { [finding.location['kubernetes_resource']['agent_id']] }

    subject(:cluster_agent_vulnerabilities) { described_class.with_cluster_agent_ids(cluster_agent_ids) }

    it 'returns vulnerabilities with given agent_id' do
      expect(cluster_agent_vulnerabilities).to contain_exactly(vulnerability)
    end
  end

  describe '.with_false_positive' do
    let_it_be(:vulnerability) { create(:vulnerability) }
    let_it_be(:non_false_positive_vulnerability) { create(:vulnerability) }
    let_it_be(:finding) { create(:vulnerabilities_finding, vulnerability_flags: [create(:vulnerabilities_flag)], vulnerability: vulnerability) }
    let_it_be(:non_false_positive_finding) { create(:vulnerabilities_finding, vulnerability: non_false_positive_vulnerability) }

    context 'when false_positive is true' do
      it 'returns vulnerabilities that have findings with false positive set to true' do
        expect(described_class.with_false_positive(true)).to contain_exactly(vulnerability)
      end
    end

    context 'when false_positive is false' do
      it 'returns vulnerabilities that have findings with false positive set to false' do
        expect(described_class.with_false_positive(false)).to include(non_false_positive_vulnerability)
      end
    end
  end

  describe '.with_fix_available' do
    let_it_be(:vulnerability) { create(:vulnerability) }
    let_it_be(:vuln_without_fix) { create(:vulnerability) }
    let_it_be(:finding) { create(:vulnerabilities_finding, vulnerability: vulnerability, solution: 'test fix') }
    let_it_be(:finding_without_fix) { create(:vulnerabilities_finding, solution: nil, vulnerability: vuln_without_fix) }

    context 'when fix_available is true' do
      it 'returns vulnerabilities that have findings with with fix' do
        expect(described_class.with_fix_available(true)).to contain_exactly(vulnerability)
      end
    end

    context 'when fix_available is false' do
      it 'returns vulnerabilities that have findings without fix' do
        expect(described_class.with_fix_available(false)).to include(vuln_without_fix)
      end
    end
  end

  describe '.last_updated_before' do
    let!(:vulnerability) { create(:vulnerability, updated_at: 1.month.ago) }

    subject(:vulnerabilities) { described_class.last_updated_before(1.week.ago) }

    before do
      create(:vulnerability)
    end

    it 'returns only the records updated before the given date' do
      expect(vulnerabilities).to contain_exactly(vulnerability)
    end
  end

  describe 'created_in_time_range' do
    it 'returns vulnerabilities created in given time range', :aggregate_failures do
      record1 = create(:vulnerability, created_at: 1.day.ago)
      record2 = create(:vulnerability, created_at: 1.month.ago)
      record3 = create(:vulnerability, created_at: 1.year.ago)

      expect(described_class.created_in_time_range(from: 1.week.ago)).to match_array([record1, vulnerability])
      expect(described_class.created_in_time_range(to: 1.week.ago)).to match_array([record2, record3])
      expect(described_class.created_in_time_range(from: 2.months.ago, to: 1.week.ago)).to match_array([record2])
    end
  end

  describe '#cvss_vectors_with_vendor' do
    subject { vulnerability.cvss_vectors_with_vendor }

    before do
      vulnerability.cvss = [{ vector: 'CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N', vendor: 'GitLab' }]
    end

    it { is_expected.to match_array(['GitLab=CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N']) }
  end

  describe '#full_path' do
    let(:project) { build(:project) }
    let(:vulnerability) { build(:vulnerability, id: 1, project: project) }

    subject { vulnerability.full_path }

    it { is_expected.to eq("#{project.full_path}/1") }
  end

  describe '#to_reference' do
    let(:namespace) { build(:namespace) }
    let(:project) { build(:project, namespace: namespace) }
    let(:vulnerability) { build(:vulnerability, id: 1, project: project) }

    context 'when nil argument' do
      it 'returns vulnerability id' do
        expect(vulnerability.to_reference).to eq '[vulnerability:1]'
      end

      it 'returns complete path to the vulnerability with full: true' do
        expect(vulnerability.to_reference(full: true)).to eq "[vulnerability:#{project.full_path}/1]"
      end
    end

    context 'when argument is a project' do
      context 'when same project' do
        it 'returns vulnerability id' do
          expect(vulnerability.to_reference(project)).to eq('[vulnerability:1]')
        end

        it 'returns full reference with full: true' do
          expect(vulnerability.to_reference(project, full: true)).to eq "[vulnerability:#{project.full_path}/1]"
        end
      end

      context 'when cross-project in same namespace' do
        let(:another_project) do
          build(:project, namespace: project.namespace)
        end

        it 'returns a cross-project reference' do
          expect(vulnerability.to_reference(another_project)).to eq "[vulnerability:#{project.path}/1]"
        end

        it 'returns full reference with full: true' do
          expect(vulnerability.to_reference(another_project, full: true)).to eq "[vulnerability:#{project.full_path}/1]"
        end
      end

      context 'when cross-project in different namespace' do
        let(:another_namespace) { build(:namespace, id: non_existing_record_id, path: 'another-namespace') }
        let(:another_namespace_project) { build(:project, namespace: another_namespace) }

        it 'returns complete path to the vulnerability' do
          expect(vulnerability.to_reference(another_namespace_project)).to eq "[vulnerability:#{project.full_path}/1]"
        end

        it 'returns full reference with full: true' do
          expect(vulnerability.to_reference(another_namespace_project, full: true)).to eq "[vulnerability:#{project.full_path}/1]"
        end
      end
    end

    context 'when argument is a namespace' do
      context 'when same as vulnerability' do
        it 'returns path to the vulnerability with the project path' do
          expect(vulnerability.to_reference(namespace)).to eq "[vulnerability:#{project.path}/1]"
        end

        it 'returns full reference with full: true' do
          expect(vulnerability.to_reference(namespace, full: true)).to eq "[vulnerability:#{project.full_path}/1]"
        end
      end

      context 'when different from vulnerability namespace' do
        let(:group) { build(:group, name: 'Group', path: 'sample-group') }

        it 'returns full path to the vulnerability with full: true' do
          expect(vulnerability.to_reference(group)).to eq "[vulnerability:#{project.full_path}/1]"
        end

        it 'returns full path to the vulnerability with full: false' do
          expect(vulnerability.to_reference(group, full: false)).to eq "[vulnerability:#{project.full_path}/1]"
        end
      end
    end
  end

  describe '#has_remediations?' do
    subject { vulnerability.has_remediations? }

    context 'when remediations exist' do
      let(:vulnerability) { create(:vulnerability, :with_remediation) }

      it { is_expected.to be(true) }
    end

    context 'when remediations do not exist' do
      let(:vulnerability) { create(:vulnerability) }

      it { is_expected.to be(false) }
    end
  end

  describe '#sbom_occurrences_with_dependency_paths_data' do
    subject { vulnerability.sbom_occurrences_with_dependency_paths_data(limit: 1) }

    let_it_be(:vulnerability) { create(:vulnerability, report_type: :dependency_scanning) }
    let_it_be(:occurrence) { create(:sbom_occurrence) }
    let_it_be(:sbom_occurrences_vulnerability) { create(:sbom_occurrences_vulnerability, vulnerability: vulnerability, occurrence: occurrence) }

    context 'with occurrences below limit' do
      it { is_expected.to eq([occurrence]) }
    end

    context 'with occurrences above limit' do
      let_it_be(:occurrence2) { create(:sbom_occurrence) }
      let_it_be(:sbom_occurrences_vulnerability2) { create(:sbom_occurrences_vulnerability, vulnerability: vulnerability, occurrence: occurrence2) }

      it { is_expected.to eq([occurrence]) }
    end
  end

  describe '#finding' do
    let_it_be(:finding_1) { finding }
    let_it_be(:finding_2) { create(:vulnerabilities_finding, vulnerability: vulnerability) }

    subject { vulnerability.finding }

    context 'with multiple findings' do
      it { is_expected.to eq(finding_1) }
    end
  end

  describe 'delegations' do
    it { is_expected.to delegate_method(:scanner_name).to(:finding).with_prefix.allow_nil }
    it { is_expected.to delegate_method(:description).to(:finding).with_prefix.allow_nil }
    it { is_expected.to delegate_method(:description_html).to(:finding).with_prefix.allow_nil }
    it { is_expected.to delegate_method(:metadata).to(:finding).with_prefix.allow_nil }
    it { is_expected.to delegate_method(:cve_value).to(:finding).allow_nil }
    it { is_expected.to delegate_method(:cwe_value).to(:finding).allow_nil }
    it { is_expected.to delegate_method(:other_identifier_values).to(:finding).allow_nil }
    it { is_expected.to delegate_method(:default_branch).to(:project).with_prefix.allow_nil }
    it { is_expected.to delegate_method(:name).to(:project).with_prefix.allow_nil }
    it { is_expected.to delegate_method(:name).to(:group).with_prefix.allow_nil }
    it { is_expected.to delegate_method(:location).to(:finding).allow_nil }
  end

  describe '#resource_parent' do
    subject(:resource_parent) { vulnerability.resource_parent }

    it { is_expected.to eq(project) }
  end

  describe '#discussions_rendered_on_frontend?' do
    subject(:discussions_rendered_on_frontend) { vulnerability.discussions_rendered_on_frontend? }

    it { is_expected.to be true }
  end

  describe '.parent_class' do
    subject(:parent_class) { ::Vulnerability.parent_class }

    it { is_expected.to eq(::Project) }
  end

  describe '.to_ability_name' do
    subject(:ability_name) { ::Vulnerability.to_ability_name }

    it { is_expected.to eq('vulnerability') }
  end

  describe 'Elastic::ApplicationVersionedSearch' do
    let(:vulnerability) { create(:vulnerability) }

    before do
      stub_ee_application_setting(elasticsearch_indexing: true)
    end

    shared_examples 'does not use elasticsearch' do
      describe '#maintaining_elasticsearch?' do
        it 'returns false' do
          expect(vulnerability.maintaining_elasticsearch?).to be(false)
        end
      end
    end

    shared_examples 'uses elasticsearch' do
      before do
        allow(Elastic::ProcessBookkeepingService).to receive(:track!)
      end

      describe '#maintaining_elasticsearch?' do
        it 'returns true' do
          expect(vulnerability.maintaining_elasticsearch?).to be(true)
        end
      end

      context 'on create' do
        it 'tracks vulnerability creation in elasticsearch' do
          expect(Elastic::ProcessBookkeepingService)
            .to have_received(:track!)
            .with(vulnerability)
            .once

          vulnerability
        end
      end

      context 'on delete' do
        it 'tracks vulnerability deletion in elasticsearch' do
          expect(Elastic::ProcessBookkeepingService).to receive(:track!).with(vulnerability).once

          vulnerability.destroy!
        end
      end

      context 'on update' do
        it 'tracks all field updates due to updated_at' do
          expect(Elastic::ProcessBookkeepingService).to receive(:track!).with(vulnerability).once

          vulnerability.update!(severity: :critical)
        end

        it 'tracks non-elastic field updates too' do
          expect(Elastic::ProcessBookkeepingService).to receive(:track!).with(vulnerability).once

          vulnerability.update!(title: "Updated Vulnerability Title")
        end
      end
    end

    it 'includes Elastic::ApplicationVersionedSearch' do
      expect(described_class).to include_module(::Elastic::ApplicationVersionedSearch)
    end

    context 'when vulnerability indexing is allowed' do
      before do
        allow(::Search::Elastic::VulnerabilityIndexingHelper).to receive(:vulnerability_indexing_allowed?).and_return(true)
      end

      it_behaves_like 'uses elasticsearch'
    end

    context 'when vulnerability indexing is disallowed' do
      before do
        allow(::Search::Elastic::VulnerabilityIndexingHelper).to receive(:vulnerability_indexing_allowed?).and_return(false)
      end

      it_behaves_like 'does not use elasticsearch'
    end

    context 'when elasticsearch indexing is disabled' do
      before do
        stub_ee_application_setting(elasticsearch_indexing: false)
      end

      it_behaves_like 'does not use elasticsearch'
    end
  end

  describe '#elastic_reference' do
    let_it_be(:vulnerability) { create(:vulnerability) }

    it 'returns the serialized result using vulnerability' do
      serialized_result = instance_double(String)
      generated_es_parent = "mock_es_parent"
      reference_instance = instance_double(::Search::Elastic::References::Vulnerability)

      expect(Vulnerabilities::Read).to receive(:generate_es_parent)
        .with(vulnerability.project)
        .and_return(generated_es_parent)

      expect(::Search::Elastic::References::Vulnerability).to receive(:new)
        .with(vulnerability.id, generated_es_parent)
        .and_return(reference_instance)

      expect(reference_instance).to receive(:serialize)
        .and_return(serialized_result)

      expect(vulnerability.elastic_reference).to eq(serialized_result)
    end
  end

  describe '#user_notes_count' do
    let(:expected_count) { 10 }
    let(:mock_service_class) { instance_double(Vulnerabilities::UserNotesCountService, count: expected_count) }

    subject(:user_notes_count) { vulnerability.user_notes_count }

    before do
      allow(Vulnerabilities::UserNotesCountService).to receive(:new).with(vulnerability).and_return(mock_service_class)
    end

    it 'delegates the call to Vulnerabilities::UserNotesCountService' do
      expect(user_notes_count).to eq(expected_count)
      expect(mock_service_class).to have_received(:count)
    end
  end

  describe '#after_note_changed' do
    let(:vulnerability) { build(:vulnerability) }
    let(:note) { instance_double(Note, system?: is_system_note?) }
    let(:mock_service_class) { instance_double(Vulnerabilities::UserNotesCountService, delete_cache: true) }

    subject(:after_note_changed) { vulnerability.after_note_changed(note) }

    before do
      allow(Vulnerabilities::UserNotesCountService).to receive(:new).with(vulnerability).and_return(mock_service_class)
    end

    context 'when the changed note is a system note' do
      let(:is_system_note?) { true }

      it 'does not send #delete_cache message to Vulnerabilities::UserNotesCountService' do
        after_note_changed

        expect(mock_service_class).not_to have_received(:delete_cache)
      end
    end

    context 'when the changed note is not a system note' do
      let(:is_system_note?) { false }

      it 'sends #delete_cache message to Vulnerabilities::UserNotesCountService' do
        after_note_changed

        expect(mock_service_class).to have_received(:delete_cache)
      end
    end
  end

  describe '#after_note_created' do
    subject { described_class.instance_method(:after_note_created).original_name }

    it { is_expected.to eq(:after_note_changed) }
  end

  describe '#after_note_destroyed' do
    subject { described_class.instance_method(:after_note_destroyed).original_name }

    it { is_expected.to eq(:after_note_changed) }
  end

  describe '#stat_diff' do
    subject { vulnerability.stat_diff }

    it { is_expected.to be_an_instance_of(Vulnerabilities::StatDiff) }
  end

  describe '#blob_path' do
    let(:finding) { create(:vulnerabilities_finding, :detected, :with_pipeline) }
    let(:vulnerability) { finding.vulnerability }

    subject { vulnerability.blob_path }

    it 'returns project blob path' do
      expect(subject).to eq(
        "/#{vulnerability.project.full_path}/-/blob/#{finding.last_finding_pipeline.sha}/#{vulnerability.finding.file}"
      )
    end

    context 'with a Secret Detection finding' do
      let(:finding) { create(:vulnerabilities_finding, :with_secret_detection, :with_pipeline) }

      it 'uses the commit SHA in the blob path' do
        secret_detection_finding_sha = finding.location.dig("commit", "sha")

        expect(subject).to eq(
          "/#{vulnerability.project.full_path}/-/blob/#{secret_detection_finding_sha}/#{vulnerability.finding.file}"
        )
      end
    end

    context 'with a Secret Detection finding made in "no git" mode' do
      # In a "no git" scan, the Secret Detection analyser populates a dummy value in the
      # finding's commit.sha property. We make sure the dummy value is not used to render
      # the blob link.
      let(:finding) { create(:vulnerabilities_finding, :with_secret_detection_in_no_git_mode, :with_pipeline) }

      it 'uses the latest SHA of the current branch in blob path' do
        expect(subject).to eq(
          "/#{vulnerability.project.full_path}/-/blob/#{finding.last_finding_pipeline.sha}/#{vulnerability.finding.file}"
        )
      end
    end
  end

  describe '.with_findings_by_uuid' do
    let_it_be(:vulnerability) { create(:vulnerability) }

    let(:uuid) { [SecureRandom.uuid] }

    subject { described_class.with_findings_by_uuid(uuid) }

    it { is_expected.to be_empty }

    context 'with findings' do
      let_it_be(:finding) { create(:vulnerabilities_finding, vulnerability: vulnerability) }

      it { is_expected.to be_empty }

      context 'with matching uuid' do
        let(:uuid) { [finding.uuid] }

        it { is_expected.to contain_exactly(vulnerability) }
      end
    end
  end

  describe '.with_dismissal_reason scope' do
    let_it_be(:dismissed_vulnerability) { create(:vulnerability, :dismissed, report_type: :dependency_scanning, severity: :low, project: project) }
    let_it_be(:dismissed_vulnerability_read) do
      create(
        :vulnerability_read,
        :used_in_tests,
        report_type: dismissed_vulnerability.report_type,
        state: dismissed_vulnerability.state,
        severity: dismissed_vulnerability.severity,
        vulnerability: dismissed_vulnerability,
        project: project
      )
    end

    subject(:scope) { described_class.with_dismissal_reason(['used_in_tests']) }

    it 'returns only dismissed Vulnerabilities' do
      expect(scope).to contain_exactly(dismissed_vulnerability)
    end
  end

  describe '.with_findings_by_uuid_and_state scope' do
    let_it_be(:vulnerability) { create(:vulnerability, state: :detected) }

    let(:uuid) { ["592d0922-232a-470b-84e9-5ce1c7aa9477"] }

    subject { described_class.with_findings_by_uuid_and_state(uuid, ["detected"]) }

    it { is_expected.to be_empty }

    context 'with findings' do
      let_it_be(:finding) { create(:vulnerabilities_finding, vulnerability: vulnerability) }

      it { is_expected.to be_empty }

      context 'with matching uuid' do
        let(:uuid) { [finding.uuid] }

        it { is_expected.to contain_exactly(vulnerability) }
      end
    end
  end

  describe '.with_findings_excluding_uuid scope' do
    let_it_be(:vulnerability) { create(:vulnerability, :with_finding) }

    let(:uuid) { vulnerability.finding.uuid }

    subject { described_class.with_findings_excluding_uuid(uuid) }

    it { is_expected.not_to include(vulnerability) }

    context 'with mismatching uuid' do
      let(:uuid) { [SecureRandom.uuid] }

      it { is_expected.to include(vulnerability) }
    end
  end

  describe '.for_default_branch scope' do
    let_it_be(:vulnerability) { create(:vulnerability, present_on_default_branch: false) }

    subject { described_class.for_default_branch }

    it { is_expected.not_to include(vulnerability) }

    context 'with present_on_default_branch false' do
      subject { described_class.for_default_branch(false) }

      it { is_expected.to include(vulnerability) }
    end
  end

  describe '.by_ids scope' do
    let_it_be(:vulnerability_1) { create(:vulnerability) }
    let_it_be(:vulnerability_2) { create(:vulnerability) }
    let_it_be(:vulnerability_3) { create(:vulnerability) }

    let_it_be(:ids) { [vulnerability_1.id, vulnerability_2.id] }

    context 'with matching ids' do
      subject { described_class.by_ids(ids) }

      it { is_expected.to contain_exactly(vulnerability_1, vulnerability_2) }
    end
  end

  describe '.by_age scope' do
    let_it_be(:days) { 30 }
    let_it_be(:old_vulnerability) { create(:vulnerability, created_at: 6.months.ago) }
    let_it_be(:new_vulnerability) { create(:vulnerability, created_at: 3.days.ago) }

    subject(:vulnerabilities) { described_class.by_age(operator, days) }

    context 'when operator is greater_than' do
      let_it_be(:operator) { :greater_than }

      it 'returns vulnerabilities detected before the selected amount of days ago' do
        expect(vulnerabilities).to contain_exactly(old_vulnerability)
      end
    end

    context 'when operator is less_than' do
      let_it_be(:operator) { :less_than }

      it 'returns vulnerabilities detected after the selected amount of days ago' do
        expect(vulnerabilities).to contain_exactly(vulnerability, new_vulnerability)
      end
    end
  end

  describe '.with_keyset_order' do
    let(:unknown_sort_direction) { :abc }

    it 'raises an error when an unknown sort direction given' do
      expect do
        described_class.with_keyset_order(described_class.state_order, 'state_order', unknown_sort_direction)
      end.to raise_error("unknown sort direction given: abc")
    end

    it 'raises an error when an unknown sort direction given for tie breaking column' do
      expect do
        described_class.with_keyset_order(described_class.state_order, 'state_order', :asc, unknown_sort_direction)
      end.to raise_error("unknown tie breaker sort direction given: abc")
    end
  end

  describe '.present_on_default_branch' do
    let_it_be(:not_present) { create(:vulnerability, present_on_default_branch: false) }

    subject { described_class.present_on_default_branch }

    it 'does not return vulnerabilities which are not present on the default branch' do
      expect(subject).not_to include(not_present)
    end
  end

  describe '#notes_summary' do
    let(:vulnerability) { create(:vulnerability, project: project) }
    let!(:most_recent_user) { create(:user) }
    let!(:note) { create(:note, project: project, noteable: vulnerability, noteable_type: 'Vulnerability', note: 'changed vulnerabilities from detected to confirmed', author: most_recent_user) }

    subject(:notes_summary) { vulnerability.notes_summary }

    it 'returns summarized version of notes' do
      expect(notes_summary).to eq("#{note.last_edited_at}|#{most_recent_user.username}|confirmed|changed vulnerabilities from detected to confirmed\n")
    end

    context 'with multiple notes' do
      let!(:additional_note) { create(:note, project: project, noteable: vulnerability, noteable_type: 'Vulnerability', note: 'additional comment by the user', author: user, discussion_id: note.discussion_id) }

      before do
        # This will re-order the tuples on disk based on an index ordered by `author_id`.
        Note.connection.execute('CLUSTER notes USING index_notes_on_author_id_and_created_at_and_id')
      end

      it 'returns summarized version of notes' do
        expect(notes_summary).to eq("#{note.last_edited_at}|#{most_recent_user.username}|confirmed|changed vulnerabilities from detected to confirmed\n; #{additional_note.last_edited_at}|#{user.username}|confirmed|additional comment by the user\n")
      end
    end
  end

  describe '#latest_state_transition' do
    context 'without any state transition' do
      let_it_be(:vulnerability) { create(:vulnerability, project: project) }

      it 'retuns nil' do
        expect(vulnerability.latest_state_transition).to be_nil
      end
    end

    context 'with state transition' do
      it 'return the latest state transition' do
        expect(vulnerability.latest_state_transition).to eq Vulnerabilities::StateTransition.where(vulnerability_id: vulnerability.id).last
      end
    end
  end

  describe '#latest_state_transition_if_dismissed' do
    context 'without any state transition' do
      let_it_be(:vulnerability) { create(:vulnerability, project: project) }

      it 'retuns nil' do
        expect(vulnerability.latest_state_transition_if_dismissed).to be_nil
      end
    end

    context 'with dismissal state transition' do
      let(:vulnerability_state_transition_confirmation) do
        build(:vulnerability_state_transition,
          vulnerability: vulnerability,
          to_state: :confirmed
        )
      end

      let(:vulnerability_state_transition_dismissal) do
        build(:vulnerability_state_transition,
          vulnerability: vulnerability,
          to_state: :dismissed
        )
      end

      before do
        vulnerability_state_transition_confirmation.save!
        vulnerability_state_transition_dismissal.save!
      end

      context 'when dismissed' do
        let_it_be(:vulnerability) { create(:vulnerability, :dismissed, project: project) }

        it 'return the latest dismissed state transition' do
          expect(vulnerability.latest_state_transition_if_dismissed).to eq vulnerability_state_transition_dismissal
        end
      end

      context 'when not dismissed' do
        it 'retuns nil' do
          expect(vulnerability.latest_state_transition_if_dismissed).to be_nil
        end
      end
    end
  end

  describe 'reading `traversal_ids` attribute' do
    let(:expected_traversal_ids) { [1, 2, 3] }

    let(:traversal_ids) { vulnerability.read_attribute(:traversal_ids) }

    before do
      vulnerability.vulnerability_read.update_column(:traversal_ids, expected_traversal_ids)
    end

    it 'returns the `traversal_ids` of associated `vulnerability_read` record' do
      expect(traversal_ids).to eq(expected_traversal_ids)
    end
  end

  context 'with loose foreign keys' do
    let_it_be(:user1) { create(:user) }
    let_it_be(:user2) { create(:user) }
    let_it_be(:user3) { create(:user) }
    let_it_be(:project) { create(:project) }

    context 'with loose foreign key on vulnerabilities.project_id' do
      it_behaves_like 'cleanup by a loose foreign key' do
        let_it_be(:parent) { project }
        let_it_be(:model) { create(:vulnerability, project_id: project.id) }
      end
    end

    context 'with loose foreign key on vulnerabilities.dismissed_by_id' do
      it_behaves_like 'cleanup by a loose foreign key' do
        let(:lfk_column) { :dismissed_by_id }
        let_it_be(:parent) { user1 }
        let_it_be(:model) { create(:vulnerability, project: project, dismissed_by: user1) }
      end
    end

    context 'with loose foreign key on vulnerabilities.resolved_by_id' do
      it_behaves_like 'cleanup by a loose foreign key' do
        let(:lfk_column) { :resolved_by_id }
        let_it_be(:parent) { user2 }
        let_it_be(:model) { create(:vulnerability, project: project, resolved_by: user2) }
      end
    end

    context 'with loose foreign key on vulnerabilities.confirmed_by_id' do
      it_behaves_like 'cleanup by a loose foreign key' do
        let(:lfk_column) { :confirmed_by_id }
        let_it_be(:parent) { user3 }
        let_it_be(:model) { create(:vulnerability, project: project, confirmed_by: user3) }
      end
    end
  end

  describe '#trigger_webhook_event' do
    let_it_be(:vulnerability) { create(:vulnerability, project: project) }

    context 'and there are no active vulnerability hooks' do
      it 'returns nil' do
        expect(vulnerability.trigger_webhook_event).to be_nil
      end
    end

    context 'and there are active vulnerability hooks' do
      it 'executes the hooks' do
        freeze_time do
          allow(vulnerability.project).to receive(:has_active_hooks?).with(:vulnerability_hooks).and_return(true)
          hook_data = {
            object_kind: "vulnerability",
            object_attributes: {
              url: ::Gitlab::Routing.url_helpers.project_security_vulnerability_url(
                vulnerability.project, vulnerability),
              title: vulnerability.title,
              state: "detected",
              project_id: vulnerability.project.id,
              location: nil,
              cvss: [{ "vendor" => "GitLab", "vector" => "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N" }],
              severity: "high",
              severity_overridden: false,
              identifiers: [],
              issues: [],
              report_type: "sast",
              confirmed_at: nil,
              confirmed_by_id: nil,
              dismissed_at: nil,
              dismissed_by_id: nil,
              resolved_on_default_branch: false,
              created_at: vulnerability.created_at,
              updated_at: vulnerability.updated_at
            }
          }

          expect(vulnerability.project).to receive(:execute_hooks).with(hook_data, :vulnerability_hooks)

          vulnerability.trigger_webhook_event
        end
      end
    end
  end

  describe '#about_to_be_archived?', :freeze_time do
    let_it_be_with_refind(:project) { create(:project, :in_group) }

    using RSpec::Parameterized::TableSyntax

    where(:archival_enabled?, :updated_at, :expected_value) do
      true  | (11.months - 1.day).ago | false
      true  | 11.months.ago           | true
      true  | (11.months + 1.day).ago | true
      false | (11.months - 1.day).ago | false
      false | 11.months.ago           | false
      false | (11.months + 1.day).ago | false
    end

    with_them do
      let(:vulnerability) { create(:vulnerability, project: project, updated_at: updated_at) }

      subject { vulnerability.about_to_be_archived? }

      before do
        stub_feature_flags(vulnerability_archival: archival_enabled?)
      end

      it { is_expected.to be(expected_value) }
    end
  end

  describe '#expected_to_be_archived_on' do
    let_it_be_with_refind(:project) { create(:project, :in_group) }

    using RSpec::Parameterized::TableSyntax

    where(:archival_enabled?, :updated_at, :expected_value) do
      false | '2023-12-01' | nil
      true  | '2022-12-01' | '2025-01-01'
      true  | '2023-12-01' | '2025-01-01'
      true  | '2023-12-02' | '2025-01-01'
      true  | '2024-01-01' | '2025-02-01'
      true  | '2024-02-28' | '2025-03-01'
    end

    with_them do
      let(:vulnerability) { create(:vulnerability, project: project, updated_at: updated_at) }

      subject { vulnerability.expected_to_be_archived_on }

      around do |example|
        travel_to('2024-12-01') { example.run }
      end

      before do
        stub_feature_flags(vulnerability_archival: archival_enabled?)
      end

      it { is_expected.to eq(expected_value) }
    end
  end

  describe '#archive?', :freeze_time do
    using RSpec::Parameterized::TableSyntax

    where(:on_default_branch?, :updated_at, :related_mr_updated_at, :related_issue_updated_at, :expected_value) do
      false | 7.days.ago | 7.days.ago | 7.days.ago | false
      true  | 7.days.ago | nil        | nil        | true
      true  | 7.days.ago | 7.days.ago | nil        | true
      true  | 7.days.ago | 1.day.ago  | nil        | false
      true  | 7.days.ago | nil        | 7.days.ago | true
      true  | 7.days.ago | nil        | 1.day.ago  | false
      true  | 1.day.ago  | nil        | nil        | false
      true  | 1.day.ago  | 7.days.ago | nil        | false
      true  | 1.day.ago  | 1.day.ago  | nil        | false
      true  | 1.day.ago  | nil        | 7.days.ago | false
      true  | 1.day.ago  | nil        | 1.day.ago  | false
    end

    with_them do
      let(:vulnerability) { create(:vulnerability, present_on_default_branch: on_default_branch?, updated_at: updated_at) }

      subject { vulnerability.archive?(2.days.ago) }

      before do
        if related_mr_updated_at
          mr_link = create(:vulnerabilities_merge_request_link, vulnerability: vulnerability)
          mr_link.merge_request.update!(updated_at: related_mr_updated_at)
        end

        if related_issue_updated_at
          issue_link = create(:vulnerabilities_issue_link, vulnerability: vulnerability)
          issue_link.issue.update!(updated_at: related_issue_updated_at)
        end
      end

      it { is_expected.to eq(expected_value) }
    end
  end

  describe '#reachability' do
    let_it_be(:vulnerability) { create(:vulnerability) }

    subject(:reachability) { vulnerability.reachability }

    it { is_expected.to be_nil }

    context 'with report type set to dependency_scanning' do
      let_it_be(:vulnerability) { create(:vulnerability, report_type: :dependency_scanning) }

      it { is_expected.to eq :unknown }

      %i[unknown in_use not_found].each do |reachability|
        context "with related sbom_occurrences record set to `#{reachability}`" do
          let_it_be(:occurrence) { create(:sbom_occurrence, reachability: reachability) }
          let_it_be(:sbom_occurrences_vulnerability) { create(:sbom_occurrences_vulnerability, vulnerability: vulnerability, occurrence: occurrence) }

          it { is_expected.to eq reachability }
        end
      end
    end
  end

  describe '#ai_resolution_enabled?' do
    subject(:ai_resolution_enabled) { vulnerability.ai_resolution_enabled? }

    context 'when vulnerability_read is present' do
      let(:has_vulnerability_resolution) { true }

      before do
        vulnerability.vulnerability_read.update!(has_vulnerability_resolution: has_vulnerability_resolution)
      end

      it { is_expected.to be_truthy }

      context 'when has_vulnerability_resolution is false' do
        let(:has_vulnerability_resolution) { false }

        it { is_expected.to be_falsey }
      end
    end

    context 'when vulnerability_read is not present' do
      before do
        vulnerability.vulnerability_read.destroy!
        vulnerability.reload
      end

      it { is_expected.to be_nil }
    end
  end
end
