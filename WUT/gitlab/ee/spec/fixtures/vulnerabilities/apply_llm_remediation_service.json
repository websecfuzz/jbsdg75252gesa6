[
  {
    "name": "CWE-328",
    "description": "A single line patch",
    "old_code": "\n    def cache_key\n      @cache_key ||= Digest::SHA1::hexdigest begin\n        if subject.respond_to? :cache_key\n          \"#{I18n.locale}/#{self.class.name.demodulize}/#{subject.cache_key}/#{@options.sort_by(&:to_s)}\"\n        else\n          subject.inspect\n        end\n      end\n    end\n",
    "new_code": "\n    def cache_key\n      @cache_key ||= Digest::SHA256.hexdigest begin\n        if subject.respond_to? :cache_key\n          \"#{I18n.locale}/#{self.class.name.demodulize}/#{subject.cache_key}/#{@options.sort_by(&:to_s)}\"\n        else\n          subject.inspect\n        end\n      end\n    end\n",
    "source_content": "#-- copyright\n# OpenProject is an open source project management software.\n# Copyright (C) 2012-2021 the OpenProject GmbH\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License version 3.\n#\n# OpenProject is a fork of ChiliProject, which is a fork of Redmine. The copyright follows:\n# Copyright (C) 2006-2013 Jean-Philippe Lang\n# Copyright (C) 2010-2013 the ChiliProject Team\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n#\n# See COPYRIGHT and LICENSE files for more details.\n#++\n\nrequire 'digest/sha1'\n\nmodule ::Widget\n  class Base < Widget::ReportingWidget\n    attr_reader :engine, :output\n    attr_accessor :request\n\n    ##\n    # Deactivate caching for certain widgets. If called on Widget::Base,\n    # caching is deactivated globally\n    def self.dont_cache!\n      @dont_cache = true\n    end\n\n    ##\n    # Query whether this widget class should be cached.\n    def self.dont_cache?\n      @dont_cache or self != Widget::Base && Widget::Base.dont_cache?\n    end\n\n    def initialize(query)\n      @subject = query\n      @engine = query.class\n      @options = {}\n    end\n\n    ##\n    # Write a string to the canvas. The string is marked as html_safe.\n    # This will write twice, if @cache_output is set.\n    def write(str)\n      str ||= ''\n      @output ||= ''.html_safe\n      @output = @output + '' if @output.frozen? # Rails 2 freezes tag strings\n      @output.concat str.html_safe\n      @cache_output.concat(str.html_safe) if @cache_output\n      str.html_safe\n    end\n\n    ##\n    # Render this widget. Abstract method. Needs to call #write at least once\n    def render\n      raise NotImplementedError, \"#render is missing in my subclass #{self.class}\"\n    end\n\n    ##\n    # Render this widget, passing options.\n    # Available options:\n    #   :to => canvas - The canvas (streaming or otherwise) to render to. Has to respond to #write\n    def render_with_options(options = {}, &block)\n      set_canvas(options.delete(:to)) if options.has_key? :to\n      @options = options\n      render_with_cache(options, &block)\n      @output\n    end\n\n    def cache_key\n      @cache_key ||= Digest::SHA1::hexdigest begin\n        if subject.respond_to? :cache_key\n          \"#{I18n.locale}/#{self.class.name.demodulize}/#{subject.cache_key}/#{@options.sort_by(&:to_s)}\"\n        else\n          subject.inspect\n        end\n      end\n    end\n\n    def cached?\n      cache? && Rails.cache.exist?(cache_key)\n    end\n\n    private\n\n    def cache?\n      !self.class.dont_cache?\n    end\n\n    ##\n    # Render this widget or serve it from cache\n    def render_with_cache(_options = {}, &block)\n      if cached?\n        write Rails.cache.fetch(cache_key)\n      else\n        render(&block)\n        Rails.cache.write(cache_key, @cache_output || @output) if cache?\n      end\n    end\n\n    ##\n    # Set the canvas. If the canvas object isn't a string (e.g. cannot be cached easily),\n    # a @cache_output String is created, that will mirror what is being written to the canvas.\n    def set_canvas(canvas)\n      @cache_output = ''.html_safe\n      @output = canvas\n    end\n  end\nend\n",
    "expected_output": "#-- copyright\n# OpenProject is an open source project management software.\n# Copyright (C) 2012-2021 the OpenProject GmbH\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License version 3.\n#\n# OpenProject is a fork of ChiliProject, which is a fork of Redmine. The copyright follows:\n# Copyright (C) 2006-2013 Jean-Philippe Lang\n# Copyright (C) 2010-2013 the ChiliProject Team\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n#\n# See COPYRIGHT and LICENSE files for more details.\n#++\n\nrequire 'digest/sha1'\n\nmodule ::Widget\n  class Base < Widget::ReportingWidget\n    attr_reader :engine, :output\n    attr_accessor :request\n\n    ##\n    # Deactivate caching for certain widgets. If called on Widget::Base,\n    # caching is deactivated globally\n    def self.dont_cache!\n      @dont_cache = true\n    end\n\n    ##\n    # Query whether this widget class should be cached.\n    def self.dont_cache?\n      @dont_cache or self != Widget::Base && Widget::Base.dont_cache?\n    end\n\n    def initialize(query)\n      @subject = query\n      @engine = query.class\n      @options = {}\n    end\n\n    ##\n    # Write a string to the canvas. The string is marked as html_safe.\n    # This will write twice, if @cache_output is set.\n    def write(str)\n      str ||= ''\n      @output ||= ''.html_safe\n      @output = @output + '' if @output.frozen? # Rails 2 freezes tag strings\n      @output.concat str.html_safe\n      @cache_output.concat(str.html_safe) if @cache_output\n      str.html_safe\n    end\n\n    ##\n    # Render this widget. Abstract method. Needs to call #write at least once\n    def render\n      raise NotImplementedError, \"#render is missing in my subclass #{self.class}\"\n    end\n\n    ##\n    # Render this widget, passing options.\n    # Available options:\n    #   :to => canvas - The canvas (streaming or otherwise) to render to. Has to respond to #write\n    def render_with_options(options = {}, &block)\n      set_canvas(options.delete(:to)) if options.has_key? :to\n      @options = options\n      render_with_cache(options, &block)\n      @output\n    end\n\n    def cache_key\n      @cache_key ||= Digest::SHA256.hexdigest begin\n        if subject.respond_to? :cache_key\n          \"#{I18n.locale}/#{self.class.name.demodulize}/#{subject.cache_key}/#{@options.sort_by(&:to_s)}\"\n        else\n          subject.inspect\n        end\n      end\n    end\n\n    def cached?\n      cache? && Rails.cache.exist?(cache_key)\n    end\n\n    private\n\n    def cache?\n      !self.class.dont_cache?\n    end\n\n    ##\n    # Render this widget or serve it from cache\n    def render_with_cache(_options = {}, &block)\n      if cached?\n        write Rails.cache.fetch(cache_key)\n      else\n        render(&block)\n        Rails.cache.write(cache_key, @cache_output || @output) if cache?\n      end\n    end\n\n    ##\n    # Set the canvas. If the canvas object isn't a string (e.g. cannot be cached easily),\n    # a @cache_output String is created, that will mirror what is being written to the canvas.\n    def set_canvas(canvas)\n      @cache_output = ''.html_safe\n      @output = canvas\n    end\n  end\nend\n"
  },
  {
    "name": "CWE-611",
    "description": "A single line patch",
    "old_code": "\n    def cache_key\n      @cache_key ||= Digest::SHA1::hexdigest begin\n        if subject.respond_to? :cache_key\n          \"#{I18n.locale}/#{self.class.name.demodulize}/#{subject.cache_key}/#{@options.sort_by(&:to_s)}\"\n        else\n          subject.inspect\n        end\n      end\n    end\n",
    "new_code": "\n    def cache_key\n      @cache_key ||= Digest::SHA256.hexdigest begin\n        if subject.respond_to? :cache_key\n          \"#{I18n.locale}/#{self.class.name.demodulize}/#{subject.cache_key}/#{@options.sort_by(&:to_s)}\"\n        else\n          subject.inspect\n        end\n      end\n    end\n",
    "source_content": "#-- copyright\n# OpenProject is an open source project management software.\n# Copyright (C) 2012-2021 the OpenProject GmbH\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License version 3.\n#\n# OpenProject is a fork of ChiliProject, which is a fork of Redmine. The copyright follows:\n# Copyright (C) 2006-2013 Jean-Philippe Lang\n# Copyright (C) 2010-2013 the ChiliProject Team\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n#\n# See COPYRIGHT and LICENSE files for more details.\n#++\n\nrequire 'digest/sha1'\n\nmodule ::Widget\n  class Base < Widget::ReportingWidget\n    attr_reader :engine, :output\n    attr_accessor :request\n\n    ##\n    # Deactivate caching for certain widgets. If called on Widget::Base,\n    # caching is deactivated globally\n    def self.dont_cache!\n      @dont_cache = true\n    end\n\n    ##\n    # Query whether this widget class should be cached.\n    def self.dont_cache?\n      @dont_cache or self != Widget::Base && Widget::Base.dont_cache?\n    end\n\n    def initialize(query)\n      @subject = query\n      @engine = query.class\n      @options = {}\n    end\n\n    ##\n    # Write a string to the canvas. The string is marked as html_safe.\n    # This will write twice, if @cache_output is set.\n    def write(str)\n      str ||= ''\n      @output ||= ''.html_safe\n      @output = @output + '' if @output.frozen? # Rails 2 freezes tag strings\n      @output.concat str.html_safe\n      @cache_output.concat(str.html_safe) if @cache_output\n      str.html_safe\n    end\n\n    ##\n    # Render this widget. Abstract method. Needs to call #write at least once\n    def render\n      raise NotImplementedError, \"#render is missing in my subclass #{self.class}\"\n    end\n\n    ##\n    # Render this widget, passing options.\n    # Available options:\n    #   :to => canvas - The canvas (streaming or otherwise) to render to. Has to respond to #write\n    def render_with_options(options = {}, &block)\n      set_canvas(options.delete(:to)) if options.has_key? :to\n      @options = options\n      render_with_cache(options, &block)\n      @output\n    end\n\n    def cache_key\n      @cache_key ||= Digest::SHA1::hexdigest begin\n        if subject.respond_to? :cache_key\n          \"#{I18n.locale}/#{self.class.name.demodulize}/#{subject.cache_key}/#{@options.sort_by(&:to_s)}\"\n        else\n          subject.inspect\n        end\n      end\n    end\n\n    def cached?\n      cache? && Rails.cache.exist?(cache_key)\n    end\n\n    private\n\n    def cache?\n      !self.class.dont_cache?\n    end\n\n    ##\n    # Render this widget or serve it from cache\n    def render_with_cache(_options = {}, &block)\n      if cached?\n        write Rails.cache.fetch(cache_key)\n      else\n        render(&block)\n        Rails.cache.write(cache_key, @cache_output || @output) if cache?\n      end\n    end\n\n    ##\n    # Set the canvas. If the canvas object isn't a string (e.g. cannot be cached easily),\n    # a @cache_output String is created, that will mirror what is being written to the canvas.\n    def set_canvas(canvas)\n      @cache_output = ''.html_safe\n      @output = canvas\n    end\n  end\nend\n",
    "expected_output": "#-- copyright\n# OpenProject is an open source project management software.\n# Copyright (C) 2012-2021 the OpenProject GmbH\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License version 3.\n#\n# OpenProject is a fork of ChiliProject, which is a fork of Redmine. The copyright follows:\n# Copyright (C) 2006-2013 Jean-Philippe Lang\n# Copyright (C) 2010-2013 the ChiliProject Team\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n#\n# See COPYRIGHT and LICENSE files for more details.\n#++\n\nrequire 'digest/sha1'\n\nmodule ::Widget\n  class Base < Widget::ReportingWidget\n    attr_reader :engine, :output\n    attr_accessor :request\n\n    ##\n    # Deactivate caching for certain widgets. If called on Widget::Base,\n    # caching is deactivated globally\n    def self.dont_cache!\n      @dont_cache = true\n    end\n\n    ##\n    # Query whether this widget class should be cached.\n    def self.dont_cache?\n      @dont_cache or self != Widget::Base && Widget::Base.dont_cache?\n    end\n\n    def initialize(query)\n      @subject = query\n      @engine = query.class\n      @options = {}\n    end\n\n    ##\n    # Write a string to the canvas. The string is marked as html_safe.\n    # This will write twice, if @cache_output is set.\n    def write(str)\n      str ||= ''\n      @output ||= ''.html_safe\n      @output = @output + '' if @output.frozen? # Rails 2 freezes tag strings\n      @output.concat str.html_safe\n      @cache_output.concat(str.html_safe) if @cache_output\n      str.html_safe\n    end\n\n    ##\n    # Render this widget. Abstract method. Needs to call #write at least once\n    def render\n      raise NotImplementedError, \"#render is missing in my subclass #{self.class}\"\n    end\n\n    ##\n    # Render this widget, passing options.\n    # Available options:\n    #   :to => canvas - The canvas (streaming or otherwise) to render to. Has to respond to #write\n    def render_with_options(options = {}, &block)\n      set_canvas(options.delete(:to)) if options.has_key? :to\n      @options = options\n      render_with_cache(options, &block)\n      @output\n    end\n\n    def cache_key\n      @cache_key ||= Digest::SHA256.hexdigest begin\n        if subject.respond_to? :cache_key\n          \"#{I18n.locale}/#{self.class.name.demodulize}/#{subject.cache_key}/#{@options.sort_by(&:to_s)}\"\n        else\n          subject.inspect\n        end\n      end\n    end\n\n    def cached?\n      cache? && Rails.cache.exist?(cache_key)\n    end\n\n    private\n\n    def cache?\n      !self.class.dont_cache?\n    end\n\n    ##\n    # Render this widget or serve it from cache\n    def render_with_cache(_options = {}, &block)\n      if cached?\n        write Rails.cache.fetch(cache_key)\n      else\n        render(&block)\n        Rails.cache.write(cache_key, @cache_output || @output) if cache?\n      end\n    end\n\n    ##\n    # Set the canvas. If the canvas object isn't a string (e.g. cannot be cached easily),\n    # a @cache_output String is created, that will mirror what is being written to the canvas.\n    def set_canvas(canvas)\n      @cache_output = ''.html_safe\n      @output = canvas\n    end\n  end\nend\n"
  }
]
