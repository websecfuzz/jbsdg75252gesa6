# frozen_string_literal: true

require 'spec_helper'

RSpec.describe VulnerabilityPolicy, feature_category: :vulnerability_management do
  describe '#rules' do
    let(:project) { create(:project) }
    let(:user) { create(:user) }
    let(:vulnerability) { create(:vulnerability, :with_finding, project: project) }

    subject { described_class.new(user, vulnerability) }

    context 'when the security_dashboard feature is enabled' do
      before do
        stub_licensed_features(security_dashboard: true)
      end

      context "when the current user is not a project member" do
        it { is_expected.to be_disallowed(:read_security_resource) }
        it { is_expected.to be_disallowed(:read_vulnerability) }
        it { is_expected.to be_disallowed(:create_note) }
        it { is_expected.to be_disallowed(:explain_vulnerability) }
        it { is_expected.to be_disallowed(:resolve_vulnerability) }
      end

      context "when the current user has developer access to the vulnerability's project" do
        before do
          project.add_developer(user)
        end

        it { is_expected.to be_allowed(:read_security_resource) }
        it { is_expected.to be_allowed(:read_vulnerability) }
        it { is_expected.to be_allowed(:create_external_issue_link) }
        it { is_expected.to be_allowed(:create_note) }
      end

      context "when the current user has admin_vulnerability via a custom role" do
        let_it_be(:user) { create(:user) }
        let_it_be(:project) { create(:project, :in_group) }
        let_it_be(:role) { create(:member_role, :guest, :admin_vulnerability, namespace: project.group) }
        let_it_be(:membership) { create(:group_member, :guest, user: user, source: project.group, member_role: role) }
        let_it_be(:vulnerability) { create(:vulnerability, :with_finding, project: project) }

        subject { described_class.new(user, vulnerability) }

        before do
          stub_licensed_features(
            custom_roles: true,
            jira_vulnerabilities_integration: true,
            security_dashboard: true
          )
        end

        it { is_expected.to be_allowed(:admin_vulnerability) }
        it { is_expected.to be_allowed(:create_external_issue_link) }
      end

      context 'when the security_dashboard feature is disabled' do
        before do
          stub_licensed_features(security_dashboard: false)
          project.add_developer(user)
        end

        it { is_expected.to be_disallowed(:read_security_resource) }
        it { is_expected.to be_disallowed(:read_vulnerability) }
        it { is_expected.to be_disallowed(:create_external_issue_link) }
        it { is_expected.to be_disallowed(:create_note) }
      end

      context 'when the user is project member but does not have proper access' do
        before do
          project.add_guest(user)
        end

        it do
          is_expected.to be_disallowed(:create_note)
        end
      end
    end

    describe 'explain_vulnerability_with_ai' do
      let(:cloud_connector_user_access) { true }

      before do
        stub_licensed_features(security_dashboard: true)
        project.add_developer(user)
        allow(::Gitlab::Llm::Chain::Utils::ChatAuthorizer).to receive_message_chain(:resource,
          :allowed?).and_return(authorized)
        allow(user).to receive(:can?).with(:admin_all_resources).and_call_original
        allow(user).to receive(:can?).with("read_vulnerability", vulnerability).and_return(true)
        allow(user).to receive(:can?).with(:access_duo_chat).and_return(true)
        allow(user).to receive(:can?).with(:access_duo_features, vulnerability.project).and_return(true)
        allow(user).to receive(:allowed_to_use?).and_return(cloud_connector_user_access)
      end

      context 'when feature is authorized' do
        let(:authorized) { true }

        it { is_expected.to be_allowed(:explain_vulnerability_with_ai) }

        context 'when user cannot read_security_resource' do
          before do
            project.add_guest(user)
          end

          it { is_expected.to be_disallowed(:explain_vulnerability_with_ai) }
        end

        context 'when service is not authorized' do
          let(:cloud_connector_user_access) { false }

          it { is_expected.to be_disallowed(:explain_vulnerability_with_ai) }
        end
      end

      context 'when feature is not authorized' do
        let(:authorized) { false }

        it { is_expected.to be_disallowed(:explain_vulnerability_with_ai) }
      end
    end

    describe 'resolve_vulnerability_with_ai' do
      let(:authorizer) { instance_double(::Gitlab::Llm::FeatureAuthorizer) }

      before do
        stub_licensed_features(security_dashboard: true)
        project.add_developer(user)
        allow(::Gitlab::Llm::FeatureAuthorizer).to receive(:new).and_return(authorizer)
      end

      context 'when feature is authorized' do
        before do
          allow(authorizer).to receive(:allowed?).and_return(true)
        end

        it { is_expected.to be_allowed(:resolve_vulnerability_with_ai) }

        context 'when user cannot read_security_resource' do
          before do
            project.add_guest(user)
          end

          it { is_expected.to be_disallowed(:resolve_vulnerability_with_ai) }
        end
      end

      context 'when feature is not authorized' do
        before do
          allow(authorizer).to receive(:allowed?).and_return(false)
        end

        it { is_expected.to be_disallowed(:resolve_vulnerability_with_ai) }
      end
    end
  end
end
