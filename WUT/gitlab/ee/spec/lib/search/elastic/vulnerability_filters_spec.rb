# frozen_string_literal: true

require 'spec_helper'

RSpec.describe ::Search::Elastic::VulnerabilityFilters, feature_category: :vulnerability_management do
  using RSpec::Parameterized::TableSyntax

  include_context 'with filters shared context'

  describe '.by_created_at' do
    subject(:by_created_at) { described_class.by_created_at(query_hash: query_hash, options: options) }

    context 'when created_after and created_before options are provided' do
      let(:created_after) { '2021-01-01T00:00:00Z' }
      let(:created_before) { '2021-12-31T00:00:00Z' }
      let(:options) { { created_after: created_after, created_before: created_before } }

      it 'adds the range filter to query_hash' do
        query_hash = by_created_at
        expected_filter = [range: {
          created_at: {
            _name: 'filters:range:created_at',
            gte: created_after,
            lte: created_before
          }
        }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end

    context 'when created_before is less than created_after' do
      let(:created_after) { '2021-12-31T00:00:00Z' }
      let(:created_before) { '2021-01-01T00:00:00Z' }
      let(:options) { { created_after: created_after, created_before: created_before } }

      it 'raises an ArgumentError' do
        expect { by_created_at }.to raise_error(ArgumentError, 'created_before must be >= created_after')
      end
    end

    context 'when created_after option is missing' do
      let(:created_after) { '2021-01-01T00:00:00Z' }
      let(:created_before) { nil }
      let(:options) { { created_after: created_after, created_before: created_before } }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when created_before option is missing' do
      let(:created_after) { nil }
      let(:created_before) { '2021-12-31T00:00:00Z' }
      let(:options) { { created_after: created_after, created_before: created_before } }

      it_behaves_like 'does not modify the query_hash'
    end
  end

  describe '.by_archived_projects' do
    subject(:by_archived_projects) { described_class.by_archived_projects(query_hash: query_hash, options: options) }

    context 'when search_level not provided in options' do
      let(:options) { {} }

      it 'raises an exception' do
        expect { by_archived_projects }.to raise_exception(ArgumentError)
      end
    end

    context 'when options[:include_archived_projects] is empty' do
      let(:options) { { search_level: 'group' } }

      it 'adds the archived filter to query_hash' do
        query_hash = by_archived_projects
        expected_filter = [{ term: { archived: { _name: 'filters:archived_projects', value: false } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end

    context 'when options[:include_archived_projects] is false' do
      let(:options) { { include_archived_projects: false, search_level: 'group' } }

      it 'adds the archived filter to query_hash' do
        query_hash = by_archived_projects
        expected_filter = [{ term: { archived: { _name: 'filters:archived_projects', value: false } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end

    context 'when options[:include_archived] is true' do
      let(:options) { { include_archived_projects: true, search_level: 'group' } }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:search_level] is project' do
      let(:options) { { include_archived_projects: false, search_level: 'project' } }

      it_behaves_like 'does not modify the query_hash'
    end
  end

  describe '.by_cluster_agent_id' do
    subject(:by_cluster_agent_id) { described_class.by_cluster_agent_id(query_hash: query_hash, options: options) }

    context 'when options[:cluster_agent_id] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:cluster_agent_id] is provided' do
      let(:options) { { cluster_agent_id: ['123'] } }

      it 'adds the cluster_agent_id filter to query_hash' do
        query_hash = by_cluster_agent_id
        expected_filter = [{ terms: { _name: 'filters:cluster_agent_id',
                                      cluster_agent_id: options[:cluster_agent_id] } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_state_and_dismissal_reason' do
    subject(:by_state_and_dismissal_reason) do
      described_class.by_state_and_dismissal_reason(query_hash: query_hash, options: options)
    end

    context 'when options[:state] and options[:dismissal_reason] are empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:state] and options[:dismissal_reason] are provided' do
      let(:options) { { state: [1, 2, 3], dismissal_reason: [1] } }

      it 'adds the state and dismissal_reason filter to query_hash' do
        query_hash = by_state_and_dismissal_reason
        expected_filter = [
          {
            bool: {
              _name: 'filters:state_and_dismissal_reason',
              should: [
                { terms: { state: options[:state] } },
                {
                  bool: {
                    must: [
                      {
                        terms: { state: [2] }
                      },
                      {
                        terms: { dismissal_reason: options[:dismissal_reason] }
                      }
                    ]
                  }
                }
              ],
              minimum_should_match: 1
            }
          }
        ]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end

    context 'when only options[:state] is provided' do
      let(:options) { { state: [1] } }

      it 'adds the state filter to query_hash' do
        query_hash = by_state_and_dismissal_reason
        expected_filter = [{ terms: { _name: 'filters:state', state: options[:state] } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end

    context 'when only options[:dismissal_reason] is provided' do
      let(:options) { { dismissal_reason: [1] } }

      it 'adds the dismissal_reason filter to query_hash' do
        query_hash = by_state_and_dismissal_reason
        expected_filter = [
          {
            bool: {
              _name: 'filters:dismissal_reason',
              must: [
                {
                  terms: { state: [2] }
                },
                {
                  terms: { dismissal_reason: options[:dismissal_reason] }
                }
              ]
            }
          }
        ]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_has_ai_resolution' do
    subject(:by_has_ai_resolution) { described_class.by_has_ai_resolution(query_hash: query_hash, options: options) }

    context 'when options[:has_ai_resolution] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:has_ai_resolution] contains a valid search has_ai_resolution' do
      let(:options) { { has_ai_resolution: true } }

      it 'adds the report_type filter to query_hash' do
        query_hash = by_has_ai_resolution
        expected_filter = [
          { term: { has_vulnerability_resolution: { _name: 'filters:has_ai_resolution', value: true } } }
        ]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_has_issues' do
    subject(:by_has_issues) { described_class.by_has_issues(query_hash: query_hash, options: options) }

    context 'when options[:has_issues] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:has_issues] contains a valid search has_issues' do
      let(:options) { { has_issues: true } }

      it 'adds the report_type filter to query_hash' do
        query_hash = by_has_issues
        expected_filter = [{ term: { has_issues: { _name: 'filters:has_issues', value: true } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_has_merge_request' do
    subject(:by_has_merge_request) { described_class.by_has_merge_request(query_hash: query_hash, options: options) }

    context 'when options[:has_merge_request] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:has_merge_request] contains a valid search has_merge_request' do
      let(:options) { { has_merge_request: true } }

      it 'adds the report_type filter to query_hash' do
        query_hash = by_has_merge_request
        expected_filter = [{ term: { has_merge_request: { _name: 'filters:has_merge_request', value: true } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_has_remediations' do
    subject(:by_has_remediations) { described_class.by_has_remediations(query_hash: query_hash, options: options) }

    context 'when options[:has_remediations] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:has_remediations] contains a valid search has_remediations' do
      let(:options) { { has_remediations: true } }

      it 'adds the report_type filter to query_hash' do
        query_hash = by_has_remediations
        expected_filter = [{ term: { has_remediations: { _name: 'filters:has_remediations', value: true } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_has_resolution' do
    subject(:by_has_resolution) { described_class.by_has_resolution(query_hash: query_hash, options: options) }

    context 'when options[:has_resolution] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:has_resolution] contains a valid search has_resolution' do
      let(:options) { { has_resolution: true } }

      it 'adds the report_type filter to query_hash' do
        query_hash = by_has_resolution
        expected_filter = [{ term: { resolved_on_default_branch: { _name: 'filters:has_resolution', value: true } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_identifier_names' do
    subject(:by_identifier_names) { described_class.by_identifier_names(query_hash: query_hash, options: options) }

    context 'when options[:identifier_names] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:identifier_names] contains a valid search identifier_name' do
      let(:options) do
        { identifier_name: %w[cve-2020-5247] }
      end

      it 'adds the identifier_name filter to query_hash' do
        query_hash = by_identifier_names
        expected_filter = [{ term: { "identifier_names.keyword": { _name: 'filters:identifier_name',
                                                                   value: options[:identifier_name] } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_partial_identifier_name' do
    subject(:by_partial_identifier_name) do
      described_class.by_partial_identifier_name(query_hash: query_hash, options: options)
    end

    context 'when options[:partial_identifier_name] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:partial_identifier_name] contains a valid search partial_identifier_name' do
      let(:options) do
        { partial_identifier_name: "cve-2020-5247" }
      end

      it 'adds the identifier_name filter to query_hash' do
        query_hash = by_partial_identifier_name
        expected_filter = [
          {
            bool: {
              must: {
                simple_query_string: {
                  _name: "filters:partial_identifier_name",
                  fields: [
                    "identifier_names",
                    "identifier_names.ngram"
                  ],
                  query: options[:partial_identifier_name],
                  lenient: true,
                  default_operator: :and
                }
              }
            }
          }
        ]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_image' do
    subject(:by_image) { described_class.by_image(query_hash: query_hash, options: options) }

    context 'when options[:image] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:image] is provided' do
      let(:options) { { image: ['my_image'] } }

      it 'adds the image filter to query_hash' do
        query_hash = by_image
        expected_filter = [{ terms: { _name: 'filters:image', location_image: options[:image] } }]
        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  context 'for owasp top 10 filters' do
    shared_examples_for 'searches for the given filter' do
      it 'adds the owasp top 10 filter to query_hash' do
        expected_filter = [
          {
            bool: {
              _name: "filters:owasp_top_10_#{year}",
              must: {
                bool: {
                  should: result.map do |v|
                    {
                      prefix: {
                        "identifier_names.keyword": {
                          value: v
                        }
                      }
                    }
                  end,
                  minimum_should_match: 1
                }
              }
            }
          }
        ]

        aggregate_failures do
          expect(result_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(result_hash.dig(:query, :bool, :must)).to be_empty
          expect(result_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(result_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end

    shared_examples_for 'searches for where there is no owasp identifer' do
      it 'adds the owasp top 10 filter to query_hash' do
        owasp_keys = if year == '2017'
                       ::Enums::Vulnerability::OWASP_TOP_10.keys
                     else
                       ::Enums::Vulnerability::OWASP_TOP_10_BY_YEAR[year].keys
                     end

        expected_filter = [
          {
            bool: {
              _name: "filters:owasp_top_10_#{year}",
              must_not: {
                bool: {
                  should: owasp_keys.map do |k|
                    formatted_key = k.split("-").first
                    {
                      prefix: {
                        "identifier_names.keyword": {
                          value: formatted_key
                        }
                      }
                    }
                  end,
                  minimum_should_match: 1
                }
              }
            }
          }
        ]

        aggregate_failures do
          expect(result_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(result_hash.dig(:query, :bool, :must)).to be_empty
          expect(result_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(result_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end

    describe '.by_owasp_top_10_2017' do
      subject(:by_owasp_top_10_2017) { described_class.by_owasp_top_10_2017(query_hash: query_hash, options: options) }

      context 'when options[:owasp_top_10_2017] is empty' do
        let(:options) { {} }

        it_behaves_like 'does not modify the query_hash'
      end

      context "when invalid options[:owasp_top_10_2017] is provided" do
        let(:options) { { owasp_top_10_2017: ["invalid_string"] } }

        it_behaves_like 'does not modify the query_hash'
      end

      context 'when valid options[:owasp_top_10_2017] is provided' do
        let(:options_1) do
          { owasp_top_10_2017: ["A3:2017-Sensitive Data Exposure"] }
        end

        let(:options_2) do
          { owasp_top_10_2017: ["A10:2017-Insufficient Logging & Monitoring", "A03:2021-Injection"] }
        end

        where(:options, :result) do
          ref(:options_1) | ["A3:2017"]
          ref(:options_2) | ["A10:2017", "A03:2021"]
        end

        with_them do
          it_behaves_like 'searches for the given filter' do
            let(:result_hash) { by_owasp_top_10_2017 }
            let(:year) { '2017' }
          end
        end
      end

      context "when options[:owasp_top_10_2017] is none" do
        let(:options) do
          { owasp_top_10_2017: ["none"] }
        end

        it_behaves_like 'searches for where there is no owasp identifer' do
          let(:result_hash) { by_owasp_top_10_2017 }
          let(:year) { '2017' }
        end
      end
    end

    describe '.by_owasp_top_10_2021' do
      subject(:by_owasp_top_10_2021) { described_class.by_owasp_top_10_2021(query_hash: query_hash, options: options) }

      context 'when options[:owasp_top_10_2021] is empty' do
        let(:options) { {} }

        it_behaves_like 'does not modify the query_hash'
      end

      context "when invalid options[:owasp_top_10_2021] is provided" do
        let(:options) { { owasp_top_10_2021: ["invalid_string"] } }

        it_behaves_like 'does not modify the query_hash'
      end

      context 'when valid options[:owasp_top_10_2021] is provided' do
        let(:options_1) do
          { owasp_top_10_2021: ["A3:2021-Injection"] }
        end

        let(:options_2) do
          { owasp_top_10_2021: ["A10:2021-Server-Side Request Forgery", "A4:2021-Insecure Design"] }
        end

        let(:options_3) do
          { owasp_top_10_2021: ["A03:2021-Injection"] }
        end

        where(:options, :result) do
          ref(:options_1) | ["A3:2021"]
          ref(:options_2) | ["A10:2021", "A4:2021"]
          ref(:options_3) | ["A03:2021"]
        end

        with_them do
          it_behaves_like 'searches for the given filter' do
            let(:result_hash) { by_owasp_top_10_2021 }
            let(:year) { '2021' }
          end
        end
      end

      context "when options[:owasp_top_10_2021] is NONE" do
        let(:options) do
          { owasp_top_10_2021: ["NONE"] }
        end

        it_behaves_like 'searches for where there is no owasp identifer' do
          let(:result_hash) { by_owasp_top_10_2021 }
          let(:year) { '2021' }
        end
      end
    end
  end

  describe '.by_projects' do
    subject(:by_projects) { described_class.by_projects(query_hash: query_hash, options: options) }

    context 'when options[:project_id] is empty' do
      let(:options) { { search_level: 'group' } }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:project_id] is provided' do
      let(:options) { { project_id: [1] } }

      it 'adds the project_id filter to query_hash' do
        query_hash = by_projects
        expected_filter = [{ terms: { _name: 'filters:project_id', project_id: options[:project_id] } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_report_type' do
    subject(:by_report_type) { described_class.by_report_type(query_hash: query_hash, options: options) }

    context 'when options[:report_type] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:report_type] contains a valid search report_type' do
      let(:options) { { report_type: [0, 1] } }

      it 'adds the report_type filter to query_hash' do
        query_hash = by_report_type
        expected_filter = [{ terms: { _name: 'filters:report_type', report_type: options[:report_type] } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
        end
      end
    end
  end

  describe '.by_scanner_external_ids' do
    subject(:by_scanner_external_ids) do
      described_class.by_scanner_external_ids(query_hash: query_hash, options: options)
    end

    context 'when options[:scanner_external_id] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:scanner_external_id] contains a valid search scanner_external_id' do
      let(:options) { { scanner_external_id: %w[gemnasium] } }

      it 'adds the scanner_external_id filter to query_hash' do
        query_hash = by_scanner_external_ids
        expected_filter = [{ terms: { _name: 'filters:scanner_external_id',
                                      scanner_external_id: options[:scanner_external_id] } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
        end
      end
    end
  end

  describe '.by_scanner_ids' do
    subject(:by_scanner_ids) { described_class.by_scanner_ids(query_hash: query_hash, options: options) }

    context 'when options[:scanner_id] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:scanner_id] contains a valid search scanner_id' do
      let(:options) { { scanner_id: [1, 2, 3] } }

      it 'adds the scanner_id filter to query_hash' do
        query_hash = by_scanner_ids
        expected_filter = [{ terms: { _name: 'filters:scanner_id',
                                      scanner_id: options[:scanner_id] } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
        end
      end
    end
  end

  describe '.by_severities' do
    subject(:by_severities) { described_class.by_severities(query_hash: query_hash, options: options) }

    context 'when options[:severity] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'

      context 'when options[:severity] contains a valid search severity' do
        let(:options) { { severity: [1, 7] } }

        it 'adds the severity filter to query_hash' do
          query_hash = by_severities
          expected_filter = [{ terms: { _name: 'filters:severity', severity: options[:severity] } }]

          aggregate_failures do
            expect(query_hash.dig(:query, :bool, :must)).to be_empty
            expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
            expect(query_hash.dig(:query, :bool, :should)).to be_empty
            expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          end
        end
      end
    end
  end

  describe '.by_reachability' do
    subject(:by_reachability) { described_class.by_reachability(query_hash: query_hash, options: options) }

    context 'when options[:reachability] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'

      context 'with invalid reachability value' do
        let(:options) { { reachability: [Sbom::Occurrence.reachabilities.values.last + 1] } }

        it_behaves_like 'does not modify the query_hash'
      end

      context 'when options[:reachability] contains a valid reachability' do
        let(:options) { { reachability: [::Sbom::Occurrence.reachabilities.each_value.first] } }
        let(:expected_query) do
          {
            query: {
              bool: {
                filter: [{
                  terms: {
                    _name: "filters:reachability",
                    reachability: [0]
                  }
                }],
                must_not: [],
                must: [],
                should: []
              }
            }
          }
        end

        it 'adds the reachability filter to query_hash' do
          expect(by_reachability).to eq(expected_query)
        end
      end
    end
  end
end
