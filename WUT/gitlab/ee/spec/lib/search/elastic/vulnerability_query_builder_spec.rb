# frozen_string_literal: true

require 'spec_helper'

RSpec.describe ::Search::Elastic::VulnerabilityQueryBuilder, :elastic_helpers, feature_category: :vulnerability_management do
  let(:base_options) do
    {
      search_level: 'group'
    }
  end

  let(:options) { base_options }

  subject(:build) { described_class.build(query: nil, options: options) }

  it 'contains all default expected filters' do
    assert_names_in_query(build, with: %w[
      filters:archived_projects
    ])
  end

  describe 'filters' do
    let_it_be(:project) { create(:project) }

    describe 'traversal_id' do
      let(:options) { base_options.merge(traversal_ids: project.namespace.traversal_ids) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          namespace:ancestry_filter:descendants
        ])
      end
    end

    describe 'created_at' do
      let(:options) do
        base_options.merge(created_after: '2021-01-01T00:00:00Z', created_before: '2021-12-31T00:00:00Z')
      end

      it 'does add range:created_ad filter' do
        assert_names_in_query(build, with: %w[filters:range:created_at])
      end
    end

    describe 'archived' do
      let(:options) { base_options.merge(include_archived_projects: true) }

      it 'show only non-archived projects vulnerabilities' do
        assert_names_in_query(build, without: %w[filters:archived_projects])
      end
    end

    describe 'cluster_agent_id' do
      let_it_be(:cluster_agent) { create(:cluster_agent, project: project) }
      let(:options) { base_options.merge(cluster_agent_id: cluster_agent.id.to_s) }

      it 'show only non-archived projects vulnerabilities' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:cluster_agent_id
        ])
      end
    end

    describe 'state and dismissal_reason' do
      context 'when state and dismissal_reason are set' do
        let(:options) { base_options.merge(dismissal_reason: [1], state: [1, 2, 3]) }

        it 'does add both state and dismissal reason filters' do
          assert_names_in_query(build, with: %w[filters:state_and_dismissal_reason])
        end
      end

      context 'when state is set but dismissal_reason is not set' do
        let(:options) { base_options.merge(state: [1, 2, 3]) }

        it 'does add only state filter' do
          assert_names_in_query(build, with: %w[filters:state])
        end
      end

      context 'when state is not set but dismissal_reason is set' do
        let(:options) { base_options.merge(dismissal_reason: [1]) }

        it 'does add only dismissal reason filters' do
          assert_names_in_query(build, with: %w[filters:dismissal_reason])
        end
      end
    end

    describe 'has_ai_resolution' do
      let(:options) { base_options.merge(has_ai_resolution: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_ai_resolution
        ])
      end
    end

    describe 'has_issues' do
      let(:options) { base_options.merge(has_issues: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_issues
        ])
      end
    end

    describe 'has_merge_request' do
      let(:options) { base_options.merge(has_merge_request: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_merge_request
        ])
      end
    end

    describe 'has_remediations' do
      let(:options) { base_options.merge(has_remediations: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_remediations
        ])
      end
    end

    describe 'has_resolution' do
      let(:options) { base_options.merge(has_resolution: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_resolution
        ])
      end
    end

    describe 'identifier_names' do
      let(:identifier_name) { 'CVE-2024-1234' }
      let(:options) { base_options.merge(identifier_name: [identifier_name]) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:identifier_name
        ])
      end
    end

    describe 'image' do
      let(:options) { base_options.merge(image: ['image_name']) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:image
        ])
      end
    end

    describe 'projects' do
      let(:options) { base_options.merge(project_id: [project.id]) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:project_id
        ])
      end
    end

    describe 'report_type' do
      let(:options) { base_options.merge(report_type: [1]) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:report_type
        ])
      end
    end

    describe 'scanner_external_id' do
      let(:options) { base_options.merge(scanner_external_id: ["gemnasium"]) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:scanner_external_id
        ])
      end
    end

    describe 'scanner_id' do
      let(:options) { base_options.merge(scanner_id: [1]) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:scanner_id
        ])
      end
    end

    describe 'severity' do
      let(:options) { base_options.merge(severity: [1]) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:severity
        ])
      end
    end
  end

  describe 'search_identifier_names' do
    let(:options) { base_options.merge(search_identifier_names: true, partial_identifier_name: "cve") }

    it 'does add aggregation' do
      query = build

      expect(query).to include(aggs: { unique_identifiers: be_a(Hash) })
    end
  end

  describe 'count_by_severities' do
    let(:options) { base_options.merge(count_by_severity: true) }

    it 'does add aggregation' do
      query = build

      expect(query).to include(aggs: { severity_counts: be_a(Hash) })
    end
  end

  describe 'sort' do
    it 'does not sort by default' do
      expect(build).to include(sort: {})
    end

    context 'when sort option is provided' do
      let(:options) { base_options.merge(sort: :severity_asc) }

      it 'applies the sort' do
        expect(build).to include(sort: { severity: { order: 'asc' }, vulnerability_id: { order: 'desc' } })
      end
    end
  end

  describe 'formats' do
    it_behaves_like 'a query that sets source_fields',
      ::Search::Elastic::References::Vulnerability::DEFAULT_SOURCE_FIELDS
    it_behaves_like 'a query formatted for size'
    it_behaves_like 'a query that is paginated'
  end

  describe 'reachability' do
    let(:options) { base_options.merge(reachability: [::Sbom::Occurrence.reachabilities.values.last]) }

    context 'with finished migrations' do
      before do
        allow(::Elastic::DataMigrationService).to receive(:migration_has_finished?).and_return(true)
      end

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:reachability
        ])
      end
    end

    context 'without finished migrations' do
      before do
        allow(::Elastic::DataMigrationService).to receive(:migration_has_finished?).and_return(false)
      end

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
        ])
      end
    end
  end
end
