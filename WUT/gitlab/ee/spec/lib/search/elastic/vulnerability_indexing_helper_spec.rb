# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::Elastic::VulnerabilityIndexingHelper, feature_category: :vulnerability_management do
  describe '.vulnerability_indexing_allowed?' do
    before do
      # Reset the memoized value before each test
      described_class.instance_variable_set(:@vulnerability_indexing_allowed, nil)

      # Default all conditions to false
      allow(Gitlab::Saas).to receive(:feature_available?).with(:advanced_search).and_return(false)
      allow(Gitlab::CurrentSettings).to receive_messages(elasticsearch_indexing?: false,
        gitlab_dedicated_instance?: false)

      # Set es_migrations_available? to return true by default
      allow(described_class).to receive(:es_migrations_available?).and_return(true)
    end

    context 'when es_index is not available' do
      before do
        allow(described_class).to receive(:es_migrations_available?).and_return(false)
      end

      context 'when SaaS with Elasticsearch is configured' do
        before do
          allow(Gitlab::CurrentSettings).to receive(:elasticsearch_indexing?).and_return(true)
          allow(Gitlab::Saas).to receive(:feature_available?).with(:advanced_search).and_return(true)
        end

        it 'returns false' do
          expect(described_class.vulnerability_indexing_allowed?).to be(false)
        end
      end

      context 'when dedicated instance with Elasticsearch is configured' do
        before do
          allow(Gitlab::CurrentSettings).to receive_messages(elasticsearch_indexing?: true,
            gitlab_dedicated_instance?: true)
        end

        it 'returns false' do
          expect(described_class.vulnerability_indexing_allowed?).to be(false)
        end
      end
    end

    context 'when es_index is available' do
      before do
        allow(described_class).to receive(:es_migrations_available?).and_return(true)
      end

      context 'when SaaS with Elasticsearch is configured' do
        before do
          allow(Gitlab::CurrentSettings).to receive(:elasticsearch_indexing?).and_return(true)
          allow(Gitlab::Saas).to receive(:feature_available?).with(:advanced_search).and_return(true)
        end

        it 'returns true' do
          expect(described_class.vulnerability_indexing_allowed?).to be(true)
        end
      end

      context 'when dedicated instance with Elasticsearch is configured' do
        before do
          allow(Gitlab::CurrentSettings).to receive_messages(elasticsearch_indexing?: true,
            gitlab_dedicated_instance?: true)
        end

        it 'returns true' do
          expect(described_class.vulnerability_indexing_allowed?).to be(true)
        end
      end

      context 'when both SaaS and dedicated instance conditions are true' do
        before do
          allow(Gitlab::Saas).to receive(:feature_available?).with(:advanced_search).and_return(true)
          allow(Gitlab::CurrentSettings).to receive_messages(elasticsearch_indexing?: true,
            gitlab_dedicated_instance?: true)
        end

        it 'returns true' do
          expect(described_class.vulnerability_indexing_allowed?).to be(true)
        end
      end

      context 'when elasticsearch indexing is disabled' do
        before do
          allow(Gitlab::CurrentSettings).to receive(:elasticsearch_indexing?).and_return(false)
        end

        context 'when SaaS advanced search is available' do
          before do
            allow(Gitlab::Saas).to receive(:feature_available?).with(:advanced_search).and_return(true)
          end

          it 'returns false' do
            expect(described_class.vulnerability_indexing_allowed?).to be(false)
          end
        end

        context 'when it is a GitLab dedicated instance' do
          before do
            allow(Gitlab::CurrentSettings).to receive(:gitlab_dedicated_instance?).and_return(true)
          end

          it 'returns false' do
            expect(described_class.vulnerability_indexing_allowed?).to be(false)
          end
        end
      end

      context 'when neither SaaS nor dedicated instance conditions are met' do
        context 'when elasticsearch indexing is enabled' do
          before do
            allow(Gitlab::CurrentSettings).to receive(:elasticsearch_indexing?).and_return(true)
          end

          it 'returns false' do
            expect(described_class.vulnerability_indexing_allowed?).to be(false)
          end
        end

        context 'when elasticsearch indexing is disabled' do
          it 'returns false' do
            expect(described_class.vulnerability_indexing_allowed?).to be(false)
          end
        end
      end
    end
  end

  describe '.es_migrations_available?' do
    let(:required_migrations) do
      [
        :create_vulnerabilities_index,
        :revise_vulnerabilities_mappings_and_field_types
      ]
    end

    context 'when all required migrations have finished' do
      before do
        required_migrations.each do |migration|
          allow(Elastic::DataMigrationService).to receive(:migration_has_finished?).with(migration).and_return(true)
        end
      end

      it 'returns true' do
        expect(described_class.send(:es_migrations_available?)).to be(true)
      end
    end

    context 'when some required migrations have not finished' do
      before do
        allow(Elastic::DataMigrationService).to receive(:migration_has_finished?).with(
          :create_vulnerabilities_index).and_return(true)
        allow(Elastic::DataMigrationService).to receive(:migration_has_finished?).with(
          :revise_vulnerabilities_mappings_and_field_types).and_return(false)
      end

      it 'returns false' do
        expect(described_class.send(:es_migrations_available?)).to be(false)
      end
    end

    context 'when no required migrations have finished' do
      before do
        required_migrations.each do |migration|
          allow(Elastic::DataMigrationService).to receive(:migration_has_finished?).with(migration).and_return(false)
        end
      end

      it 'returns false' do
        expect(described_class.send(:es_migrations_available?)).to be(false)
      end
    end
  end
end
