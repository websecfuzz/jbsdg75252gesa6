# frozen_string_literal: true

require 'spec_helper'

RSpec.describe ::Search::Elastic::References::Vulnerability, :elastic_helpers, :request_store, feature_category: :global_search do
  # Create project and group structure
  let_it_be(:parent_group) { create(:group) }
  let_it_be(:group) { create(:group, parent: parent_group) }
  let_it_be(:project) { create(:project, group: group) }
  let_it_be(:user_project) { create(:project, namespace: create(:namespace)) }

  let_it_be(:vulnerability) { create(:vulnerability, :with_read, project: project, report_type: :container_scanning) }
  let_it_be(:user_vulnerability) { create(:vulnerability, :with_read, project: user_project, report_type: :sast) }

  # Create identifiers for CVE information
  let_it_be(:identifier) do
    create(:vulnerabilities_identifier, external_type: 'cve', external_id: 'CVE-2023-12345', name: 'CVE-2023-12345')
  end

  let_it_be(:user_identifier) do
    create(:vulnerabilities_identifier, external_type: 'cve', external_id: 'CVE-2023-67890', name: 'CVE-2023-67890')
  end

  # Create findings associated with vulnerabilities
  let_it_be(:finding) do
    create(:vulnerabilities_finding, vulnerability: vulnerability, project: project, identifiers: [identifier])
  end

  let_it_be(:user_finding) do
    create(:vulnerabilities_finding, vulnerability: user_vulnerability, project: user_project,
      identifiers: [user_identifier])
  end

  let_it_be(:vulnerability_read) do
    vulnerability.vulnerability_read
  end

  let_it_be(:user_vulnerability_read) do
    user_vulnerability.vulnerability_read
  end

  # Basic configuration for tests
  before do
    allow(::Elastic::DataMigrationService).to receive(:migration_has_finished?).and_return(true)

    stub_const('Gitlab::QueryLimiting::Transaction::THRESHOLD', 100)
  end

  describe '#as_indexed_json' do
    let(:base_vulnerability_hash) do
      {
        vulnerability_id: object.vulnerability_id,
        created_at: be_within(0.1.seconds).of(object.vulnerability.created_at),
        updated_at: be_within(0.1.seconds).of(object.vulnerability.updated_at),
        project_id: object.project_id,
        scanner_id: object.scanner_id,
        scanner_external_id: object.scanner.external_id,
        report_type: object.report_type_before_type_cast,
        severity: object.severity_before_type_cast,
        state: object.state_before_type_cast,
        has_issues: object.has_issues,
        resolved_on_default_branch: object.resolved_on_default_branch,
        uuid: object.uuid,
        location_image: object.location_image,
        cluster_agent_id: object.cluster_agent_id,
        casted_cluster_agent_id: object.casted_cluster_agent_id,
        dismissal_reason: object.dismissal_reason_before_type_cast,
        has_merge_request: object.has_merge_request,
        has_remediations: object.has_remediations,
        traversal_ids: object.project.namespace.elastic_namespace_ancestry,
        archived: object.archived,
        has_vulnerability_resolution: object.has_vulnerability_resolution,
        auto_resolved: object.auto_resolved,
        identifier_names: object.identifier_names,
        epss_scores: [],
        reachability: [],
        type: described_class::DOC_TYPE,
        schema_version: described_class::SCHEMA_VERSION
      }
    end

    let(:object) { vulnerability_read }
    let(:expected_hash) { base_vulnerability_hash }

    let(:vulnerability_reference_object) do
      described_class.new(object.vulnerability_id, object.es_parent)
    end

    subject(:indexed_json) do
      vulnerability_reference_object.as_indexed_json.with_indifferent_access
    end

    it 'serializes vulnerability as a hash' do
      expect(indexed_json).to match(expected_hash)
    end

    context 'with CVE identifiers and EPSS scores' do
      let(:cve_value) { vulnerability_read.cve_value }
      let(:epss_score) { 0.85 }
      let(:cve_enrichment) do
        create(:pm_cve_enrichment, cve: cve_value, epss_score: epss_score)
      end

      before do
        allow(object).to receive_messages(
          cve_value: cve_value,
          epss_scores: [epss_score]
        )

        # epss_scores is set only during preloading by the proxy record creation. So preloading below.
        allow(PackageMetadata::CveEnrichment).to receive(:by_cves).with(
          [cve_enrichment.cve]).and_return([cve_enrichment])
        described_class.preload_indexing_data([vulnerability_reference_object])
      end

      it 'includes EPSS scores in the indexed JSON' do
        expect(indexed_json[:epss_scores]).to eq([epss_score])
      end
    end

    context 'with reachability data' do
      let(:reachability_data) { 1 }

      before do
        allow(object).to receive(:reachability).and_return(reachability_data)
        allow(vulnerability_reference_object).to receive(:database_record).and_return(object)
      end

      it 'includes reachability in the indexed JSON' do
        expect(indexed_json[:reachability]).to eq(reachability_data)
      end

      context 'when the mapping migration has not completed' do
        before do
          allow(::Elastic::DataMigrationService).to receive(
            :migration_has_finished?).with(:add_rechability_field_to_vulnerability).and_return(false)
        end

        it 'returns old schema version' do
          expect(indexed_json[:schema_version]).to eq(25_25)
        end

        it 'does not assign reachability on the indexed json' do
          expect(indexed_json[:reachability]).to be_nil
        end
      end
    end
  end

  describe '.preload_indexing_data' do
    let(:vulnerability_ref) { described_class.new(vulnerability_read.vulnerability_id, vulnerability_read.es_parent) }
    let(:user_vulnerability_ref) do
      described_class.new(user_vulnerability_read.vulnerability_id, user_vulnerability_read.es_parent)
    end

    let(:refs) { [vulnerability_ref, user_vulnerability_ref] }

    it 'preloads vulnerability records' do
      expect(::Vulnerabilities::Read).to receive(:preload_indexing_data).and_call_original
      expect(described_class).to receive(:extract_cve_values).and_call_original
      expect(described_class).to receive(:preload_cve_enrichments).and_call_original

      described_class.preload_indexing_data(refs)

      expect(vulnerability_ref.database_record).to be_present
      expect(user_vulnerability_ref.database_record).to be_present
    end

    context 'with CVE values' do
      let_it_be(:cve_enrichment) { create(:pm_cve_enrichment, cve: vulnerability_read.cve_value) }
      let_it_be(:cve_identifier) do
        create(:vulnerabilities_identifier, external_type: 'cve', external_id: cve_enrichment.cve,
          name: cve_enrichment.cve)
      end

      let_it_be(:cve_vulnerability) { create(:vulnerability, project: project, report_type: :container_scanning) }
      let_it_be(:cve_finding) do
        create(
          :vulnerabilities_finding,
          vulnerability: cve_vulnerability,
          identifiers: [cve_identifier]
        )
      end

      let(:vulnerability_ref_with_cve) do
        described_class.new(vulnerability_read.vulnerability_id, vulnerability_read.es_parent)
      end

      before do
        allow_next_instance_of(::Vulnerabilities::Read) do |instance|
          allow(instance).to receive(:cve_value).and_return(cve_enrichment.cve)
        end

        allow(PackageMetadata::CveEnrichment).to receive(:by_cves).with(
          [cve_enrichment.cve]).and_return([cve_enrichment])
      end

      it 'extracts CVE values and preloads CVE enrichments' do
        expect(PackageMetadata::CveEnrichment).to receive(:by_cves).with(
          [cve_enrichment.cve]).and_return([cve_enrichment])

        described_class.preload_indexing_data([vulnerability_ref_with_cve])
      end
    end

    context 'with reachability data' do
      let!(:sbom_occurrence_1) do
        create(:sbom_occurrence, reachability: 'in_use')
      end

      let!(:sbom_occurrence_2) do
        create(:sbom_occurrence, reachability: 'unknown')
      end

      let!(:sbom_occurrences_vulnerability_1) do
        create(:sbom_occurrences_vulnerability,
          occurrence: sbom_occurrence_1,
          vulnerability_id: vulnerability_read.vulnerability_id)
      end

      let!(:sbom_occurrences_vulnerability_2) do
        create(:sbom_occurrences_vulnerability,
          occurrence: sbom_occurrence_2,
          vulnerability_id: user_vulnerability_read.vulnerability_id)
      end

      it 'preserves reachability data after preloading' do
        described_class.preload_indexing_data(refs)

        expect(vulnerability_ref.database_record.reachability).to eq(
          sbom_occurrence_1.reachability_before_type_cast)
        expect(user_vulnerability_ref.database_record.reachability).to eq(
          sbom_occurrence_2.reachability_before_type_cast)
      end
    end

    context 'for database_record' do
      it 'without preloading returns an instance of model class' do
        expect(vulnerability_ref.database_record).to be_an_instance_of(described_class.model_klass)
      end

      it 'with preloading it returns the proxy record' do
        described_class.preload_indexing_data(refs)

        expect(vulnerability_ref.database_record).to be_an_instance_of(Search::Elastic::RecordProxy::Vulnerability)
      end
    end

    context 'when checking for N+1 queries' do
      it 'does not have N+1 queries when preloading multiple references' do
        # Create initial test data
        project1 = create(:project, group: group)
        project2 = create(:project, namespace: create(:namespace))

        vulnerability1 = create(:vulnerability, :with_read, project: project1, report_type: :container_scanning)
        vulnerability2 = create(:vulnerability, :with_read, project: project2, report_type: :sast)

        # Create CVE identifiers
        identifier1 = create(:vulnerabilities_identifier, external_type: 'cve', external_id: 'CVE-2023-11111',
          name: 'CVE-2023-11111')
        identifier2 = create(:vulnerabilities_identifier, external_type: 'cve', external_id: 'CVE-2023-22222',
          name: 'CVE-2023-22222')

        # Create findings with CVE identifiers
        create(:vulnerabilities_finding, vulnerability: vulnerability1, project: project1, identifiers: [identifier1])
        create(:vulnerabilities_finding, vulnerability: vulnerability2, project: project2, identifiers: [identifier2])

        # Create CVE enrichments with EPSS scores
        create(:pm_cve_enrichment, cve: 'CVE-2023-11111', epss_score: 0.75)
        create(:pm_cve_enrichment, cve: 'CVE-2023-22222', epss_score: 0.85)

        # Create SBOM occurrences for reachability data
        sbom_occurrence1 = create(:sbom_occurrence, reachability: 'in_use')
        sbom_occurrence2 = create(:sbom_occurrence, reachability: 'unknown')

        vulnerability_read1 = vulnerability1.vulnerability_read
        vulnerability_read2 = vulnerability2.vulnerability_read

        # Create SBOM occurrences vulnerabilities for reachability
        create(:sbom_occurrences_vulnerability,
          occurrence: sbom_occurrence1,
          vulnerability_id: vulnerability_read1.vulnerability_id)
        create(:sbom_occurrences_vulnerability,
          occurrence: sbom_occurrence2,
          vulnerability_id: vulnerability_read2.vulnerability_id)

        # Create refs array for initial batch
        refs = [
          described_class.new(vulnerability_read1.vulnerability_id, vulnerability_read1.es_parent)
        ]

        # Establish baseline query count
        control = ActiveRecord::QueryRecorder.new(skip_cached: false) do
          described_class.preload_indexing_data(refs)
        end

        # Create additional test data for second batch
        project3 = create(:project, group: group)

        vulnerability3 = create(:vulnerability, :with_read, project: project3, report_type: :container_scanning)

        identifier3 = create(:vulnerabilities_identifier, external_type: 'cve', external_id: 'CVE-2023-33333',
          name: 'CVE-2023-33333')

        # Create finding with CVE identifier
        create(:vulnerabilities_finding, vulnerability: vulnerability3, project: project3, identifiers: [identifier3])

        # Create CVE enrichment with EPSS score for the third vulnerability
        create(:pm_cve_enrichment, cve: 'CVE-2023-33333', epss_score: 0.65)

        # Create SBOM occurrence for reachability data for the third vulnerability
        sbom_occurrence3 = create(:sbom_occurrence, reachability: 'not_found')

        vulnerability_read3 = vulnerability3.vulnerability_read

        create(:sbom_occurrences_vulnerability,
          occurrence: sbom_occurrence3,
          vulnerability_id: vulnerability_read3.vulnerability_id)

        # Add new refs to the array
        refs += [
          described_class.new(vulnerability_read2.vulnerability_id, vulnerability_read2.es_parent),
          described_class.new(vulnerability_read3.vulnerability_id, vulnerability_read3.es_parent)
        ]

        expect { described_class.preload_indexing_data(refs) }.not_to exceed_all_query_limit(control)

        expect { refs.each(&:as_indexed_json) }.not_to exceed_all_query_limit(0)
      end
    end
  end

  describe '#fetch_record_attribute' do
    let(:vulnerability_ref) { described_class.new(vulnerability_read.vulnerability_id, vulnerability_read.es_parent) }

    subject(:fetch_record_attribute) do
      vulnerability_ref.send(:fetch_record_attribute, record, attribute)
    end

    context 'when record responds to the attribute' do
      let(:record) { vulnerability_read }
      let(:attribute) { :epss_scores }
      let(:expected_result) { [0.5, 0.8] }

      before do
        allow(record).to receive(attribute).and_return(expected_result)
        allow(record).to receive(:respond_to?).with(attribute).and_return(true)
      end

      it 'returns the attribute value' do
        expect(fetch_record_attribute).to eq(expected_result)
      end
    end

    context 'when record does not respond to the attribute' do
      let(:record) { vulnerability_read }
      let(:attribute) { :non_existent_attribute }

      before do
        allow(record).to receive(:respond_to?).with(attribute).and_return(false)
      end

      it 'returns an empty array' do
        expect(fetch_record_attribute).to eq([])
      end
    end
  end

  describe '#instantiate' do
    let(:vulnerability_ref) { described_class.new(vulnerability_read.vulnerability_id, vulnerability_read.es_parent) }

    it 'instantiates vulnerability' do
      new_vulnerability = described_class.instantiate(vulnerability_ref.serialize)
      expect(new_vulnerability.routing).to eq(vulnerability_read.es_parent)
      expect(new_vulnerability.identifier).to eq(vulnerability_read.vulnerability_id)
    end
  end

  describe '#serialize' do
    it 'returns serialized string of vulnerability record from class method' do
      expect(described_class.serialize(vulnerability_read)).to eq(
        "Vulnerability|#{vulnerability_read.vulnerability_id}|#{vulnerability_read.es_parent}")
    end

    it 'returns serialized string of vulnerability record from instance method' do
      expect(described_class.new(vulnerability_read.vulnerability_id,
        vulnerability_read.es_parent).serialize).to eq(
          "Vulnerability|#{vulnerability_read.vulnerability_id}|#{vulnerability_read.es_parent}")
    end
  end

  describe '#index_name' do
    it 'returns correct environment based index name from class method' do
      expect(described_class.index).to eq('gitlab-test-vulnerabilities')
    end

    it 'returns correct environment based index name from instance method' do
      expect(described_class.new(vulnerability_read.vulnerability_id,
        vulnerability_read.es_parent).index_name).to eq('gitlab-test-vulnerabilities')
    end
  end
end
