# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::Elastic::Preloaders::Vulnerability::EnhancedProxy, feature_category: :vulnerability_management do
  let_it_be(:project) { create(:project) }
  let_it_be(:vulnerabilities) do
    create_list(:vulnerability, 3, :with_read, project: project)
  end

  let_it_be(:vulnerability_reads) { vulnerabilities.map(&:vulnerability_read) }

  let(:refs) do
    vulnerability_reads.map do |vuln_read|
      Search::Elastic::References::Vulnerability.new(
        vuln_read.vulnerability_id, vuln_read.es_parent)
    end
  end

  let(:mock_reachability_preloader) { instance_double(Search::Elastic::Preloaders::Vulnerability::Reachability) }
  let(:reachability_data) do
    {
      vulnerability_reads[0].vulnerability_id => ::Enums::Sbom::REACHABILITY_TYPES[::Enums::Sbom::IN_USE],
      vulnerability_reads[1].vulnerability_id => ::Enums::Sbom::REACHABILITY_TYPES[::Enums::Sbom::NOT_FOUND]
    }
  end

  let(:enhanced_proxy) { described_class.new(refs, vulnerability_reads) }

  before do
    allow(Search::Elastic::Preloaders::Vulnerability::Reachability)
      .to receive(:new)
      .with(vulnerability_reads)
      .and_return(mock_reachability_preloader)

    allow(mock_reachability_preloader)
      .to receive(:preload)
      .and_return(reachability_data)
  end

  describe '#initialize' do
    it 'creates index of records by vulnerability_id' do
      records_by_id = enhanced_proxy.instance_variable_get(:@records_by_id)

      expect(records_by_id.keys).to match_array(vulnerability_reads.map(&:vulnerability_id))
      expect(records_by_id[vulnerability_reads[0].vulnerability_id]).to eq(vulnerability_reads[0])
    end

    context 'with single record' do
      let(:single_proxy) { described_class.new(refs, vulnerability_reads.first) }

      it 'normalizes single record to array' do
        records_by_id = single_proxy.instance_variable_get(:@records_by_id)
        expect(records_by_id.keys).to eq([vulnerability_reads.first.vulnerability_id])
      end
    end
  end

  describe '#preload_and_enhance!' do
    it 'preloads reachability data' do
      enhanced_proxy.preload_and_enhance!

      expect(Search::Elastic::Preloaders::Vulnerability::Reachability)
        .to have_received(:new).with(vulnerability_reads)
      expect(mock_reachability_preloader).to have_received(:preload)
    end

    it 'creates enhanced proxies for matching refs' do
      expect(::Search::Elastic::RecordProxy::Vulnerability)
        .to receive(:create_with_enhancements)
        .exactly(3).times
        .and_call_original

      enhanced_proxy.preload_and_enhance!

      refs.each do |ref|
        database_record = ref.database_record
        expect(database_record).to be_an_instance_of(Search::Elastic::RecordProxy::Vulnerability)
      end
    end

    context 'with unmatched ref identifier' do
      let(:unmatched_ref) do
        Search::Elastic::References::Vulnerability.new(
          vulnerability_reads.last.id + 99999,
          vulnerability_reads.last.es_parent)
      end

      let(:mixed_refs) { refs + [unmatched_ref] }
      let(:mixed_proxy) { described_class.new(mixed_refs, vulnerability_reads) }

      it 'skips unmatched refs but processes matched ones' do
        mixed_proxy.preload_and_enhance!

        expect(unmatched_ref.database_record).to be_nil

        refs.each do |ref|
          database_record = ref.database_record
          expect(database_record).to be_an_instance_of(Search::Elastic::RecordProxy::Vulnerability)
        end
      end
    end
  end

  describe 'proxy enhancement' do
    it 'enhances proxies with correct reachability data' do
      expected_enhancements_in_use = {
        'reachability' => ::Enums::Sbom::REACHABILITY_TYPES[::Enums::Sbom::IN_USE]
      }.with_indifferent_access

      expected_enhancements_not_found = {
        'reachability' => ::Enums::Sbom::REACHABILITY_TYPES[::Enums::Sbom::NOT_FOUND]
      }.with_indifferent_access

      expected_enhancements_unknown = {
        'reachability' => ::Enums::Sbom::REACHABILITY_TYPES[::Enums::Sbom::UNKNOWN]
      }.with_indifferent_access

      expect(::Search::Elastic::RecordProxy::Vulnerability)
        .to receive(:create_with_enhancements)
        .with(vulnerability_reads[0], expected_enhancements_in_use)
        .and_call_original

      expect(::Search::Elastic::RecordProxy::Vulnerability)
        .to receive(:create_with_enhancements)
        .with(vulnerability_reads[1], expected_enhancements_not_found)
        .and_call_original

      expect(::Search::Elastic::RecordProxy::Vulnerability)
        .to receive(:create_with_enhancements)
        .with(vulnerability_reads[2], expected_enhancements_unknown)
        .and_call_original

      enhanced_proxy.preload_and_enhance!
    end

    it 'creates working proxies that delegate to original records' do
      enhanced_proxy.preload_and_enhance!

      assigned_proxy = refs[0].database_record
      expect(assigned_proxy.vulnerability_id).to eq(vulnerability_reads[0].vulnerability_id)
      expect(assigned_proxy.project_id).to eq(vulnerability_reads[0].project_id)
      expect(assigned_proxy.reachability).to eq(reachability_data[vulnerability_reads[0].vulnerability_id])
    end
  end

  describe 'error handling' do
    context 'when reachability preloader fails' do
      before do
        allow(mock_reachability_preloader)
          .to receive(:preload)
          .and_raise(StandardError, 'Preloader failed')
      end

      it 'propagates the error' do
        expect { enhanced_proxy.preload_and_enhance! }
          .to raise_error(StandardError, 'Preloader failed')
      end
    end
  end

  describe '#fetch_reachability_value' do
    it 'returns preloaded value when available' do
      enhanced_proxy.instance_variable_set(:@reachability_data, { 123 => 'in_use' })

      result = enhanced_proxy.send(:fetch_reachability_value, 123)
      expect(result).to eq('in_use')
    end

    it 'returns UNKNOWN for missing data' do
      enhanced_proxy.instance_variable_set(:@reachability_data, {})

      result = enhanced_proxy.send(:fetch_reachability_value, 123)
      expect(result).to eq(::Enums::Sbom::REACHABILITY_TYPES[::Enums::Sbom::UNKNOWN])
    end
  end
end
