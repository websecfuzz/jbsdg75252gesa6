# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::Elastic::Preloaders::Vulnerability::Reachability, feature_category: :vulnerability_management do
  # Test data setup
  let_it_be(:project1) { create(:project) }
  let_it_be(:project2) { create(:project) }

  let_it_be(:vulnerabilities) do
    {
      vuln1: create(:vulnerability, :with_read, project: project1),
      vuln2: create(:vulnerability, :with_read, project: project1),
      vuln3: create(:vulnerability, :with_read, project: project2),
      vuln4: create(:vulnerability, :with_read, project: project2)
    }
  end

  let_it_be(:vulnerability_reads) do
    vulnerabilities.transform_values(&:vulnerability_read)
  end

  # SBOM occurrences with different reachability statuses
  let_it_be(:sbom_occurrences) do
    {
      in_use: create(:sbom_occurrence, project: project1, reachability: ::Enums::Sbom::IN_USE),
      not_found: create(:sbom_occurrence, project: project1, reachability: ::Enums::Sbom::NOT_FOUND),
      unknown: create(:sbom_occurrence, project: project2, reachability: ::Enums::Sbom::UNKNOWN)
    }
  end

  # Associations between vulnerabilities and SBOM occurrences
  let_it_be(:occurrence_associations) do
    [
      create(:sbom_occurrences_vulnerability,
        occurrence: sbom_occurrences[:in_use],
        vulnerability_id: vulnerabilities[:vuln1].id),
      create(:sbom_occurrences_vulnerability,
        occurrence: sbom_occurrences[:not_found],
        vulnerability_id: vulnerabilities[:vuln2].id),
      create(:sbom_occurrences_vulnerability,
        occurrence: sbom_occurrences[:unknown],
        vulnerability_id: vulnerabilities[:vuln3].id)
    ]
  end

  describe '#preload' do
    subject(:preloader) { described_class.new(records) }

    context 'with vulnerability records having different reachability statuses' do
      let(:records) { vulnerability_reads.values }

      it 'returns reachability data for all vulnerabilities' do
        result = preloader.preload

        expect(result).to be_a(Hash)
        expect(result.keys).to match_array(vulnerabilities.values.map(&:id))
      end

      it 'correctly maps each reachability status' do
        result = preloader.preload

        expect(result[vulnerabilities[:vuln1].id]).to eq(reachability_type_for(:in_use))
        expect(result[vulnerabilities[:vuln2].id]).to eq(reachability_type_for(:not_found))
        expect(result[vulnerabilities[:vuln3].id]).to eq(reachability_type_for(:unknown))
        expect(result[vulnerabilities[:vuln4].id]).to eq(reachability_type_for(:unknown)) # no association
      end
    end

    context 'with vulnerability having multiple SBOM occurrences' do
      let_it_be(:multi_occurrence_vulnerability) { create(:vulnerability, :with_read, project: project1) }
      let_it_be(:conflicting_occurrences) { create_conflicting_occurrences_for(multi_occurrence_vulnerability) }

      let(:records) { [multi_occurrence_vulnerability.vulnerability_read] }

      it 'prioritizes IN_USE over NOT_FOUND when both exist' do
        result = preloader.preload

        expect(result[multi_occurrence_vulnerability.id]).to eq(reachability_type_for(:in_use))
      end
    end

    context 'with edge cases' do
      context 'when records are empty' do
        let(:records) { [] }

        it 'returns empty hash' do
          expect(preloader.preload).to eq({})
        end
      end

      context 'when database query fails' do
        let(:records) { [vulnerability_reads[:vuln1]] }

        before do
          allow(::Sbom::Occurrence).to receive(:filter_by_vulnerability_id)
            .and_raise(StandardError, 'Database error')
          allow(::Gitlab::ErrorTracking).to receive(:track_exception)
        end

        it 'handles errors gracefully and tracks exceptions' do
          result = preloader.preload

          expect(result).to eq({})
          expect(::Gitlab::ErrorTracking).to have_received(:track_exception)
            .with(instance_of(StandardError), class: described_class.name)
        end
      end
    end
  end

  describe '#data_for' do
    subject(:preloader) { described_class.new([vulnerability_reads[:vuln1], vulnerability_reads[:vuln2]]) }

    it 'returns preloaded reachability data for specific vulnerability' do
      data = preloader.data_for(vulnerability_reads[:vuln1])

      expect(data).to eq(reachability_type_for(:in_use))
    end

    it 'returns nil for vulnerability not in preloaded records' do
      data = preloader.data_for(vulnerability_reads[:vuln3])

      expect(data).to be_nil
    end
  end

  describe 'base class integration' do
    subject(:preloader) { described_class.new([vulnerability_reads[:vuln1], vulnerability_reads[:vuln2]]) }

    it 'tracks preloaded state correctly' do
      expect(preloader.preloaded?).to be false

      preloader.preload

      expect(preloader.preloaded?).to be true
    end

    it 'caches preloaded data to avoid duplicate queries' do
      expect(::Sbom::Occurrence).to receive(:filter_by_vulnerability_id).once.and_call_original

      result1 = preloader.preload
      result2 = preloader.preload

      expect(result1).to eq(result2)
    end

    it 'handles single record input' do
      single_preloader = described_class.new(vulnerability_reads[:vuln1])
      result = single_preloader.preload

      expect(result).to have_key(vulnerabilities[:vuln1].id)
      expect(result[vulnerabilities[:vuln1].id]).to eq(reachability_type_for(:in_use))
    end

    it 'deduplicates records correctly' do
      duplicate_records = [vulnerability_reads[:vuln1], vulnerability_reads[:vuln1], vulnerability_reads[:vuln2]]
      duplicate_preloader = described_class.new(duplicate_records)
      result = duplicate_preloader.preload

      expect(result.keys).to match_array([vulnerabilities[:vuln1].id, vulnerabilities[:vuln2].id])
    end
  end

  describe 'reachability priority logic' do
    describe 'reachability priority logic' do
      context 'when vulnerability has conflicting reachability statuses' do
        shared_examples 'prioritizes reachability status' do |higher_priority,
          lower_priority, expected_status|
          subject(:preloader) { described_class.new([vulnerability.vulnerability_read]) }

          before do
            create_occurrence_with_reachability(vulnerability, higher_priority)
            create_occurrence_with_reachability(vulnerability, lower_priority)
          end

          it "prioritizes #{expected_status} status" do
            result = preloader.preload

            expect(result[vulnerability.id]).to eq(reachability_type_for(expected_status))
          end
        end

        it_behaves_like 'prioritizes reachability status', :in_use, :not_found, :in_use do
          let(:vulnerability) { create(:vulnerability, :with_read, project: project1) }
        end

        it_behaves_like 'prioritizes reachability status', :not_found, :unknown, :not_found do
          let(:vulnerability) { create(:vulnerability, :with_read, project: project1) }
        end
      end

      context 'when vulnerability has only UNKNOWN occurrences' do
        let_it_be(:vulnerability) { create(:vulnerability, :with_read, project: project1) }

        subject(:preloader) { described_class.new([vulnerability.vulnerability_read]) }

        before do
          create_occurrence_with_reachability(vulnerability, :unknown)
        end

        it 'returns UNKNOWN status' do
          result = preloader.preload

          expect(result[vulnerability.id]).to eq(reachability_type_for(:unknown))
        end
      end
    end
  end

  describe 'performance characteristics' do
    let_it_be(:large_vulnerability_set) do
      create_list(:vulnerability, 5, :with_read, project: project1).map(&:vulnerability_read)
    end

    it 'performs efficient batch querying' do
      preloader = described_class.new(large_vulnerability_set)

      expect { preloader.preload }.not_to exceed_query_limit(3)
    end

    it 'avoids N+1 queries with larger datasets' do
      # Setup some vulnerabilities with SBOM occurrences
      large_vulnerability_set.first(3).each do |vuln_read|
        create_occurrence_with_reachability_for_vuln_read(vuln_read, :in_use)
      end

      preloader = described_class.new(large_vulnerability_set)
      control_count = count_queries { preloader.preload }

      # Adding more records should not significantly increase query count
      larger_set = large_vulnerability_set + [vulnerability_reads[:vuln1], vulnerability_reads[:vuln2]]
      larger_preloader = described_class.new(larger_set)

      expect { larger_preloader.preload }.not_to exceed_query_limit(control_count + 1)
    end
  end

  private

  # Helper methods for cleaner test code
  def reachability_type_for(status)
    ::Enums::Sbom::REACHABILITY_TYPES[status]
  end

  def create_occurrence_with_reachability(vulnerability, reachability_status)
    occurrence = create(:sbom_occurrence,
      project: vulnerability.project,
      reachability: ::Enums::Sbom.const_get(reachability_status.to_s.upcase, false))

    create(:sbom_occurrences_vulnerability,
      occurrence: occurrence,
      vulnerability_id: vulnerability.id)
  end

  def create_occurrence_with_reachability_for_vuln_read(vulnerability_read, reachability_status)
    occurrence = create(:sbom_occurrence,
      project: project1,
      reachability: ::Enums::Sbom.const_get(reachability_status.to_s.upcase, false))

    create(:sbom_occurrences_vulnerability,
      occurrence: occurrence,
      vulnerability_id: vulnerability_read.vulnerability_id)
  end

  def create_conflicting_occurrences_for(vulnerability)
    in_use_occurrence = create(:sbom_occurrence, project: vulnerability.project, reachability: ::Enums::Sbom::IN_USE)
    not_found_occurrence = create(:sbom_occurrence, project: vulnerability.project,
      reachability: ::Enums::Sbom::NOT_FOUND)

    [
      create(:sbom_occurrences_vulnerability, occurrence: in_use_occurrence, vulnerability_id: vulnerability.id),
      create(:sbom_occurrences_vulnerability, occurrence: not_found_occurrence, vulnerability_id: vulnerability.id)
    ]
  end

  def count_queries(&block)
    ActiveRecord::QueryRecorder.new(&block).count
  end
end
