# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::BackgroundMigration::BackfillHasVulnerabilityResolution, feature_category: :vulnerability_management do
  before(:all) do
    # This migration will not work if a sec database is configured. It should be finalized and removed prior to
    # sec db rollout.
    # Consult https://gitlab.com/gitlab-org/gitlab/-/merge_requests/171707 for more info.
    skip_if_multiple_databases_are_setup(:sec)
  end

  let(:organizations) { table(:organizations) }
  let(:namespaces) { table(:namespaces) }
  let(:projects) { table(:projects) }
  let(:scanners) { table(:vulnerability_scanners) }
  let!(:user) { table(:users).create!(email: 'author@example.com', username: 'author', projects_limit: 10) }

  let(:identifiers) { table(:vulnerability_identifiers) }
  let(:vulnerabilities) { table(:vulnerabilities) }
  let(:vulnerability_findings) { table(:vulnerability_occurrences) }
  let(:vulnerability_occurrence_identifiers) { table(:vulnerability_occurrence_identifiers) }
  let(:vulnerability_reads) { table(:vulnerability_reads) }

  let(:organization) { organizations.create!(name: 'organization', path: 'organization') }
  let(:namespace) do
    namespaces.create!(name: 'gitlab-org', path: 'gitlab-org', type: 'Group', organization_id: organization.id)
  end

  let!(:project) { create_project('gitlab', namespace) }

  let(:total_reads_count) { vulnerability_reads.all.count }
  let(:args) do
    {
      start_id: vulnerability_reads.minimum(:id),
      end_id: vulnerability_reads.maximum(:id),
      batch_table: :vulnerability_reads,
      batch_column: :id,
      sub_batch_size: total_reads_count,
      pause_ms: 0,
      connection: ApplicationRecord.connection
    }
  end

  let(:test_identifiers) do
    {
      not_supported_cwe: { external_id: "cwe-2018-1234", external_type: "cwe", name: "CWE-NOPE" },
      not_supported_CWE: { external_id: "CWE-2019-1234", external_type: "CWE", name: "CWE-NOPE" },
      not_supported_cve: { external_id: "cve-2020-1234", external_type: "cve", name: "CWE-NOPE2" },
      supported_cwe: { external_id: "cwe-2021-1234", external_type: "cwe", name: "CWE-73" },
      supported_CWE: { external_id: "CWE-2022-1234", external_type: "CWE", name: "CWE-23" },
      supported_CVE: { external_id: "cve-2023-1234", external_type: "CVE", name: "CWE-80" }
    }.transform_values do |attrs|
      identifiers.create!(
        project_id: project.id,
        fingerprint: SecureRandom.hex(20),
        **attrs
      )
    end
  end

  let!(:findings_supported_by_duo) do
    [
      create_finding(identifiers: test_identifiers.values_at(:not_supported_cve, :supported_cwe)),
      create_finding(identifiers: test_identifiers.values_at(:not_supported_cve, :supported_CWE))
    ].map(&:uuid).then { |uuids| vulnerability_reads.where(uuid: uuids) }
  end

  let!(:findings_not_supported_by_duo) do
    [
      create_finding(sast: false, identifiers: test_identifiers.values_at(:not_supported_cve, :supported_cwe)),
      create_finding(sast: false, identifiers: test_identifiers.values_at(:not_supported_cve, :supported_CWE)),
      create_finding(identifiers: test_identifiers.values_at(:not_supported_cwe)),
      create_finding(identifiers: test_identifiers.values_at(:not_supported_CWE))
    ].map(&:uuid).then { |uuids| vulnerability_reads.where(uuid: uuids) }
  end

  context 'when there are null values for vulnerability_reads.has_vulnerability_resolution' do
    subject(:perform_migration) { described_class.new(**args).perform }

    let(:backfill_col_for) { ->(findings) { findings.pluck(:has_vulnerability_resolution).uniq } }

    it 'updates the nil columns with a boolean' do
      expect { perform_migration }.to change { backfill_col_for.call(findings_supported_by_duo) }.from([nil]).to([true])
        .and change { backfill_col_for.call(findings_not_supported_by_duo) }.from([nil]).to([false])
    end

    context 'with non-nil rows' do
      let!(:findings_not_supported_by_duo) { super().tap { |read| read.update!(has_vulnerability_resolution: true) } }
      let!(:findings_supported_by_duo) { super().tap { |read| read.update!(has_vulnerability_resolution: false) } }

      it 'does not affect non-nil rows' do
        # To easily test this expectation, I am taking the findings_not_supported_by_duo and findings_supported_by_duo
        # and setting their has_vulnerability_resolution columns to the wrong values (i.e. setting false when the
        # backfill logic would set it to true, and vice versa). I then make sure the backfill ignores non-nil rows by
        # making sure the values do not change
        expect { perform_migration }.not_to change { backfill_col_for.call(findings_supported_by_duo) }.from([false])
        expect { perform_migration }.not_to change { backfill_col_for.call(findings_not_supported_by_duo) }.from([true])
      end
    end
  end

  private

  def create_finding(identifiers:, sast: true)
    # scanner is required, but we do not care about it for the migration
    scanner = scanners.find_or_create_by!(name: 'bar') do |scanner|
      scanner.project_id = project.id
      scanner.external_id = 'foo'
    end

    finding = vulnerability_findings.create!(
      project_id: project.id,
      scanner_id: scanner.id,
      severity: 5, # medium
      report_type: (sast ? 0 : 99),
      primary_identifier_id: identifiers.first.id,
      project_fingerprint: SecureRandom.hex(20),
      location_fingerprint: SecureRandom.hex(20),
      uuid: SecureRandom.uuid,
      name: identifiers.first.name,
      raw_metadata: "{}",
      metadata_version: "test:1.0"
    )

    vuln = vulnerabilities.create!(
      finding_id: finding.id,
      project_id: project.id,
      author_id: user.id,
      title: "Vulnerability for finding #{finding.id}",
      severity: finding.severity,
      report_type: (sast ? 0 : 99),
      state: 1
    )

    # After the vulnerability is associated with the finding, a
    # vulnerability_read will automatically be created due to a database
    # trigger. The default value is false, so we reset it to nil
    finding.update!(vulnerability_id: vuln.id)
    vulnerability_reads.find_or_create_by!(uuid: finding.uuid).update!(
      has_vulnerability_resolution: nil
    )

    identifiers.each do |identifier|
      vulnerability_occurrence_identifiers.create!(
        project_id: finding.project_id,
        identifier_id: identifier.id,
        occurrence_id: finding.id
      )
    end

    finding
  end

  def create_project(name, namespace)
    project_namespace = namespaces.create!(
      organization_id: namespace.organization_id,
      name: name,
      path: name,
      type: 'Project'
    )

    projects.create!(
      namespace_id: namespace.id,
      project_namespace_id: project_namespace.id,
      organization_id: namespace.organization_id,
      name: name,
      path: name,
      archived: false
    )
  end
end
