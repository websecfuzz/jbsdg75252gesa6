# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::BackgroundMigration::BackfillHasVulnerabilityResolutionCwe78Cwe89, feature_category: :vulnerability_management do
  let(:organizations) { table(:organizations) }
  let(:namespaces) { table(:namespaces) }
  let(:projects) { table(:projects) }
  let!(:user) do
    table(:users).create!(email: 'author@example.com', username: 'author', projects_limit: 10,
      organization_id: organization.id)
  end

  let(:scanners) { table(:vulnerability_scanners, database: :sec) }
  let(:identifiers) { table(:vulnerability_identifiers, database: :sec) }
  let(:vulnerabilities) { table(:vulnerabilities, database: :sec) }
  let(:vulnerability_findings) { table(:vulnerability_occurrences, database: :sec) }
  let(:vulnerability_occurrence_identifiers) { table(:vulnerability_occurrence_identifiers, database: :sec) }
  let(:vulnerability_reads) { table(:vulnerability_reads, database: :sec) }

  let(:organization) { organizations.create!(name: 'organization', path: 'organization') }
  let(:namespace) do
    namespaces.create!(name: 'gitlab-org', path: 'gitlab-org', type: 'Group', organization_id: organization.id)
  end

  let!(:project) { create_project('gitlab', namespace) }

  let(:total_reads_count) { vulnerability_reads.all.count }
  let(:args) do
    {
      start_id: vulnerability_reads.minimum(:id),
      end_id: vulnerability_reads.maximum(:id),
      batch_table: :vulnerability_reads,
      batch_column: :id,
      sub_batch_size: total_reads_count,
      pause_ms: 0,
      connection: ::SecApplicationRecord.connection
    }
  end

  let(:test_identifiers) do
    {
      not_supported_cwe: { external_id: "cwe-2018-1234", external_type: "cwe", name: "CWE-NOPE" },
      not_supported_CWE: { external_id: "CWE-2019-1234", external_type: "CWE", name: "CWE-NOPE" },
      not_supported_cve: { external_id: "cve-2020-1234", external_type: "cve", name: "CWE-NOPE2" },
      cwe_78: { external_id: "CWE-78", external_type: "cwe", name: "CWE-78" },
      cwe_89: { external_id: "CWE-89", external_type: "cwe", name: "CWE-89" },
      cwe_119: { external_id: "CWE-119", external_type: "cwe", name: "CWE-119" }
    }.transform_values do |attrs|
      identifiers.create!(
        project_id: project.id,
        fingerprint: SecureRandom.hex(20),
        **attrs
      )
    end
  end

  let!(:findings_supported_by_duo) do
    [
      create_finding(has_vulnerability_resolution: true, identifiers: [test_identifiers[:cwe_78]]),
      create_finding(has_vulnerability_resolution: false, identifiers: [test_identifiers[:cwe_89]]),
      create_finding(has_vulnerability_resolution: true, identifiers: [test_identifiers[:cwe_119]])
    ].map(&:uuid).then { |uuids| vulnerability_reads.where(uuid: uuids) }
  end

  let!(:findings_not_supported_by_duo) do
    [
      create_finding(has_vulnerability_resolution: false, identifiers: [test_identifiers[:not_supported_cwe]]),
      create_finding(has_vulnerability_resolution: true, identifiers: [test_identifiers[:not_supported_CWE]]),
      create_finding(has_vulnerability_resolution: nil, identifiers: [test_identifiers[:not_supported_cve]])
    ].map(&:uuid).then { |uuids| vulnerability_reads.where(uuid: uuids) }
  end

  context 'when has_vulnerability_resolution is nil or incorrect' do
    subject(:perform_migration) { described_class.new(**args).perform }

    it 'preserves supported findings that already have correct value (true)' do
      expect do
        perform_migration
      end.not_to change {
        findings_supported_by_duo.first.reload.has_vulnerability_resolution
      }.from(true)
    end

    it 'updates supported findings with incorrect value (false â†’ true)' do
      expect do
        perform_migration
      end.to change {
        findings_supported_by_duo.second.reload.has_vulnerability_resolution
      }.from(false).to(true)
    end

    it 'preserves unsupported findings that already have correct value (false and true)' do
      expect do
        perform_migration
      end.not_to change {
        [
          findings_not_supported_by_duo.first.reload.has_vulnerability_resolution,
          findings_not_supported_by_duo.second.reload.has_vulnerability_resolution
        ]
      }.from([false, true])
    end

    it 'fills nil values with correct resolution (true for supported)' do
      nil_supported = create_finding(identifiers: [test_identifiers[:cwe_78]])
      read = vulnerability_reads.find_by(uuid: nil_supported.uuid)
      read.update!(has_vulnerability_resolution: nil)

      expect do
        perform_migration
      end.to change {
        read.reload.has_vulnerability_resolution
      }.from(nil).to(true)
    end

    it 'preserves pre-existing supported findings that already have correct value (true)' do
      expect do
        perform_migration
      end.not_to change {
        findings_supported_by_duo.third.reload.has_vulnerability_resolution
      }.from(true)
    end
  end

  private

  def create_finding(identifiers:, sast: true, has_vulnerability_resolution: nil)
    scanner = scanners.find_or_create_by!(name: 'bar') do |scanner|
      scanner.project_id = project.id
      scanner.external_id = 'foo'
    end

    finding = vulnerability_findings.create!(
      project_id: project.id,
      scanner_id: scanner.id,
      severity: 5,
      report_type: (sast ? 0 : 99),
      primary_identifier_id: identifiers.first.id,
      location_fingerprint: SecureRandom.hex(20),
      uuid: SecureRandom.uuid,
      name: identifiers.first.name,
      raw_metadata: "{}",
      metadata_version: "test:1.0"
    )

    vuln = vulnerabilities.create!(
      finding_id: finding.id,
      project_id: project.id,
      author_id: user.id,
      title: "Vulnerability for finding #{finding.id}",
      severity: finding.severity,
      report_type: (sast ? 0 : 99),
      state: 1
    )

    finding.update!(vulnerability_id: vuln.id)
    vulnerability_reads
      .find_or_create_by!(uuid: finding.uuid).update!(has_vulnerability_resolution: has_vulnerability_resolution)

    identifiers.each do |identifier|
      vulnerability_occurrence_identifiers.create!(
        project_id: finding.project_id,
        identifier_id: identifier.id,
        occurrence_id: finding.id
      )
    end

    finding
  end

  def create_project(name, namespace)
    project_namespace = namespaces.create!(
      organization_id: namespace.organization_id,
      name: name,
      path: name,
      type: 'Project'
    )

    projects.create!(
      namespace_id: namespace.id,
      project_namespace_id: project_namespace.id,
      organization_id: namespace.organization_id,
      name: name,
      path: name,
      archived: false
    )
  end
end
