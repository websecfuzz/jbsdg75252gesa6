# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::BackgroundMigration::FixCorruptedScannerIdsOfVulnerabilityReads, feature_category: :vulnerability_management do
  before(:all) do
    # This migration will not work if a sec database is configured. It should be finalized and removed prior to
    # sec db rollout.
    # Consult https://gitlab.com/gitlab-org/gitlab/-/merge_requests/171707 for more info.
    skip_if_multiple_databases_are_setup(:sec)
  end

  subject(:perform_migration) { described_class.new(**migration_attrs).perform }

  let(:migration_attrs) do
    {
      start_id: vulnerability_reads.first.id,
      end_id: vulnerability_reads.last.id,
      batch_table: :vulnerability_reads,
      batch_column: :id,
      sub_batch_size: 1,
      pause_ms: 0,
      connection: ApplicationRecord.connection
    }
  end

  # Not really used in this spec, just needed as required dependencies
  # needed for creating vulnerabilities.
  let(:users) { table(:users) }
  let(:user) { create_user(email: "test1@example.com", username: "test1") }
  let(:organizations) { table(:organizations) }
  let(:organization) { organizations.create!(name: 'organization', path: 'organization') }

  let(:namespaces) { table(:namespaces) }
  let(:namespace) do
    namespaces.create!(name: 'test-1', path: 'test-1', owner_id: user.id, organization_id: organization.id)
  end

  let(:projects) { table(:projects) }
  let(:project) do
    projects.create!(namespace_id: namespace.id, project_namespace_id: namespace.id, organization_id: organization.id)
  end

  let(:vulnerability_identifiers) { table(:vulnerability_identifiers) }

  # Here are the models we are concerned with for this spec
  let(:vulnerability_scanners) { table(:vulnerability_scanners) }
  let(:misc_scanner) { create_scanner(project, external_id: 'scanner to be replaced by migration') }
  let(:vulnerability_findings) { table(:vulnerability_occurrences) }
  let(:vulnerabilities) { table(:vulnerabilities) }
  let(:vulnerability_reads) { table(:vulnerability_reads) }

  let(:corrupted_vulnerability1) { create_full_vulnerability(project) }
  let(:corrupted_vulnerability2) { create_full_vulnerability(project) }
  let(:non_corrupted_vulnerability) { create_full_vulnerability(project) }

  let(:vulnerability_read1) { vulnerability_reads.find_by(vulnerability_id: corrupted_vulnerability1.id) }
  let(:vulnerability_read2) { vulnerability_reads.find_by(vulnerability_id: corrupted_vulnerability2.id) }
  let(:vulnerability_read3) { vulnerability_reads.find_by(vulnerability_id: non_corrupted_vulnerability.id) }
  let(:finding1) { vulnerability_findings.find_by(id: corrupted_vulnerability1.finding_id) }
  let(:finding2) { vulnerability_findings.find_by(id: corrupted_vulnerability2.finding_id) }
  let(:finding3) { vulnerability_findings.find_by(id: non_corrupted_vulnerability.finding_id) }

  before do
    # simulate corrupted data
    # I create 3 vulnerabilities. 2 will have mis-matched scanners, 1 will be fine.
    # I then assert that the mismatches have been corrected
    vulnerability_read1.update!(scanner_id: misc_scanner.id)
    vulnerability_read2.update!(scanner_id: misc_scanner.id)
    non_corrupted_vulnerability
  end

  it 'corrects the scanner_id for the corrupted vulnerability_reads', :aggregate_failures do
    expect { perform_migration }.to change { vulnerability_reads.where(scanner_id: misc_scanner).count }.from(2).to(0)

    expect(vulnerability_read1.reload.scanner_id).to eq(finding1.scanner_id)
    expect(vulnerability_read2.reload.scanner_id).to eq(finding2.scanner_id)
    expect(vulnerability_read3.reload.scanner_id).to eq(finding3.scanner_id)
  end

  context 'when there are records that fall outside of the migration bounds' do
    # The goal here is to make sure my UPDATE sql statement is bounded
    # by the sub_batches
    let(:migration_attrs) { super().merge(start_id: vulnerability_read1.id, end_id: vulnerability_read1.id) }

    it 'does not update those records', :aggregate_failures do
      expect { perform_migration }.not_to change { vulnerability_read2.reload.scanner_id }.from(misc_scanner.id)
    end
  end

  private

  def create_full_vulnerability(project, finding_overrides: {}, vulnerability_overrides: {}, read_overrides: {})
    finding = create_finding(project, finding_overrides)
    vulnerability = create_vulnerability(vulnerability_overrides.merge(finding_id: finding.id))
    create_vulnerability_read(vulnerability, finding, read_overrides)

    finding.update!(vulnerability_id: vulnerability.id)

    vulnerability
  end

  def create_finding(project, overrides = {})
    attrs = {
      project_id: project.id,
      scanner_id: create_scanner(project).id,
      severity: 5, # medium
      report_type: 99, # generic
      primary_identifier_id: create_identifier(project).id,
      project_fingerprint: SecureRandom.hex(20),
      location_fingerprint: SecureRandom.hex(20),
      uuid: SecureRandom.uuid,
      name: "CVE-2018-1234",
      raw_metadata: "{}",
      metadata_version: "test:1.0"
    }.merge(overrides)

    vulnerability_findings.create!(attrs)
  end

  def create_vulnerability(overrides = {})
    attrs = {
      project_id: project.id,
      author_id: user.id,
      title: 'test',
      severity: 1,
      confidence: 1,
      report_type: 1,
      state: 1,
      detected_at: Time.zone.now
    }.merge(overrides)

    vulnerabilities.create!(attrs)
  end

  def create_vulnerability_read(vulnerability, finding, overrides = {})
    attrs = {
      project_id: vulnerability.project_id,
      vulnerability_id: vulnerability.id,
      scanner_id: finding.scanner_id,
      severity: vulnerability.severity,
      report_type: vulnerability.report_type,
      state: vulnerability.state,
      uuid: finding.uuid
    }.merge(overrides)

    vulnerability_reads.create!(attrs)
  end

  def create_scanner(project, overrides = {})
    random_scanner_uuid = SecureRandom.uuid

    attrs = {
      project_id: project.id,
      external_id: "test_vulnerability_scanner-#{random_scanner_uuid})",
      name: "Test Vulnerabilities::Scanner #{random_scanner_uuid}"
    }.merge(overrides)

    vulnerability_scanners.create!(attrs)
  end

  def create_identifier(project, overrides = {})
    attrs = {
      project_id: project.id,
      external_id: "CVE-2018-1234",
      external_type: "CVE",
      name: "CVE-2018-1234",
      fingerprint: SecureRandom.hex(20)
    }.merge(overrides)

    vulnerability_identifiers.create!(attrs)
  end

  def create_user(overrides = {})
    attrs = {
      email: "test@example.com",
      notification_email: "test@example.com",
      name: "test",
      username: "test",
      state: "active",
      projects_limit: 10
    }.merge(overrides)

    users.create!(attrs)
  end
end
