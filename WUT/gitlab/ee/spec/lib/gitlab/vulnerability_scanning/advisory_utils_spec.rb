# frozen_string_literal: true

require "spec_helper"

RSpec.describe Gitlab::VulnerabilityScanning::AdvisoryUtils, feature_category: :software_composition_analysis do
  let(:advisory_utils_test_class) do
    Class.new do
      include Gitlab::VulnerabilityScanning::AdvisoryUtils
    end
  end

  let(:affected_package) do
    build(:pm_affected_package)
  end

  let(:advisory) { affected_package.advisory }
  let_it_be(:user) { create(:user) }
  let_it_be(:pipeline) { create(:ci_pipeline, user: user) }
  let_it_be(:occurrence) { create(:sbom_occurrence, pipeline: pipeline) }

  describe '.occurrence_is_affected?' do
    let(:source) { occurrence.source }
    let(:version) { "5.2" }

    subject(:occurrence_is_affected) do
      advisory_utils_test_class.new.occurrence_is_affected?(purl_type: affected_package.purl_type,
        range: affected_package.affected_range, version: version, distro: affected_package.distro_version,
        source: source, project_id: occurrence.project_id, xid: advisory.advisory_xid, source_xid: advisory.source_xid)
    end

    context 'when the occurrence is not affected' do
      let(:version) { "1.0" }

      it { is_expected.to be false }
    end

    context 'with container scanning' do
      let(:affected_package) { build(:pm_affected_package, :os_advisory, affected_range: "<5:5.2") }
      let(:source) do
        create(:sbom_source, source_type: :container_scanning, packager_name: 'apk',
          source: {
            'category' => 'development',
            'image' => { 'name' => 'image-1', 'tag' => 'v1' },
            'operating_system' => { 'name' => 'debian', 'version' => '9' }
          })
      end

      it { is_expected.to be true }

      context 'when affected package version is not supported' do
        # APK package versions containing leading zeros eg 1.2.03 are currently unsupported. https://gitlab.com/gitlab-org/gitlab/-/issues/471509
        let(:affected_package) { build(:pm_affected_package, purl_type: "apk", distro_version: 'alpine 3.14') }
        let(:version) { "5.03" }

        let(:source) do
          create(:sbom_source, source_type: :container_scanning, packager_name: 'apk',
            source: {
              'category' => 'development',
              'image' => { 'name' => 'image-1', 'tag' => 'v1' },
              'operating_system' => { 'name' => 'alpine', 'version' => '3.14' }
            })
        end

        it "captures, tracks, and re-raise the unsupported version error" do
          expect(Gitlab::ErrorTracking).to receive(:track_exception)
                  .with(an_instance_of(SemverDialects::UnsupportedVersionError),
                    message: 'Cannot determine if component is affected',
                    purl_type: 'apk',
                    version: version,
                    project_id: occurrence.project_id,
                    advisory_xid: advisory.advisory_xid,
                    source_xid: advisory.source_xid).once

          expect { occurrence_is_affected }.to raise_error(SemverDialects::UnsupportedVersionError)
        end

        context 'when feature flag track_semver_dialect_errors_for_cvs_in_sentry is disabled' do
          before do
            stub_feature_flags(track_semver_dialect_errors_for_cvs_in_sentry: false)
          end

          it "does not track the unsupported error" do
            expect(Gitlab::ErrorTracking).not_to receive(:track_exception)

            expect { occurrence_is_affected }.to raise_error(SemverDialects::UnsupportedVersionError)
          end
        end
      end

      context 'when advisory affecte_range is invalid' do
        # 3.0.0alpha is NOT a valid version and simulates an incorect advisory range
        let(:affected_package) { build(:pm_affected_package, affected_range: ">=3.0.0alpha <= 3.8.2 || <= 2.15.0") }
        let(:version) { "3.8.2" }

        it "captures, tracks, and re-raise the invalid constraint error" do
          expect(Gitlab::ErrorTracking).to receive(:track_exception)
                  .with(an_instance_of(SemverDialects::InvalidConstraintError),
                    message: 'Cannot determine if component is affected',
                    purl_type: 'npm',
                    version: version,
                    project_id: occurrence.project_id,
                    advisory_xid: advisory.advisory_xid,
                    source_xid: advisory.source_xid).once

          expect { occurrence_is_affected }.to raise_error(SemverDialects::InvalidConstraintError)
        end

        context 'when feature flag track_semver_dialect_errors_for_cvs_in_sentry is disabled' do
          before do
            stub_feature_flags(track_semver_dialect_errors_for_cvs_in_sentry: false)
          end

          it "does not tracks the invalid constraint error" do
            expect(Gitlab::ErrorTracking).not_to receive(:track_exception)

            expect { occurrence_is_affected }.to raise_error(SemverDialects::InvalidConstraintError)
          end
        end
      end
    end

    context 'with dependency scanning' do
      it { is_expected.to be true }
    end

    context 'when version is invalid' do
      let(:affected_package) { build(:pm_affected_package, purl_type: "pypi") }
      let(:version) { " 5.0" }

      it "captures, tracks, and re-raise the unsupported version error" do
        expect(Gitlab::ErrorTracking).to receive(:track_exception)
          .with(
            an_instance_of(SemverDialects::InvalidVersionError),
            message: 'Cannot determine if component is affected',
            purl_type: affected_package.purl_type,
            version: version,
            project_id: occurrence.project_id,
            advisory_xid: advisory.advisory_xid,
            source_xid: advisory.source_xid
          )
          .once

        expect { occurrence_is_affected }.to raise_error(SemverDialects::InvalidVersionError)
      end
    end
  end

  describe '.create_vulnerabilities' do
    subject(:create_vulnerabilities) do
      advisory_utils_test_class.new.create_vulnerabilities([finding_map])
    end

    let(:finding_map) { create(:vs_finding_map, pipeline: pipeline) }

    it 'creates new vulnerabilities and returns their id' do
      expect(Gitlab::AppJsonLogger).to receive(:debug)
        .with(
          message: "Successfully created vulnerabilities on advisory ingestion",
          project_ids_with_upsert: [pipeline.project.id])
        .once

      expect do
        created_ids = create_vulnerabilities
        expect(created_ids).to be_an(Array)
          .and all(be_a(Integer))
          .and be_present
      end.to change { Vulnerability.count }.by(1)
    end

    context 'when exception is raised' do
      before do
        allow(::Security::Ingestion::IngestCvsSliceService).to receive(:execute).and_raise(StandardError)
      end

      it 'does not create vulnerabilities' do
        expect(Gitlab::AppJsonLogger).to receive(:error)
         .with(
           message: "Failed to create vulnerabilities on advisory ingestion",
           error: an_instance_of(StandardError),
           project_ids_with_upsert: [])
         .once

        expect do
          created_ids = create_vulnerabilities
          expect(created_ids).to eq([])
        end.not_to change { Vulnerability.count }
      end
    end
  end
end
