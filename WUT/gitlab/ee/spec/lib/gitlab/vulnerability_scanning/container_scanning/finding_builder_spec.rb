# frozen_string_literal: true

require "spec_helper"

RSpec.describe Gitlab::VulnerabilityScanning::ContainerScanning::FindingBuilder, feature_category: :software_composition_analysis do
  let(:now) { Time.zone.now }
  let(:ci_build) { build(:ci_build, pipeline: build(:ci_pipeline, user: build(:user))) }
  let(:sbom_source) { build(:ci_reports_sbom_source) }
  let(:security_scanner) { Gitlab::VulnerabilityScanning::SecurityScanner.fabricate }

  let(:affected_component) do
    build(:vs_possibly_affected_component, name: 'Bind 9',
      version: '9.0.1')
  end

  let(:advisory) do
    build(:vs_advisory,
      title: "bind: assertion failure in buffer.c while building responses to a specifically constructed request",
      description: "buffer.c in named in ISC BIND 9 before 9.9.9-P3, 9.10.x before 9.10.4-P3, and 9.11.x",
      cvss_v2: "AV:N/AC:L/Au:N/C:N/I:N/A:C",
      cvss_v3: "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      urls: %w[http://rhn.redhat.com/errata/RHSA-2016-1944.html http://rhn.redhat.com/errata/RHSA-2016-1945.html http://rhn.redhat.com/errata/RHSA-2016-2099.html],
      identifiers: [
        build(:pm_identifier, type: "cve", name: "CVE-2018-1000538",
          url: "https://nvd.nist.gov/vuln/detail/CVE-2018-1000538", value: "CVE-2018-1000538")
      ],
      solution: 'Update Bind Daemon'
    )
  end

  subject(:builder) do
    described_class.new(project: ci_build.project, pipeline: ci_build.pipeline, sbom_source: sbom_source,
      scanner: security_scanner, advisory: advisory, affected_component: affected_component)
  end

  describe "#finding" do
    let(:finding) { builder.finding }

    let(:sbom_source) do
      build(:ci_reports_sbom_source, :container_scanning, image_name: 'rhel', image_tag: '7.1',
        operating_system_name: 'Red Hat Enterprise Linux', operating_system_version: '7')
    end

    context "when cyclonedx sbom contains required gitlab:container_scanning properties" do
      it "does not add any errors to the report" do
        expect { builder.finding }.not_to raise_error
      end

      it "creates the links" do
        expect(finding.links).to match_array([
          have_attributes(url: "http://rhn.redhat.com/errata/RHSA-2016-1944.html"),
          have_attributes(url: "http://rhn.redhat.com/errata/RHSA-2016-1945.html"),
          have_attributes(url: "http://rhn.redhat.com/errata/RHSA-2016-2099.html")
        ])
      end

      it "creates the name" do
        expect(finding.name).to eq(advisory.title)
      end

      it "creates the description" do
        expect(finding.description).to eq(advisory.description)
      end

      it "creates the solution" do
        expect(finding.solution).to eq("Update Bind Daemon")
      end

      it "creates a valid location" do
        expect(finding.location).to have_attributes(
          image: 'rhel:7.1',
          operating_system: 'Red Hat Enterprise Linux 7',
          package_name: 'Bind 9',
          package_version: '9.0.1')
      end

      it "creates the severity" do
        expect(finding.severity).to eq("high")
      end

      it "creates the confidence" do
        expect(finding.confidence).to eq("unknown")
      end

      it "creates the metadata version" do
        expect(finding.metadata_version).to eq("0.0.0")
      end

      it "creates the details" do
        expect(finding.details).to include({
          vulnerable_package: {
            name: "Vulnerable Package",
            type: "text",
            value: "Bind 9:9.0.1"
          }
        })
      end

      context 'with original_data data', :use_clean_rails_redis_caching do
        shared_examples 'original_data structure' do |with_container_repository_url|
          it 'returns the correct data structure' do
            expected_data = {
              message: advisory.title,
              description: advisory.description,
              solution: advisory.solution,
              location: {
                image: "#{sbom_source.image_name}:#{sbom_source.image_tag}",
                operating_system: "#{sbom_source.operating_system_name} #{sbom_source.operating_system_version}",
                dependency: {
                  package: { name: affected_component.name },
                  version: affected_component.version
                }
              }
            }

            if with_container_repository_url
              expected_data[:location][:container_repository_url] = container_repository_url
            end

            expect(finding.original_data).to eq(expected_data.with_indifferent_access.freeze)
          end
        end

        before do
          allow(Rails.cache).to receive(:fetch).and_call_original if fetch_cache

          allow(Rails.application.routes.url_helpers).to receive(:project_container_registry_url)
            .and_return(container_repository_url)
        end

        let(:full_path) { "#{Gitlab.config.registry.host_port}/project1/amazonlinux" }
        let(:image_name) { 'project1/amazonlinux' }
        let(:sbom_source) { build(:ci_reports_sbom_source, :container_scanning, image_name: full_path) }
        let(:container_repository_url) { 'http://localhost/namespace24/project-24/container_registry/3' }
        let(:fetch_cache) { false }

        context 'when project does not have any container repository' do
          it_behaves_like 'original_data structure', false
        end

        context 'when project has a container repository' do
          before do
            create(:container_repository, name: image_name, project: ci_build.project)
          end

          context 'when project has a container repository with the given image name' do
            let(:fetch_cache) { true }

            it_behaves_like 'original_data structure', true

            it 'fetches the container_repository_url from the cache or repository' do
              expect(Rails.cache).to receive(:fetch).with(
                ["container_repository_url", ci_build.project.id, full_path],
                expires_in: described_class::EXPIRATION_TIME
              )

              finding
            end
          end

          context 'when project does not have a container repository with the given image name' do
            let(:image_name) { 'project1/ubuntu' }

            it_behaves_like 'original_data structure', false
          end

          context 'when full path is an external repository' do
            let(:full_path) { 'example1.com/project1/amazonlinux2' }

            it_behaves_like 'original_data structure', false
          end

          context 'with an invalid full path' do
            let(:full_path) { "#{Gitlab.config.registry.host_port}/project1/amazonlinux:invalid" }

            it_behaves_like 'original_data structure', false
          end

          context 'when host is not configured' do
            before do
              allow(Gitlab.config.registry).to receive(:host_port).and_return(nil)
            end

            it_behaves_like 'original_data structure', false
          end
        end
      end
    end

    context "when cyclonedx does not contain required gitlab:container_scanning properties" do
      using RSpec::Parameterized::TableSyntax

      where(:image_name, :image_tag) do
        'rhel' | nil
        nil    | '7.1'
        nil    | nil
      end

      with_them do
        let(:sbom_source) do
          build(:ci_reports_sbom_source, :container_scanning, image_name: image_name, image_tag: image_tag)
        end

        it "adds an error to the generated report" do
          expect do
            builder.finding
          end.to raise_error(Gitlab::VulnerabilityScanning::FindingBuilder::MissingPropertiesError,
            "Missing required gitlab:container_scanning CycloneDX properties")
        end
      end
    end

    context "when title is not present" do
      let(:advisory) { build(:vs_advisory, title: nil) }

      it "replaces with default title" do
        expected_name = "#{affected_component.name} in #{sbom_source.operating_system_name} " \
          "#{sbom_source.operating_system_version} is vulnerable to #{advisory.identifiers.first['name']}"
        expect(finding.name).to eq(expected_name)
      end
    end

    context "when title is empty" do
      let(:advisory) { build(:vs_advisory, title: "") }

      it "replaces with default title" do
        expected_name = "#{affected_component.name} in #{sbom_source.operating_system_name} " \
          "#{sbom_source.operating_system_version} is vulnerable to #{advisory.identifiers.first['name']}"
        expect(finding.name).to eq(expected_name)
      end
    end
  end
end
