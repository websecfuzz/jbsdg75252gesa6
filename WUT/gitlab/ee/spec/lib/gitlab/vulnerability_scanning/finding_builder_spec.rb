# frozen_string_literal: true

require "spec_helper"

RSpec.describe Gitlab::VulnerabilityScanning::FindingBuilder, feature_category: :software_composition_analysis do
  let(:sbom_source) { build(:ci_reports_sbom_source) }
  let(:scanner) { Gitlab::VulnerabilityScanning::SecurityScanner.fabricate }
  let(:location) { build(:ci_reports_security_locations_sast) }
  let(:cvss_v3) { "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H" }
  let(:cvss_v2) { "AV:N/AC:L/Au:N/C:N/I:N/A:P" }
  let(:identifiers) do
    [
      build(:pm_identifier, type: "cve", name: "CVE-2018-1000538",
        url: "https://nvd.nist.gov/vuln/detail/CVE-2018-1000538", value: "CVE-2018-1000538")
    ]
  end

  let(:advisory) do
    build(:vs_advisory,
      title: "Allocation of File Descriptors or Handles Without Limits or Throttling",
      description: "Minio a Allocation of Memory Without Limits or Throttling vulnerability in write-to-RAM.",
      cvss_v3: cvss_v3,
      cvss_v2: cvss_v2,
      urls: ["https://nvd.nist.gov/vuln/detail/CVE-2018-1000538", "https://github.com/minio/minio/pull/5957"],
      identifiers: identifiers,
      solution: "Unfortunately, there is no solution available yet."
    )
  end

  let(:affected_component) { build(:vs_possibly_affected_component) }

  let(:user) { build(:user) }
  let(:pipeline) { build(:ci_pipeline, user: user) }

  subject(:builder) do
    described_class.new(pipeline: pipeline, project: pipeline&.project,
      sbom_source: sbom_source, scanner: scanner, advisory: advisory, affected_component: affected_component)
  end

  describe "#finding" do
    context "when abstract methods have not been implemented" do
      context "when report_type has not been implemented" do
        before do
          allow(builder).to receive(:location_fingerprint).and_return("01234567890abcdef")
          allow(builder).to receive(:location).and_return(location)
          allow(builder).to receive(:original_data).and_return({})
        end

        it { expect { builder.finding }.to raise_error(NoMethodError, /#report_type is not implemented/) }
      end

      context "when location has not been implemented" do
        before do
          allow(builder).to receive(:report_type).and_return("dependency_scanning")
        end

        it { expect { builder.finding }.to raise_error(NoMethodError, /#location is not implemented/) }
      end

      context "when original_data has not been implemented" do
        before do
          allow(builder).to receive(:report_type).and_return("dependency_scanning")
          allow(builder).to receive(:location).and_return(location)
        end

        it { expect { builder.finding }.to raise_error(NoMethodError, /#original_data is not implemented/) }
      end
    end

    shared_examples 'emits warning for uuid' do
      it 'emits a warning for the missing UUID component' do
        expect(Gitlab::AppJsonLogger).to receive(:warn).with(message: "One or more UUID name components are nil",
          components: Hash)

        builder.finding
      end
    end

    context "when creating uuid" do
      before do
        allow(Gitlab::AppJsonLogger).to receive(:warn).and_call_original
        allow(builder).to receive(:report_type).and_return("dependency_scanning")
        allow(builder).to receive(:location_fingerprint).and_return("01234567890abcdef")
        allow(builder).to receive(:location).and_return(location)
        allow(builder).to receive(:original_data).and_return({})
      end

      context "when primary_identifier is nil" do
        before do
          allow(builder).to receive(:primary_identifier).and_return(nil)
        end

        it_behaves_like 'emits warning for uuid'
      end

      context "when location_fingerprint is nil" do
        before do
          allow(builder).to receive(:location_fingerprint).and_return(nil)
        end

        it_behaves_like 'emits warning for uuid'
      end

      context "when all uuid components are present" do
        it 'does not emit a warning for the missing UUID component' do
          expect(Gitlab::AppJsonLogger).not_to receive(:warn)

          builder.finding
        end
      end
    end

    context "when creating finding name" do
      before do
        allow(builder).to receive(:report_type).and_return("dependency_scanning")
        allow(builder).to receive(:original_data).and_return({})
      end

      context "when location fingerprint path exists" do
        before do
          allow(builder).to receive(:location).and_return(location)
        end

        it { expect(builder.finding.name).to eq("CVE-2018-1000538 in App.java") }
      end

      context "when location fingerprint path does not exist" do
        before do
          allow(builder).to receive(:location).and_return(nil)
        end

        it { expect(builder.finding.name).to eq("CVE-2018-1000538") }
      end
    end

    context 'when all arguments are valid' do
      before do
        allow(builder).to receive(:report_type).and_return("dependency_scanning")
        allow(builder).to receive(:location_fingerprint).and_return("01234567890abcdef")
        allow(builder).to receive(:location).and_return(location)
        allow(builder).to receive(:original_data).and_return({})
      end

      it 'populates finding cvss data' do
        expect(builder.finding.cvss).to eq([
          {
            'vendor' => 'NVD',
            'vector' => cvss_v3
          },
          {
            'vendor' => 'NVD',
            'vector' => cvss_v2
          }
        ])
      end

      context 'when vectors are missing' do
        let(:cvss_v3) { nil }
        let(:cvss_v2) { nil }

        it 'does not include a JSON object for missing vectors' do
          expect(builder.finding.cvss).to eq([])
        end
      end

      context 'when identifiers are unknown' do
        let(:identifiers) { [build(:pm_identifier, type: "???")] }

        it 'reports vendor as Unknown' do
          expect(builder.finding.cvss).to eq([
            {
              'vendor' => 'Unknown',
              'vector' => cvss_v3
            },
            {
              'vendor' => 'Unknown',
              'vector' => cvss_v2
            }
          ])
        end
      end
    end

    context 'when invalid arguments' do
      before do
        allow(builder).to receive(:report_type).and_return("dependency_scanning")
        allow(builder).to receive(:location).and_return(nil)
        allow(builder).to receive(:original_data).and_return({})
      end

      context 'if no sbom source' do
        let_it_be(:sbom_source) { nil }

        specify do
          expect { builder.finding }
            .to raise_error(
              described_class::ArgumentError,
              Gitlab::VulnerabilityScanning::FindingBuilder::ERROR_SBOM_MISSING_SOURCE_ARG
            )
        end
      end

      context 'if no pipeline' do
        let_it_be(:pipeline) { nil }

        specify do
          expect { builder.finding }
            .to raise_error(
              described_class::ArgumentError,
              Gitlab::VulnerabilityScanning::FindingBuilder::ERROR_SBOM_MISSING_PIPELINE
            )
        end
      end

      context 'if no pipeline author' do
        let(:user) { nil }

        specify do
          expect { builder.finding }
            .to raise_error(
              described_class::ArgumentError,
              Gitlab::VulnerabilityScanning::FindingBuilder::ERROR_PIPELINE_USER_NIL
            )
        end
      end
    end
  end

  describe '.for_report_type' do
    subject(:builder) { described_class.for_report_type(report_type) }

    context 'when given dependency_scanning' do
      let(:report_type) { 'dependency_scanning' }

      it { is_expected.to be(::Gitlab::VulnerabilityScanning::DependencyScanning::FindingBuilder) }
    end

    context 'when given container_scanning' do
      let(:report_type) { 'container_scanning' }

      it { is_expected.to be(::Gitlab::VulnerabilityScanning::ContainerScanning::FindingBuilder) }
    end

    context 'when given container_scanning_for_registry' do
      let(:report_type) { 'container_scanning_for_registry' }

      it { is_expected.to be(::Gitlab::VulnerabilityScanning::ContainerScanning::FindingBuilder) }
    end

    context 'when anything else' do
      let(:report_type) { 'sast' }

      it { is_expected.to be_nil }
    end
  end

  describe '.for_purl_type' do
    shared_examples_for 'it returns the correct builder' do
      specify do
        purl_types.each do |purl_type|
          builder = described_class.for_purl_type(purl_type)
          expect(builder).to be(expected_builder)
        end
      end
    end

    context 'when given a dependency scanning purl_type' do
      let(:purl_types) do
        %w[
          composer
          conan
          gem
          golang
          maven
          npm
          nuget
          pypi
        ]
      end

      let(:expected_builder) { ::Gitlab::VulnerabilityScanning::DependencyScanning::FindingBuilder }

      it_behaves_like 'it returns the correct builder'
    end

    context 'when given a container scanning purl_type' do
      let(:purl_types) do
        %w[
          apk
          rpm
          deb
          cbl-mariner
          wolfi
        ]
      end

      let(:expected_builder) { ::Gitlab::VulnerabilityScanning::ContainerScanning::FindingBuilder }

      it_behaves_like 'it returns the correct builder'
    end

    context 'when given anything else' do
      let(:purl_types) { ['foo', 'bar', nil] }
      let(:expected_builder) { nil }

      it_behaves_like 'it returns the correct builder'
    end
  end
end
