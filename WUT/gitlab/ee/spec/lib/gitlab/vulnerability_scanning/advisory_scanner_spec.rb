# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::VulnerabilityScanning::AdvisoryScanner, feature_category: :software_composition_analysis do
  let_it_be(:user) { create(:user) }
  let_it_be_with_reload(:affected_project) { create(:project) }
  let_it_be(:affected_pipeline) { create(:ci_pipeline, user: user, project: affected_project) }

  let_it_be(:user_2) { create(:user) }
  let_it_be_with_reload(:affected_twice_project) { create(:project) }
  let_it_be(:affected_twice_pipeline) { create(:ci_pipeline, user: user_2, project: affected_twice_project) }

  let_it_be(:invalid_affected_project) { create(:project) }
  # A user is required to attribute vulnerability creation to a user, hence the omission of a user
  # for the pipeline here.
  let_it_be(:invalid_affected_pipeline) { create(:ci_pipeline, project: invalid_affected_project) }

  let_it_be(:unaffected_project) { create(:project) }
  let_it_be(:unaffected_pipeline) { create(:ci_pipeline, user: user, project: unaffected_project) }

  let_it_be(:invalid_version) { create(:sbom_component_version, version: 'invalid-version') }
  let_it_be(:affected_version) { create(:sbom_component_version, version: '0.8.0') }
  let_it_be(:affected_version_2) { create(:sbom_component_version, version: '0.9.0') }
  let_it_be(:unaffected_version) { create(:sbom_component_version, version: '1.0.0') }

  let(:affected_range) { '>=0.8.0 <1.0.0' }

  describe '#execute' do
    before do
      # Assume that Time.current might use a time zone that's not UTC.
      # See https://gitlab.com/gitlab-data/analytics/-/issues/23964#note_2528947112
      allow(Time).to receive(:current).and_return(Time.new(2023, 11, 14, 0, 0, 0, '-04:00'))
      allow(SemverDialects::IntervalSetParser).to receive(:parse).and_call_original
      allow(Gitlab::VulnerabilityScanning::TrackCvsService).to receive(:new).and_call_original
      allow(Gitlab::AppJsonLogger).to receive(:debug).and_call_original
      allow(Gitlab::AppJsonLogger).to receive(:error).and_call_original
      allow(Gitlab::ErrorTracking).to receive(:track_exception).and_call_original

      described_class.scan_projects_for(affected_package.advisory)
    end

    context 'with Dependency Scanning' do
      before_all do
        eslint = create(:sbom_component, name: 'eslint', purl_type: :npm)
        openssl = create(:sbom_component, name: 'openssl', purl_type: :wolfi)
        create(:sbom_occurrence, component: eslint, component_version: affected_version,
          pipeline: affected_pipeline)
        create(:sbom_occurrence, component: eslint, component_version: affected_version,
          pipeline: affected_twice_pipeline)
        create(:sbom_occurrence, component: eslint, component_version: affected_version,
          pipeline: affected_twice_pipeline)
        create(:sbom_occurrence, component: eslint, component_version: affected_version,
          pipeline: invalid_affected_pipeline)
        create(:sbom_occurrence, component: eslint, component_version: unaffected_version,
          pipeline: unaffected_pipeline)
        create(:sbom_occurrence, component: openssl)
        orphan_occurrence = create(:sbom_occurrence, component: eslint, component_version: affected_version,
          pipeline: affected_pipeline)
        orphan_occurrence.update_column(:project_id, 0)
      end

      let(:affected_package) do
        create(:pm_affected_package, package_name: 'eslint', purl_type: :npm, affected_range: affected_range)
      end

      context 'when the advisory matches component versions' do
        it 'creates vulnerabilities in valid affected projects only' do
          advisory = affected_package.advisory
          expect(affected_project.vulnerabilities).to match_array([
            have_attributes(
              author_id: user.id,
              project_id: affected_pipeline.project.id,
              state: 'detected',
              report_type: 'dependency_scanning',
              present_on_default_branch: true,
              title: advisory.title,
              severity: advisory.cvss_v3.severity.downcase,
              finding_description: advisory.description,
              solution: affected_package.solution
            )
          ])

          expect(affected_twice_project.vulnerabilities).to match_array([
            have_attributes(
              author_id: user_2.id,
              project_id: affected_twice_pipeline.project.id,
              state: 'detected',
              report_type: 'dependency_scanning',
              present_on_default_branch: true,
              title: advisory.title,
              severity: advisory.cvss_v3.severity.downcase,
              finding_description: advisory.description,
              solution: affected_package.solution
            ),
            have_attributes(
              author_id: user_2.id,
              project_id: affected_twice_pipeline.project.id,
              state: 'detected',
              report_type: 'dependency_scanning',
              present_on_default_branch: true,
              title: advisory.title,
              severity: advisory.cvss_v3.severity.downcase,
              finding_description: advisory.description,
              solution: affected_package.solution
            )
          ])

          expect(unaffected_project.vulnerabilities).to be_empty
          expect(invalid_affected_project.vulnerabilities).to be_empty
          expect(SemverDialects::IntervalSetParser).to have_received(:parse).once
        end

        it "logs a debug message for the scan" do
          expect(Gitlab::AppJsonLogger).to have_received(:debug).with(
            message: 'Successfully created vulnerabilities on advisory ingestion',
            project_ids_with_upsert: [affected_project.id, affected_twice_project.id])
        end

        it "tracks an event for the scan" do
          expect(Gitlab::VulnerabilityScanning::TrackCvsService).to have_received(:new).with(
            advisory: affected_package.advisory,
            start_time: Time.current.utc.iso8601,
            end_time: Time.current.utc.iso8601,
            counts: {
              possibly_affected_projects: 4,
              possibly_affected_sbom_occurrences: 5,
              known_affected_projects: 3,
              known_affected_sbom_occurrences: 4,
              sbom_occurrences_semver_dialects_errors_count: 0
            }
          )
        end
      end

      context 'when component matches but version is not in the affected range' do
        let(:affected_range) { '<0.1.0' }

        it 'does not attempt to create an empty list of vulnerabilities' do
          expect(affected_project.vulnerabilities).to be_empty
          expect(affected_twice_project.vulnerabilities).to be_empty
          expect(Gitlab::AppJsonLogger).not_to have_received(:error)
        end
      end

      context 'when component version is not supported' do
        before_all do
          eslint = Sbom::Component.find_by(purl_type: 'npm', name: 'eslint')
          create(:sbom_occurrence, component: eslint, component_version: invalid_version,
            pipeline: affected_pipeline)
        end

        it "captures the error and count the failure in internal metrics" do
          expect(Gitlab::VulnerabilityScanning::TrackCvsService).to have_received(:new).with(
            advisory: affected_package.advisory,
            start_time: Time.current.utc.iso8601,
            end_time: Time.current.utc.iso8601,
            counts: {
              possibly_affected_projects: 4,
              possibly_affected_sbom_occurrences: 6,
              known_affected_projects: 3,
              known_affected_sbom_occurrences: 4,
              sbom_occurrences_semver_dialects_errors_count: 1
            }
          )
        end
      end
    end

    context 'with Container Scanning' do
      let_it_be(:affected_version) { create(:sbom_component_version, version: '2:7.4.051-1ubuntu3.1') }
      let(:affected_range) { '<2:7.4.052-1ubuntu3.1' }
      let(:solution) { FFaker::Lorem.paragraph }
      let(:fixed_versions) { %w[5.2.1.1] }
      let(:affected_package) do
        create(:pm_affected_package, :os_advisory, package_name: 'perl', purl_type: :deb,
          affected_range: affected_range, solution: solution, fixed_versions: fixed_versions)
      end

      let_it_be(:affected_version_2) { create(:sbom_component_version, version: '2:7.3.052-1ubuntu3.1') }
      let_it_be(:unaffected_version) { create(:sbom_component_version, version: '2:7.4.052-1ubuntu3.1') }
      let_it_be(:matching_component) { create(:sbom_component, name: 'matching-package', purl_type: 'deb') }

      before_all do
        deb_source_package = create(:sbom_source_package, purl_type: 'deb', name: 'perl')
        deb_comp = create(:sbom_component, name: 'deb_comp', purl_type: :deb)
        create(:sbom_occurrence, :os_occurrence, source_package: deb_source_package, component: deb_comp,
          component_version: affected_version, pipeline: affected_pipeline)
        create(:sbom_occurrence, :os_occurrence, source_package: deb_source_package, component: deb_comp,
          component_version: affected_version, pipeline: affected_twice_pipeline)
        create(:sbom_occurrence, :os_occurrence, source_package: deb_source_package, component: deb_comp,
          component_version: affected_version, pipeline: affected_twice_pipeline)
        create(:sbom_occurrence, :os_occurrence, source_package: deb_source_package, component: deb_comp,
          component_version: affected_version, pipeline: invalid_affected_pipeline)
        create(:sbom_occurrence, :os_occurrence, source_package: deb_source_package, component: deb_comp,
          component_version: unaffected_version, pipeline: unaffected_pipeline)

        wolfi_sbom_source = create(:sbom_source, source_type: :container_scanning, packager_name: 'apk',
          source: {
            'category' => 'development',
            'image' => { 'name' => 'image-1', 'tag' => 'v1' },
            'operating_system' => { 'name' => 'wolfi', 'version' => '' }
          })
        wolfi_source_package = create(:sbom_source_package, purl_type: 'wolfi', name: 'openssl')
        wolfi_component = create(:sbom_component, name: 'wolfi_component', purl_type: :wolfi)
        create(:sbom_occurrence, source_package: wolfi_source_package, component: wolfi_component,
          component_version: affected_version, pipeline: affected_pipeline, source: wolfi_sbom_source)
      end

      context 'when the advisory matches component versions' do
        shared_examples 'vulnerabilty creator' do
          it 'creates vulnerabilities in valid affected projects only' do
            advisory = affected_package.advisory
            expect(affected_project.vulnerabilities).to match_array([
              have_attributes(
                author_id: user.id,
                project_id: affected_pipeline.project.id,
                state: 'detected',
                report_type: 'container_scanning',
                present_on_default_branch: true,
                title: advisory.title,
                severity: advisory.cvss_v3.severity.downcase,
                finding_description: advisory.description,
                solution: expected_solution
              )
            ])

            expect(affected_twice_project.vulnerabilities).to match_array([
              have_attributes(
                author_id: user_2.id,
                project_id: affected_twice_pipeline.project.id,
                state: 'detected',
                report_type: 'container_scanning',
                present_on_default_branch: true,
                title: advisory.title,
                severity: advisory.cvss_v3.severity.downcase,
                finding_description: advisory.description,
                solution: expected_solution
              ),
              have_attributes(
                author_id: user_2.id,
                project_id: affected_twice_pipeline.project.id,
                state: 'detected',
                report_type: 'container_scanning',
                present_on_default_branch: true,
                title: advisory.title,
                severity: advisory.cvss_v3.severity.downcase,
                finding_description: advisory.description,
                solution: expected_solution
              )
            ])

            expect(unaffected_project.vulnerabilities).to be_empty
            expect(invalid_affected_project.vulnerabilities).to be_empty
          end
        end

        context 'when solution is present' do
          let(:expected_solution) { affected_package.solution }

          it_behaves_like 'vulnerabilty creator'
        end

        context 'when solution is not present' do
          let(:solution) { '' }

          context 'when fixed_versions is present' do
            let(:fixed_versions) { %w[5.2.1.1] }
            let(:expected_solution) { "Upgrade to version #{fixed_versions.join(', ')} or above" }

            it_behaves_like 'vulnerabilty creator'
          end

          context 'when fixed_versions is empty' do
            let(:fixed_versions) { '' }
            let(:expected_solution) { 'Unfortunately, there is no solution available yet.' }

            it_behaves_like 'vulnerabilty creator'
          end
        end

        it 'logs a debug message for the scan' do
          expect(Gitlab::AppJsonLogger).to have_received(:debug).with(
            message: 'Successfully created vulnerabilities on advisory ingestion',
            project_ids_with_upsert: [affected_project.id, affected_twice_project.id])
        end

        it 'tracks an event for the scan' do
          expect(Gitlab::VulnerabilityScanning::TrackCvsService).to have_received(:new).with(
            advisory: affected_package.advisory,
            start_time: Time.current.iso8601,
            end_time: Time.current.iso8601,
            counts: {
              possibly_affected_projects: 4,
              possibly_affected_sbom_occurrences: 5,
              known_affected_projects: 3,
              known_affected_sbom_occurrences: 4,
              sbom_occurrences_semver_dialects_errors_count: 0
            }
          )
        end
      end

      context 'when component matches but version is not in the affected range' do
        let(:affected_range) { '<1:7.4.052-1ubuntu3.1' }

        it 'does not attempt to create an empty list of vulnerabilities' do
          expect(affected_project.vulnerabilities).to be_empty
          expect(affected_twice_project.vulnerabilities).to be_empty
          expect(Gitlab::AppJsonLogger).not_to have_received(:error)
        end
      end

      context 'when affected package purl type is supported, but component version is not in the affected range' do
        let(:affected_range) { '<1.2.3' }
        let(:advisory) { create(:pm_advisory, source_xid: 'trivy-db') }

        shared_examples 'tracks event and expects no vulnerabilities' do |purl_type, package_name, distro_version|
          before_all do
            distro_name, distro_version_string = distro_version.split(' ', 2)
            affected_version = create(:sbom_component_version, version: '1.2.4')
            sbom_source = create(:sbom_source, source_type: :container_scanning, packager_name: purl_type,
              source: {
                'category' => 'development',
                'image' => { 'name' => 'image-1', 'tag' => 'v1' },
                'operating_system' => { 'name' => distro_name,
                                        'version' => distro_version_string }
              })
            source_package = create(:sbom_source_package, purl_type: purl_type, name: package_name)
            component = create(:sbom_component, name: "#{distro_name}_component", purl_type: purl_type.to_sym)
            create(:sbom_occurrence, source_package: source_package, component: component,
              component_version: affected_version, pipeline: affected_pipeline, source: sbom_source)
          end

          let(:affected_package) do
            create(:pm_affected_package, package_name: package_name, distro_version: distro_version,
              purl_type: purl_type, advisory: advisory, affected_range: affected_range)
          end

          it 'tracks an event with correct count' do
            expect(Gitlab::VulnerabilityScanning::TrackCvsService).to have_received(:new).with(
              advisory: affected_package.advisory,
              start_time: Time.current.iso8601,
              end_time: Time.current.iso8601,
              counts: {
                possibly_affected_projects: 1,
                possibly_affected_sbom_occurrences: 1,
                known_affected_projects: 0,
                known_affected_sbom_occurrences: 0,
                sbom_occurrences_semver_dialects_errors_count: 0
              }
            )
          end

          it 'expects no vulnerabilities to be created' do
            expect(affected_project.vulnerabilities.count).to eq(0)
          end
        end

        context 'when purl type is rpm' do
          it_behaves_like 'tracks event and expects no vulnerabilities', 'rpm', 'curl', 'Oracle Linux 8'
        end

        context 'when purl type is apk' do
          it_behaves_like 'tracks event and expects no vulnerabilities', 'apk', 'libssh', 'alpine 3.14'
        end
      end

      context 'when affected package purl type is not supported' do
        let(:advisory) { create(:pm_advisory, source_xid: 'trivy-db') }
        let(:affected_package) do
          create(:pm_affected_package, package_name: 'openssl', distro_version: 'wolfi',
            purl_type: 'wolfi', advisory: advisory)
        end

        it 'tracks an event with no affected projects or occurences' do
          expect(Gitlab::VulnerabilityScanning::TrackCvsService).to have_received(:new).with(
            advisory: affected_package.advisory,
            start_time: Time.current.iso8601,
            end_time: Time.current.iso8601,
            counts: {
              possibly_affected_projects: 0,
              possibly_affected_sbom_occurrences: 0,
              known_affected_projects: 0,
              known_affected_sbom_occurrences: 0,
              sbom_occurrences_semver_dialects_errors_count: 0
            }
          )
        end

        it 'expects no vulnerabilities to be created' do
          expect(affected_project.vulnerabilities.count).to eq(0)
        end
      end

      context 'when affected package version is not supported' do
        before_all do
          affected_version = create(:sbom_component_version, version: '1.2.03')
          sbom_source = create(:sbom_source, source_type: :container_scanning, packager_name: 'apk',
            source: {
              'category' => 'development',
              'image' => { 'name' => 'image-1', 'tag' => 'v1' },
              'operating_system' => { 'name' => 'alpine',
                                      'version' => '3.14' }
            })
          source_package = create(:sbom_source_package, purl_type: 'apk', name: 'zlib')
          component = create(:sbom_component, name: "alpine_component", purl_type: :apk)
          create(:sbom_occurrence, source_package: source_package, component: component,
            component_version: affected_version, pipeline: affected_pipeline, source: sbom_source)
        end

        let(:advisory) { create(:pm_advisory, source_xid: 'trivy-db') }
        let(:affected_package) do
          create(:pm_affected_package, package_name: 'zlib', distro_version: 'alpine 3.14',
            purl_type: 'apk', advisory: advisory, affected_range: '<1.2.4')
        end

        it "captures the error and count the failure in internal metrics" do
          expect(Gitlab::VulnerabilityScanning::TrackCvsService).to have_received(:new).with(
            advisory: affected_package.advisory,
            start_time: Time.current.iso8601,
            end_time: Time.current.iso8601,
            counts: {
              possibly_affected_projects: 1,
              possibly_affected_sbom_occurrences: 1,
              known_affected_projects: 0,
              known_affected_sbom_occurrences: 0,
              sbom_occurrences_semver_dialects_errors_count: 1
            }
          )
        end
      end
    end
  end
end
