# frozen_string_literal: true

require 'spec_helper'
require_relative '../../completions/resolve_vulnerability/shared_examples'

RSpec.describe Gitlab::Llm::AiGateway::Completions::ResolveVulnerability, feature_category: :vulnerability_management do
  let_it_be(:user) { create(:user) }
  let_it_be(:user2) { create(:user) }
  let(:prompt_class) { Gitlab::Llm::Templates::Vulnerabilities::ResolveVulnerability }
  let(:merge_request_service) { ::MergeRequests::CreateFromVulnerabilityDataService }
  let(:merge_request) { create(:merge_request, :simple, source_project: project) }
  let(:mr_url) { Gitlab::Routing.url_helpers.project_merge_request_url(project, merge_request) }
  let(:finding_location_file) { 'main.c' }
  let(:changed_code) { "somecode\nexecute" }
  let(:content) { "```\n#{changed_code}\n``` and a ```\nsecond code block\n```" }
  let(:prompt_version) { "1.0.1" }

  let_it_be(:source_code) { "#include <stdio.h>\n\nint main() { printf(\"hello, world!\"); }" }
  let_it_be(:project) do
    create(:project, :custom_repo, files: { 'main.c' => source_code }, developers: [user, user2])
  end

  let(:vulnerability_description) { 'vulnerability description' }
  let(:vulnerability_finding_description) { 'finding description' }
  let(:vulnerability) do
    create(:vulnerability, :with_finding, description: vulnerability_description, project: project)
      .tap { |v| v.finding.update!(description: vulnerability_finding_description) }
  end

  let(:prompt_message) do
    build(:ai_message, :resolve_vulnerability, user: user, resource: vulnerability, request_id: 'uuid')
  end

  let(:options) { {} }

  let(:logger) { instance_double(Gitlab::Llm::Logger) }

  let(:tracking_context) { { request_id: "uuid", action: :resolve_vulnerability } }
  let(:code_patch) { "<old_code>printf(\"hello, world!\");</old_code><new_code>\n#{changed_code}</new_code>" }
  let(:is_false_positive) { "false" }
  let(:model_metadata) { nil }

  let(:description_options) { { analysis_data: "analysis", summary_data: "some summary", vulnerable_mr: nil } }

  subject(:resolve) { described_class.new(prompt_message, prompt_class, options) }

  def allow_llm_client_to_raise_error(error)
    allow_next_instance_of(::Gitlab::Llm::AiGateway::Client) do |client|
      allow(client).to receive(:complete).and_raise(error)
    end
  end

  def allow_llm_client_to_return_message(response)
    identifier_names = vulnerability.finding.identifier_names.join("\n* ")

    request_body = {
      'prompt_version' => prompt_version,
      'inputs' => {
        filename: finding_location_file,
        identifiers: "<report_identifiers>\n * #{identifier_names}\n</report_identifiers>",
        name: vulnerability.title,
        source_code: source_code,
        vulnerability_description: expected_description,
        vulnerable_code: source_code
      }
    }.compact

    expect_next_instance_of(Gitlab::Llm::AiGateway::Client) do |client|
      expect(client).to receive(:complete_prompt)
                    .with(
                      base_url: Gitlab::AiGateway.url,
                      prompt_name: :resolve_vulnerability,
                      inputs: request_body['inputs'],
                      model_metadata: model_metadata,
                      prompt_version: request_body['prompt_version']
                    )
                    .and_return(response)
    end
  end

  describe '#root_namespace' do
    context 'when the project is in a subgroup' do
      let_it_be(:group) { create(:group) }
      let_it_be(:subgroup) { create(:group, parent: group) }
      let_it_be(:project) { create(:project, group: subgroup) }

      it 'returns the root namespace' do
        expect(resolve.root_namespace).to eq(group)
      end
    end

    context 'when the project is in a group at the root level' do
      let_it_be(:group) { create(:group) }
      let_it_be(:project) { create(:project, group: group) }

      it 'returns the root namespace' do
        expect(resolve.root_namespace).to eq(group)
      end
    end

    context 'when the project is in a user namespace' do
      it 'returns the root namespace' do
        expect(resolve.root_namespace).to eq(project.root_namespace)
      end
    end
  end

  describe '#execute' do
    before do
      stub_feature_flags(ai_model_switching: false)
    end

    it_behaves_like 'a resolve vulnerability completion' do
      let(:expected_description) { vulnerability.description }
    end

    context 'when the vulnerability description is nil' do
      it_behaves_like 'a resolve vulnerability completion' do
        let(:vulnerability_description) { nil }
        let(:expected_description) { vulnerability.finding.description }
      end
    end

    context 'when namespace model switching is enabled' do
      let_it_be(:group) { create(:group) }
      let_it_be(:project) do
        create(:project, :custom_repo, files: { 'main.c' => source_code }, developers: [user, user2], group: group)
      end

      let(:feature_setting_name) { 'resolve_vulnerability' }

      before do
        stub_feature_flags(ai_model_switching: true)
      end

      context 'when the model is pinned to a specific model' do
        before do
          create(:ai_namespace_feature_setting,
            namespace: group,
            feature: feature_setting_name
          )
        end

        it_behaves_like 'a resolve vulnerability completion' do
          let(:expected_description) { vulnerability.description }
          let(:model_metadata) do
            {
              feature_setting: feature_setting_name,
              identifier: 'claude_sonnet_3_7',
              provider: 'gitlab'
            }
          end
        end
      end
    end
  end
end
