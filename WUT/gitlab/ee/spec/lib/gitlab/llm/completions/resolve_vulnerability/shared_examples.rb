# frozen_string_literal: true

def expect_published_graphql_message(error)
  expect(GraphqlTriggers).to have_received(:ai_completion_response)
    .with(an_object_having_attributes(
      user: user,
      resource: vulnerability,
      role: ::Gitlab::Llm::AiMessage::ROLE_ASSISTANT,
      request_id: 'uuid',
      errors: Array.wrap(error)
    )
         )
end

def expect_published_graphql_content(content)
  expect(GraphqlTriggers).to have_received(:ai_completion_response)
    .with(an_object_having_attributes(
      content: content,
      user: user,
      resource: vulnerability,
      role: ::Gitlab::Llm::AiMessage::ROLE_ASSISTANT,
      request_id: 'uuid',
      errors: []
    )
         )
end

def expect_logged_warn(error)
  expect(logger).to have_received(:warn).with(message: "LLM completion error",
    error_message: error.to_s,
    klass: described_class.to_s,
    ai_component: 'resolve_vulnerability',
    event_name: 'error_response_received')
end

def expect_logged_error(error)
  expect(logger).to have_received(:error).with(message: "LLM completion error",
    error_message: error.to_s,
    klass: described_class.to_s,
    ai_component: 'abstraction_layer',
    event_name: 'error_response_received')
end

def expect_tracked_error(error)
  expect(Gitlab::ErrorTracking).to have_received(:track_exception).with(error)
end

def expect_tracked_internal_event(event_name, status)
  internal_merge_request_id = status == "error" ? nil : merge_request.id
  expect(Gitlab::InternalEvents).to receive(:track_event).with(event_name,
    project: project,
    user: user,
    namespace: project.namespace,
    category: described_class.to_s,
    additional_properties: {
      property: status,
      label: "resolve_vulnerability",
      vulnerability_id: vulnerability.id,
      internal_merge_request_id: internal_merge_request_id,
      language: "C"
    }
  )
end

RSpec.shared_examples "a resolve vulnerability completion" do
  let(:response_body) do
    <<~CONTENT
      <analysis>
      analysis</analysis>
      <fixed_code>
      #{code_patch}</fixed_code>
      <is_false_positive>
      #{is_false_positive}</is_false_positive>
      <summary>
      some summary</summary>
    CONTENT
  end

  let(:example_response) { instance_double(HTTParty::Response, body: response_body.to_json, success?: true) }

  before do
    stub_licensed_features(security_dashboard: true)

    [:admin_all_resources, :resolve_vulnerability_with_ai].each do |permission|
      allow(user).to receive(:can?).with(permission).and_return(true)
      allow(user2).to receive(:can?).with(permission).and_return(true)
    end

    vulnerability.finding.location['file'] = finding_location_file
    vulnerability.finding.location['start_line'] = 1

    allow(GraphqlTriggers).to receive(:ai_completion_response)
    allow(Gitlab::Llm::Logger).to receive(:build).and_return(logger)
    allow(logger).to receive(:error)
    allow(logger).to receive(:warn)
    allow(Gitlab::ErrorTracking).to receive(:track_exception)
  end

  context 'when the AIGW responds with an empty code block' do
    let(:code_patch) { '' }

    before do
      allow_llm_client_to_return_message(example_response)
    end

    it 'publishes a false positive error to the graphql subscription' do
      resolve.execute

      expect_published_graphql_message(a_string_starting_with('The response from the AI provider was ' \
        'empty because it has determined this vulnerability to be a false positive.'))
    end
  end

  context 'when the AIGW responds does not include a code block' do
    let(:response_body) do
      <<~CONTENT
        <analysis>
        analysis</analysis>
        <is_false_positive>
        #{is_false_positive}</is_false_positive>
        <summary>
        some summary</summary>
      CONTENT
    end

    before do
      allow_llm_client_to_return_message(example_response)
    end

    it 'publishes a false positive error to the graphql subscription' do
      resolve.execute

      expect_published_graphql_message(a_string_starting_with('The response from the AI provider was ' \
        'empty because it has determined this vulnerability to be a false positive.'))
    end
  end

  context 'when the AIGW responds with the is_false_positive tag' do
    let(:is_false_positive) { "true" }

    before do
      allow_llm_client_to_return_message(example_response)
    end

    it 'publishes a false positive error to the graphql subscription' do
      resolve.execute

      expect_published_graphql_message(a_string_starting_with('The response from the AI provider was ' \
        'empty because it has determined this vulnerability to be a false positive.'))
    end
  end

  context 'when there is no file for the finding in the repo' do
    let(:finding_location_file) { 'no_such_file.c' }

    it 'returns an error' do
      resolve.execute

      expect_published_graphql_message('Unable to locate source code for vulnerability')
    end
  end

  context 'when vulnerable code exceeds maximum length' do
    it 'returns an error' do
      stub_const("Gitlab::Llm::Templates::Vulnerabilities::VulnerabilityTemplate::MAX_CHARACTERS", 0)

      resolve.execute

      expect_published_graphql_message('Vulnerable code exceeds maximum length (0)')
    end
  end

  context 'when vulnerability report_type is secret detection' do
    it 'returns an error' do
      allow(vulnerability).to receive(:secret_detection?).and_return(true)

      resolve.execute

      expect_published_graphql_message('Refusing to send possible secrets in AI prompt')
    end
  end

  context 'when the AIGW returns a nil response' do
    let(:example_response) { nil }

    before do
      allow_llm_client_to_return_message(example_response)
    end

    it 'records the error and publishes a message to the graphql subscription' do
      resolve.execute

      expect_logged_warn("Empty response from LLM")
      expect_published_graphql_message(described_class::RESPONSE_FAILURE_ERROR)
    end
  end

  context 'when the response from the AIGW experiences a Net::ReadTimeout' do
    let(:error) { Net::ReadTimeout.new }

    before do
      allow_llm_client_to_raise_error(error)
    end

    it 'records the error and publishes a message to the graphql subscription' do
      resolve.execute

      expect_tracked_error(error)
      expect_logged_error("Net::ReadTimeout")
      expect_published_graphql_message(described_class::CLIENT_TIMEOUT_ERROR)
    end
  end

  context 'when the AIGW returns a Gitlab::AiGateway::ForbiddenError' do
    let(:error) { Gitlab::AiGateway::ForbiddenError.new }

    before do
      allow_llm_client_to_raise_error(error)
    end

    it 'records the error and publishes a message to the graphql subscription' do
      resolve.execute

      expect_tracked_error(error)
      expect_logged_error("Gitlab::AiGateway::ForbiddenError")
      expect_published_graphql_message(described_class::FORBIDDEN_ERROR)
    end
  end

  context 'when an unexpected error is raised reading the response from the AIGW' do
    let(:error) { StandardError.new("Ooops...") }

    before do
      allow_llm_client_to_raise_error(error)
    end

    it 'records the error and publishes a message to the graphql subscription' do
      resolve.execute

      expect_tracked_error(error)
      expect_logged_error(error.to_s)
      expect_published_graphql_message(described_class::DEFAULT_ERROR)
    end
  end

  context 'when the AIGW returns a successful response' do
    let(:mr_service_response) { { merge_request: merge_request, status: :success } }

    before do
      allow_llm_client_to_return_message(example_response)

      allow(merge_request_service).to receive(:new).and_call_original
      allow_next_instance_of(merge_request_service) do |mr_service|
        allow(mr_service).to receive(:execute).and_return(mr_service_response)
      end
    end

    it 'requests that a MR be created with the extracted patch' do
      resolve.execute

      expect(merge_request_service).to have_received(:new).with(
        project,
        vulnerability,
        user,
        llm_patch: code_patch,
        description_options: description_options
      )
    end

    it 'publishes the created merge request for the fix' do
      resolve.execute

      expect_published_graphql_content(mr_url)
    end

    it 'tracks internal event with success' do
      expect_tracked_internal_event("track_mr_creation_from_vr", "success")

      resolve.execute
    end

    context 'when options has vulnerable_merge_request_id' do
      let(:vulnerable_mr) do
        create(
          :merge_request,
          source_branch: 'vulnerable',
          target_branch: project.default_branch,
          source_project: project
        )
      end

      let(:options) { { vulnerable_merge_request_id: mr_global_id } }
      let(:mr_global_id) { Gitlab::GlobalId.as_global_id(vulnerable_mr.id, model_name: MergeRequest) }
      let(:note_service) { instance_double(Vulnerabilities::Remediations::NoteService) }
      let(:note) { create(:note_on_merge_request, project: vulnerable_mr.project, noteable: vulnerable_mr) }

      before do
        allow(Vulnerabilities::Remediations::NoteService).to receive(:new).and_return(note_service)
        allow(note_service).to receive(:execute).and_return(note)
      end

      it 'creates a note on the vulnerable merge request' do
        resolve.execute

        expected_params = [vulnerable_mr, merge_request, vulnerability, user]

        expect(Vulnerabilities::Remediations::NoteService).to have_received(:new).with(*expected_params)
        expect(note_service).to have_received(:execute).exactly(:once)
      end

      it 'tracks internal event with success' do
        expect_tracked_internal_event("track_mr_creation_from_vr_in_mr_request", "success")

        resolve.execute
      end
    end

    context 'when the AIGW responds with a typed code block' do
      let(:content) { "```java\n#{code_patch}\n```" }

      it 'publishes the created merge request for the fix' do
        resolve.execute

        expect_published_graphql_content(mr_url)
      end
    end

    context 'when the CreateFromVulnerabilityDataService service fails to create an MR for the vulnerability' do
      before do
        allow_next_instance_of(merge_request_service) do |service|
          allow(service).to receive(:execute).and_return({ status: :error })
        end
      end

      it 'records the error and publishes a message to the graphql subscription' do
        resolve.execute

        error = StandardError.new(described_class::RESOLUTION_FAILURE_ERROR)
        expect_tracked_error(error)
        expect_logged_error(error)
        expect_published_graphql_message(described_class::RESOLUTION_FAILURE_ERROR)
      end
    end

    context 'when the response from the merge reqeust service is malformed' do
      before do
        allow_next_instance_of(merge_request_service) do |service|
          allow(service).to receive(:execute)
                              .and_return({ status: :error, unreadable_response: true })
        end
      end

      it 'records the error and publishes a message to the graphql subscription' do
        resolve.execute

        error = StandardError.new(described_class::RESPONSE_FAILURE_ERROR)
        expect_tracked_error(error)
        expect_logged_error(error)
        expect_published_graphql_message(described_class::RESPONSE_FAILURE_ERROR)
      end

      it 'tracks internal event with error' do
        expect_tracked_internal_event("track_mr_creation_from_vr", "error")

        resolve.execute
      end

      it 'clears cache' do
        resolve.execute

        expect(Rails.cache.read([user.id, vulnerability.cache_key, 'resolve'].join('/'))).to be_nil
      end
    end
  end
end
