# frozen_string_literal: true

require 'spec_helper'
require_relative './resolve_vulnerability/shared_examples'

RSpec.describe Gitlab::Llm::Completions::ResolveVulnerability, feature_category: :vulnerability_management do
  let_it_be(:user) { create(:user) }
  let_it_be(:user2) { create(:user) }
  let(:prompt_class) { Gitlab::Llm::Templates::Vulnerabilities::ResolveVulnerability }
  let(:merge_request_service) { ::MergeRequests::CreateFromVulnerabilityDataService }
  let(:merge_request) { create(:merge_request, :simple, source_project: project) }
  let(:mr_url) { Gitlab::Routing.url_helpers.project_merge_request_url(project, merge_request) }
  let(:finding_location_file) { 'main.c' }
  let(:changed_code) { "somecode\nexecute" }
  let(:content) { "```\n#{changed_code}\n``` and a ```\nsecond code block\n```" }

  let_it_be(:source_code) { "#include <stdio.h>\n\nint main() { printf(\"hello, world!\"); }" }
  let_it_be(:project) do
    create(:project, :custom_repo, files: { 'main.c' => source_code }, developers: [user, user2])
  end

  let(:vulnerability) { create(:vulnerability, :with_finding, project: project) }

  let(:prompt_message) do
    build(:ai_message, :resolve_vulnerability, user: user, resource: vulnerability, request_id: 'uuid')
  end

  let(:options) { {} }

  let(:logger) { instance_double(Gitlab::Llm::Logger) }

  let(:tracking_context) { { request_id: "uuid", action: :resolve_vulnerability } }
  let(:code_patch) { "<old_code>printf(\"hello, world!\");</old_code><new_code>\n#{changed_code}</new_code>" }
  let(:is_false_positive) { "false" }

  let(:description_options) { { analysis_data: "analysis", summary_data: "some summary", vulnerable_mr: nil } }

  subject(:resolve) { described_class.new(prompt_message, prompt_class, options) }

  def allow_llm_client_to_return_message(message)
    allow_next_instance_of(::Gitlab::Llm::ResolveVulnerability::Client) do |client|
      allow(client).to receive(:messages_complete).and_return(message)
    end
  end

  def allow_llm_client_to_raise_error(error)
    allow_next_instance_of(::Gitlab::Llm::ResolveVulnerability::Client) do |client|
      allow(client).to receive(:messages_complete).and_raise(error)
    end
  end

  describe '#execute', :clean_gitlab_redis_cache do
    it_behaves_like "a resolve vulnerability completion" do
      let(:example_response) do
        {
          "id" => "msg_01JPMpeAAtZdoNLvq8Nqhd3D",
          "type" => "message",
          "role" => "assistant",
          "model" => "claude-3-haiku-20240307",
          "content" => [
            {
              "type" => "text",
              "text" => response_body
            }
          ],
          "stop_reason" => "end_turn",
          "stop_sequence" => nil,
          "usage" => {
            "input_tokens" => 130,
            "output_tokens" => 26
          }
        }
      end

      let(:response_body) do
        <<~CONTENT
          <analysis>
          analysis</analysis>
          <fixed_code>
          #{code_patch}</fixed_code>
          <is_false_positive>
          #{is_false_positive}</is_false_positive>
          <summary>
          some summary</summary>
        CONTENT
      end
    end
  end
end
