# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::Llm::ResponseModifiers::ResolveVulnerability, feature_category: :vulnerability_management do
  let(:ai_response) { nil }

  subject(:response_modifier) { described_class.new(ai_response) }

  shared_examples_for 'empty response error' do
    it 'parses content from the ai response' do
      expect(response_modifier.response_body).to eq('')
    end

    it 'returns empty errors' do
      expect(response_modifier.errors).to match_array("The response from the AI provider was empty.")
    end
  end

  context 'when no ai_response is passed' do
    it_behaves_like 'empty response error'
  end

  context 'when empty hash is passed' do
    let(:ai_response) { {}.to_json }

    it_behaves_like 'empty response error'
  end

  context 'when LLM determines a false positive' do
    let(:ai_response) { { false_positive: true } }

    it 'parses content from the ai response' do
      expect(response_modifier.response_body).to eq('')
    end

    it 'returns empty errors' do
      expect(response_modifier.errors).to match_array(a_string_starting_with('The response from the AI provider was ' \
        'empty because it has determined this vulnerability to be a false positive.'))
    end
  end

  context 'when no merge request url is passed' do
    let(:url) { nil }
    let(:ai_response) { { 'merge_request_url' => url }.to_json }

    it 'parses content from the ai response' do
      expect(response_modifier.response_body).to eq('')
    end

    it 'returns empty errors' do
      expect(response_modifier.errors).to match_array("No resolution merge request url was provided")
    end
  end

  context 'when a merge request url is passed' do
    let(:url) { "http://localhost/namespace1/project-1/-/merge_requests/1" }
    let(:ai_response) { { 'merge_request_url' => url }.to_json }

    it 'parses content from the ai response' do
      expect(response_modifier.response_body).to eq(url)
    end

    it 'returns empty errors' do
      expect(response_modifier.errors).to be_empty
    end
  end
end
