# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::Llm::Chain::Tools::ExplainVulnerability::Executor, feature_category: :duo_chat do
  let_it_be(:user) { build_stubbed(:user) }
  let_it_be(:source_code) do
    <<~SOURCE
    #include <stdio.h>

    int main(int argc, char *argv[])
    {
      char buf[8];
      memcpy(&buf, "123456789");
      printf("hello, world!");
    }
    SOURCE
  end

  let_it_be(:project) do
    create(:project, :custom_repo, files: {
      'src/main.c' => source_code
    })
  end

  let_it_be(:vulnerability_finding) do
    create(:vulnerabilities_finding,
      :sast,
      project: project,
      location: {
        'file' => 'src/main.c',
        'start_line' => 5,
        'end_line' => 6
      },
      identifiers: [build(:vulnerabilities_identifier, name: 'CWE-0000')]
    )
  end

  let(:vulnerable_code) { source_code.lines[4..5].join.chomp }
  let_it_be(:resource) { create(:vulnerability, :sast, findings: [vulnerability_finding], project: project) }

  let(:ai_request_double) { instance_double(Gitlab::Llm::Chain::Requests::AiGateway) }
  let(:prompt_class) { Gitlab::Llm::Chain::Tools::ExplainVulnerability::Prompts::Anthropic }
  let(:command_name) { '/explain_vulnerability' }
  let(:current_file) { { file_name: 'main.c' } }

  let(:context) do
    Gitlab::Llm::Chain::GitlabContext.new(
      current_user: user, container: nil, resource: resource, ai_request: ai_request_double, current_file: current_file
    )
  end

  let(:expected_slash_commands) do
    {
      '/vulnerability_explain' => {
        selected_code_without_input_instruction: 'Explain the current vulnerability.'
      }
    }
  end

  subject(:tool) { described_class.new(context: context, options: {}) }

  describe '#name' do
    it 'returns tool name' do
      expect(described_class::NAME).to eq('ExplainVulnerability')
    end

    it 'returns resource name' do
      expect(described_class::RESOURCE_NAME).to eq('Vulnerability')
    end
  end

  describe '#execute' do
    context 'when context is authorized' do
      before do
        allow(Ability).to receive(:allowed?).with(user, :explain_vulnerability_with_ai, resource).and_return(true)
        allow(tool).to receive(:provider_prompt_class).and_return(prompt_class)
      end

      it 'calls prompt with correct params' do
        expect(prompt_class).to receive(:prompt).with(a_hash_including(
          language_info: 'The code is written in C and stored as main.c',
          title: resource.title,
          identifiers: 'CWE-0000',
          vulnerability_info: a_string_including(vulnerable_code)))

        tool.execute
      end

      it 'builds the expected prompt' do
        prompt = tool.prompt[:prompt]

        expect(prompt.length).to eq(2)

        expected_system_prompt = <<~PROMPT.chomp
          You are a software vulnerability developer.
          You can explain vulnerabilities in code.
          The code is written in C and stored as main.c
        PROMPT

        expected_user_prompt = <<~PROMPT.chomp
          First, carefully review the vulnerability report:

          <vulnerability_report>
          Name: #{resource.title}
          Description: The cipher does not provide data integrity update 1
          </vulnerability_report>

          CWE-0000

          Now, explain the vulnerability "#{resource.title} - (CWE-0000)".
          The file "main.c" has this vulnerable code:

          ```
          #{vulnerable_code}
          ```

          Provide a code example with syntax highlighting on how an attacker can take advantage of the vulnerability.
          Provide a code example with syntax highlighting on how to fix it.
          Provide the response in markdown format with headers.
        PROMPT

        expect(prompt[0][:role]).to eq(:system)
        expect(prompt[0][:content]).to eq(expected_system_prompt)

        expect(prompt[1][:role]).to eq(:user)
        expect(prompt[1][:content]).to eq(expected_user_prompt)
      end

      context 'when the vulnerability contains no source code`' do
        before do
          resource.finding.project = project
          resource.finding.clear_memoization(:source_code)
          resource.finding.clear_memoization(:vulnerable_code)
        end

        context 'when no file is present' do
          before do
            resource.finding.location['file'] = 'src/missing.c'
          end

          it 'calls prompt without vulnerability_info' do
            expect(prompt_class).to receive(:prompt).with(a_hash_including(
              vulnerability_info: ''))

            tool.execute
          end
        end

        context 'when a file is not provided' do
          before do
            resource.finding.location.delete('file')
          end

          it 'calls prompt without vulnerability_info' do
            expect(prompt_class).to receive(:prompt).with(a_hash_including(
              vulnerability_info: ''))

            tool.execute
          end
        end

        context 'when there is more vulnerable code than the maximum allowed' do
          let_it_be(:max_code_length) { Gitlab::Llm::Chain::Concerns::AnthropicPrompt::MAX_CHARACTERS / 10 }
          let_it_be(:project) do
            create(:project, :custom_repo, files: {
              'src/main.c' => 'x' * (max_code_length + 1)
            })
          end

          before do
            resource.finding.location['start_line'] = 1
          end

          it 'calls prompt without vulnerability_info' do
            expect(prompt_class).to receive(:prompt).with(a_hash_including(
              vulnerability_info: ''))

            tool.execute
          end
        end
      end

      context 'when response is successful' do
        before do
          allow(tool).to receive(:request).and_return('successful response')
        end

        context 'when user input is blank' do
          before do
            allow(tool).to receive(:input_blank?).and_return(true)
          end

          it 'accepts blank input and returns success answer' do
            expect(tool.execute.content).to eq('successful response')
          end
        end

        it 'returns success answer' do
          expect(tool.execute.content).to eq('successful response')
        end
      end

      context 'when error is raised during a request' do
        before do
          allow(tool).to receive(:request).and_raise(StandardError)
        end

        it 'returns an error answer' do
          answer = tool.execute

          expect(answer.content).to eq("I'm sorry, I can't generate a response. Please try again.")
          expect(answer.error_code).to eq("M4000")
        end
      end

      context 'when the resource is not a vulnerability' do
        let_it_be(:resource) { user }

        it 'returns an error answer' do
          expect(tool.execute.content)
            .to eq(_('This command is used for explaining vulnerabilities and can only be invoked from ' \
              'a vulnerability detail page.'))
        end
      end

      context 'when the vulnerability is not a SAST vulnerability' do
        let_it_be(:resource) { create(:vulnerability, report_type: :secret_detection) }

        it 'returns an error answer' do
          expect(tool.execute.content)
            .to eq(_('Vulnerability Explanation currently only supports vulnerabilities reported by SAST.'))
        end
      end

      context 'when the language is unknown' do
        let(:current_file) { {} }

        before do
          allow(resource).to receive(:file).and_return('filename')
        end

        it 'uses empty language info' do
          expect(prompt_class).to receive(:prompt).with(a_hash_including(language_info: ''))

          tool.execute
        end

        it 'builds the expected system prompt' do
          expected_system_prompt = <<~PROMPT
            You are a software vulnerability developer.
            You can explain vulnerabilities in code.
          PROMPT

          expect(tool.prompt[:prompt][0][:content]).to eq(expected_system_prompt)
        end
      end
    end

    context 'when context is not authorized' do
      before do
        allow(Ability).to receive(:allowed?).with(user, :explain_vulnerability_with_ai, resource).and_return(false)
      end

      it 'returns error answer' do
        answer = tool.execute

        response = "I'm sorry, I can't generate a response. You might want to try again. " \
          "You could also be getting this error because the items you're asking about " \
          "either don't exist, you don't have access to them, or your session has expired."
        expect(answer.content).to eq(response)
        expect(answer.error_code).to eq("M3003")
      end
    end

    context 'when code tool was already used' do
      before do
        context.tools_used << described_class
      end

      it 'returns already used answer' do
        expect(tool.execute.content)
          .to eq('You already have the answer from ExplainVulnerability tool, read carefully.')
      end
    end

    context 'when using claude 3.7 FF' do
      include_context 'with stubbed LLM authorizer', allowed: true

      before do
        allow(Ability).to receive(:allowed?).with(user, :explain_vulnerability_with_ai, resource).and_return(true)
        allow(tool).to receive(:provider_prompt_class).and_return(prompt_class)
        allow(Gitlab::Llm::Chain::Requests::AiGateway).to receive(:new).with(user, {
          service_name: :explain_vulnerability,
          tracking_context: { request_id: nil, action: 'explain_vulnerability' },
          root_namespace: project.root_ancestor
        }).and_return(ai_request_double)
      end

      context 'when FF is enabled' do
        before do
          stub_feature_flags(explain_vulnerability_slash_commands_claude_3_7: true)
        end

        it 'receives the new prompt version' do
          expect(ai_request_double).to receive(:request).with(
            hash_including(options: hash_including(prompt_version: '1.0.1')),
            unit_primitive: 'explain_vulnerability'
          )

          tool.execute

          expect(Gitlab::Llm::Chain::Requests::AiGateway).to have_received(:new).with(
            user,
            service_name: :explain_vulnerability,
            tracking_context: { request_id: nil, action: 'explain_vulnerability' },
            root_namespace: project.root_ancestor
          )
        end
      end

      context 'when FF disabled' do
        before do
          stub_feature_flags(explain_vulnerability_slash_commands_claude_3_7: false)
        end

        it 'uses the old prompt version' do
          expect(ai_request_double).to receive(:request).with(
            hash_including(options: hash_including(prompt_version: '^1.0.0')),
            unit_primitive: 'explain_vulnerability'
          )

          tool.execute

          expect(Gitlab::Llm::Chain::Requests::AiGateway).to have_received(:new).with(
            user,
            service_name: :explain_vulnerability,
            tracking_context: { request_id: nil, action: 'explain_vulnerability' },
            root_namespace: project.root_ancestor
          )
        end
      end
    end
  end
end
