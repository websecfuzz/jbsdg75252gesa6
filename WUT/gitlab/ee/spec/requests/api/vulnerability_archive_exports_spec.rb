# frozen_string_literal: true

require 'spec_helper'

RSpec.describe API::VulnerabilityArchiveExports, feature_category: :vulnerability_management do
  include AccessMatchersForRequest

  before do
    stub_licensed_features(security_dashboard: true)
  end

  let_it_be_with_refind(:project) { create(:project) }
  let_it_be(:user) { create(:user) }

  describe 'POST /security/projects/:id/vulnerability_archive_exports' do
    let(:request_path) { "/security/projects/#{project.id}/vulnerability_archive_exports" }
    let(:export_format) { :csv }
    let(:request_params) do
      {
        export_format: export_format,
        start_date: '01/01/2025',
        end_date: '01/01/2025'
      }
    end

    subject(:create_archive_export) { post api(request_path, user), params: request_params }

    context 'when the request does not fulfill the requirements' do
      let(:export_format) { 'exif' }

      it 'responds with bad_request', :aggregate_failures do
        create_archive_export

        expect(response).to have_gitlab_http_status(:bad_request)
        expect(json_response).to eq('error' => 'export_format does not have a valid value')
      end
    end

    context 'when the request fulfills the requirements' do
      let(:mock_service_object) do
        instance_double(::Vulnerabilities::Archival::Export::CreateService, execute: archive_export)
      end

      before_all do
        project.add_developer(user)
      end

      before do
        allow(::Vulnerabilities::Archival::Export::CreateService).to receive(:new).and_return(mock_service_object)
      end

      context 'when the export creation succeeds' do
        let(:archive_export) { create(:vulnerability_archive_export) }

        it 'returns information about new archive export', :aggregate_failures do
          create_archive_export

          expect(response).to have_gitlab_http_status(:created)
          expect(response).to match_response_schema('public_api/v4/vulnerability_archive_export', dir: 'ee')
        end
      end

      context 'when the export creation fails' do
        let(:errors) { instance_double(ActiveModel::Errors, any?: true, messages: ['foo']) }
        let(:archive_export) { instance_double(Vulnerabilities::ArchiveExport, persisted?: false, errors: errors) }

        it 'returns the error message', :aggregate_failures do
          create_archive_export

          expect(response).to have_gitlab_http_status(:bad_request)
          expect(json_response).to eq('message' => ['foo'])
        end
      end
    end

    describe 'permissions', :enable_admin_mode do
      it { expect { create_archive_export }.to be_allowed_for(:admin) }
      it { expect { create_archive_export }.to be_allowed_for(:owner).of(project) }
      it { expect { create_archive_export }.to be_allowed_for(:maintainer).of(project) }
      it { expect { create_archive_export }.to be_allowed_for(:developer).of(project) }
      it { expect { create_archive_export }.to be_allowed_for(:auditor) }

      it { expect { create_archive_export }.to be_denied_for(:reporter).of(project) }
      it { expect { create_archive_export }.to be_denied_for(:guest).of(project) }
      it { expect { create_archive_export }.to be_denied_for(:anonymous) }
    end

    it_behaves_like 'forbids access to vulnerability API endpoint in case of disabled features' do
      before_all do
        project.add_developer(user)
      end
    end
  end

  describe 'GET /security/vulnerability_archive_exports/:id' do
    let_it_be(:archive_export) { create(:vulnerability_archive_export, :finished, project: project, author: user) }

    let(:request_path) { "/security/vulnerability_archive_exports/#{archive_export.id}" }

    subject(:get_archive_export) { get api(request_path, user) }

    context 'with an authorized user with proper permissions' do
      before_all do
        project.add_developer(user)
      end

      context 'when export is finished' do
        it 'returns information about archive export', :aggregate_failures do
          get_archive_export

          expect(response).to have_gitlab_http_status(:ok)
          expect(response).to match_response_schema('public_api/v4/vulnerability_archive_export', dir: 'ee')
          expect(json_response['id']).to eq archive_export.id
        end

        it 'does not return Poll-Interval header' do
          get_archive_export

          expect(response.headers['Poll-Interval']).to be_blank
        end
      end

      context 'when export is running' do
        before do
          archive_export.update_column(:status, 'running')
        end

        it 'returns information about archive export', :aggregate_failures do
          get_archive_export

          expect(response).to have_gitlab_http_status(:accepted)
          expect(response).to match_response_schema('public_api/v4/vulnerability_archive_export', dir: 'ee')
          expect(json_response['id']).to eq archive_export.id
        end

        it 'returns Poll-Interval header with value set to 5 seconds' do
          get_archive_export

          expect(response.headers['Poll-Interval']).to eq '5000'
        end
      end
    end

    describe 'permissions', :enable_admin_mode do
      context 'for export author' do
        before_all do
          project.add_developer(user)
        end

        it { expect { get_archive_export }.to be_allowed_for(user) }
      end

      context 'for other users' do
        it { expect { get_archive_export }.to be_denied_for(:admin) }
        it { expect { get_archive_export }.to be_denied_for(:owner).of(project) }
        it { expect { get_archive_export }.to be_denied_for(:maintainer).of(project) }
        it { expect { get_archive_export }.to be_denied_for(:developer).of(project) }
        it { expect { get_archive_export }.to be_denied_for(:auditor) }
        it { expect { get_archive_export }.to be_denied_for(:reporter).of(project) }
        it { expect { get_archive_export }.to be_denied_for(:guest).of(project) }
        it { expect { get_archive_export }.to be_denied_for(:anonymous) }
      end
    end

    it_behaves_like 'forbids access to vulnerability API endpoint in case of disabled features' do
      before_all do
        project.add_developer(user)
      end
    end
  end

  describe 'GET /security/vulnerability_archive_exports/:id/download' do
    let!(:archive_export) { create(:vulnerability_archive_export, :finished, project: project, author: user) }
    let(:request_path) { "/security/vulnerability_archive_exports/#{archive_export.id}/download" }

    subject(:download_export) { get api(request_path, user) }

    context 'with an authorized user with proper permissions' do
      before_all do
        project.add_developer(user)
      end

      context 'when export is running' do
        before do
          archive_export.update_column(:status, 'running')
        end

        it 'renders 404', :aggregate_failures do
          download_export

          expect(response).to have_gitlab_http_status(:not_found)
          expect(json_response).to eq('message' => '404 Archive Export Not Found')
        end
      end

      context 'when export is finished' do
        it 'renders 200 with CSV file', :aggregate_failures do
          download_export

          expect(response).to have_gitlab_http_status(:ok)
          expect(response.body).to include 'Scanner Type,Scanner Name'
        end
      end
    end

    describe 'permissions', :enable_admin_mode do
      context 'for export author' do
        before_all do
          project.add_developer(user)
        end

        it { expect { download_export }.to be_allowed_for(user) }
      end

      context 'for other users' do
        it { expect { download_export }.to be_denied_for(:admin) }
        it { expect { download_export }.to be_denied_for(:owner).of(project) }
        it { expect { download_export }.to be_denied_for(:maintainer).of(project) }
        it { expect { download_export }.to be_denied_for(:developer).of(project) }
        it { expect { download_export }.to be_denied_for(:auditor) }
        it { expect { download_export }.to be_denied_for(:reporter).of(project) }
        it { expect { download_export }.to be_denied_for(:guest).of(project) }
        it { expect { download_export }.to be_denied_for(:anonymous) }
      end
    end

    it_behaves_like 'forbids access to vulnerability API endpoint in case of disabled features' do
      before_all do
        project.add_developer(user)
      end
    end
  end
end
