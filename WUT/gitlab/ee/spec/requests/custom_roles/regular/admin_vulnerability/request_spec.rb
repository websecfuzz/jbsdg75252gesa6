# frozen_string_literal: true

require 'spec_helper'

RSpec.describe 'User with admin_vulnerability custom role', feature_category: :permissions do
  let_it_be(:user) { create(:user) }
  let_it_be(:project) { create(:project, :repository, :in_group) }
  let_it_be_with_reload(:role) { create(:member_role, :guest, :admin_vulnerability, namespace: project.group) }
  let_it_be(:membership) { create(:group_member, :guest, user: user, source: project.group, member_role: role) }

  let(:current_user) { user }

  before do
    stub_licensed_features(custom_roles: true, security_dashboard: true, jira_vulnerabilities_integration: true)
  end

  describe Projects::Security::VulnerabilitiesController do
    before do
      sign_in(current_user)
    end

    describe "#new" do
      subject(:add_project_security_vulnerability) { get new_project_security_vulnerability_path(project) }

      it 'user has access via a custom role' do
        add_project_security_vulnerability

        expect(response).to have_gitlab_http_status(:ok)
        expect(response.body).to have_text(
          format(s_('VulnerabilityManagement|Add vulnerability finding'))
        )
      end

      context 'when user is a maintainer' do
        let(:current_user) { create(:user, maintainer_of: project) }

        it_behaves_like 'does not call custom role query'
      end

      context 'when user is an owner' do
        let(:current_user) { create(:user, owner_of: project) }

        it_behaves_like 'does not call custom role query'
      end
    end
  end

  describe Mutations::Security::Finding::CreateIssue do
    include GraphqlHelpers

    let_it_be(:pipeline) { create(:ee_ci_pipeline, project: project) }
    let_it_be(:build) { create(:ci_build, :success, project: project, pipeline: pipeline) }
    let_it_be(:artifact) { create(:ee_ci_job_artifact, :dependency_scanning_remediation, job: build) }
    let_it_be(:report) { create(:dependency_scanning_security_report, pipeline: pipeline) }
    let_it_be(:report_finding) { report.findings.last }
    let_it_be(:scan) do
      create(:security_scan, :latest_successful, {
        scan_type: :dependency_scanning,
        pipeline: pipeline,
        build: artifact.job
      })
    end

    let_it_be(:security_finding) do
      create(:security_finding, {
        severity: report_finding.severity,
        uuid: report_finding.uuid,
        scan: scan
      })
    end

    it "has access via a custom role" do
      post_graphql_mutation(graphql_mutation(:security_finding_create_issue, {
        project: project.to_global_id.to_s,
        uuid: security_finding.uuid.to_s
      }), current_user: user)

      expect(response).to have_gitlab_http_status(:success)
      mutation_response = graphql_mutation_response(:security_finding_create_issue)
      expect(mutation_response).to be_present
      expect(mutation_response['errors']).to be_empty
    end
  end

  describe Mutations::Security::Finding::CreateMergeRequest do
    include GraphqlHelpers

    let_it_be(:pipeline) { create(:ee_ci_pipeline, project: project) }
    let_it_be(:build) { create(:ci_build, :success, project: project, pipeline: pipeline) }
    let_it_be(:artifact) { create(:ee_ci_job_artifact, :dependency_scanning_remediation, job: build) }
    let_it_be(:report) { create(:dependency_scanning_security_report, pipeline: pipeline) }
    let_it_be(:report_finding) { report.findings.last }
    let_it_be(:scan) do
      create(:security_scan, :latest_successful, {
        scan_type: :dependency_scanning,
        pipeline: pipeline,
        build: artifact.job
      })
    end

    let_it_be(:security_finding) do
      create(:security_finding, {
        severity: report_finding.severity,
        uuid: report_finding.uuid,
        scan: scan
      })
    end

    before do
      role.update!(admin_merge_request: true)
      allow_next_instance_of(Commits::CommitPatchService) do |service|
        allow(service).to receive(:execute).and_return(status: :success)
      end
    end

    it "has access via a custom role" do
      post_graphql_mutation(graphql_mutation(:security_finding_create_merge_request, {
        uuid: security_finding.uuid.to_s
      }), current_user: user)

      expect(response).to have_gitlab_http_status(:success)
      mutation_response = graphql_mutation_response(:security_finding_create_merge_request)
      expect(mutation_response).to be_present
      expect(mutation_response['errors']).to be_empty
    end
  end

  describe Mutations::Security::Finding::Dismiss do
    include GraphqlHelpers

    let_it_be(:pipeline) { create(:ee_ci_pipeline, project: project) }
    let_it_be(:build) { create(:ci_build, :success, project: project, pipeline: pipeline) }
    let_it_be(:scan) { create(:security_scan, build: build) }
    let_it_be(:security_finding) do
      create(:security_finding, :with_finding_data, scan: scan, remediation_byte_offsets: [{
        "start_byte" => 0,
        "end_byte" => 1
      }])
    end

    it "has access via a custom role" do
      post_graphql_mutation(graphql_mutation(:security_finding_dismiss, {
        uuid: security_finding.uuid,
        comment: "dismissal feedback",
        dismissal_reason: "USED_IN_TESTS"
      }), current_user: user)

      expect(response).to have_gitlab_http_status(:success)
      mutation_response = graphql_mutation_response(:security_finding_dismiss)
      expect(mutation_response).to be_present
      expect(mutation_response["securityFinding"]).to be_present
      expect(mutation_response["errors"]).to be_empty
    end
  end

  describe Mutations::Security::Finding::RevertToDetected do
    include GraphqlHelpers

    let_it_be(:pipeline) { create(:ee_ci_pipeline, project: project) }
    let_it_be(:build) { create(:ci_build, :success, project: project, pipeline: pipeline) }
    let_it_be(:scan) { create(:security_scan, build: build) }
    let_it_be(:security_finding) { create(:security_finding, :with_finding_data, scan: scan) }

    it "has access via a custom role" do
      post_graphql_mutation(graphql_mutation(:security_finding_revert_to_detected, {
        uuid: security_finding.uuid.to_s
      }), current_user: user)

      expect(response).to have_gitlab_http_status(:success)
      mutation_response = graphql_mutation_response(:security_finding_revert_to_detected)
      expect(mutation_response).to be_present
      expect(mutation_response['errors']).to be_empty
    end
  end

  describe Mutations::Vulnerabilities::BulkDismiss do
    include GraphqlHelpers

    let_it_be(:vulnerability) { create(:vulnerability, :with_findings, project: project) }

    it "has access via a custom role" do
      post_graphql_mutation(graphql_mutation(:vulnerabilities_dismiss, {
        vulnerability_ids: [vulnerability.to_global_id.to_s],
        comment: 'Dismissal Feedback',
        dismissal_reason: 'USED_IN_TESTS'
      }), current_user: user)

      expect(response).to have_gitlab_http_status(:success)
      mutation_response = graphql_mutation_response(:vulnerabilities_dismiss)
      expect(mutation_response).to be_present
      expect(mutation_response["vulnerabilities"]).to be_present
      expect(mutation_response["errors"]).to be_empty
    end
  end

  describe Mutations::Vulnerabilities::Confirm do
    include GraphqlHelpers

    let_it_be(:vulnerability) { create(:vulnerability, :with_findings, project: project) }

    it "has access via a custom role" do
      post_graphql_mutation(graphql_mutation(:vulnerability_confirm, {
        id: vulnerability.to_global_id.to_s,
        comment: "A comment"
      }), current_user: user)

      expect(response).to have_gitlab_http_status(:success)
      mutation_response = graphql_mutation_response(:vulnerability_confirm)
      expect(mutation_response).to be_present
      expect(mutation_response["vulnerability"]).to be_present
      expect(mutation_response["errors"]).to be_empty
    end
  end

  describe Mutations::Vulnerabilities::Create do
    include GraphqlHelpers

    it "has access via a custom role" do
      post_graphql_mutation(graphql_mutation(:vulnerability_create, {
        project: project.to_global_id,
        name: "example",
        description: "example",
        scanner: {
          id: "my-custom-scanner",
          name: "example",
          url: "https://example.org",
          vendor: { name: "example" },
          version: "1.0.0"
        },
        identifiers: [{
          name: "example",
          url: "https://example.org/example"
        }],
        state: "DETECTED",
        severity: "UNKNOWN",
        solution: "curl -s 'https://unpkg.com/emoji.json@13.1.0/emoji.json' | jq -r '.[] | .char'"
      }), current_user: user)

      expect(response).to have_gitlab_http_status(:success)
      mutation_response = graphql_mutation_response(:vulnerability_create)
      expect(mutation_response).to be_present
      expect(mutation_response["vulnerability"]).to be_present
      expect(mutation_response["errors"]).to be_empty
    end
  end

  describe Mutations::Vulnerabilities::CreateExternalIssueLink do
    include GraphqlHelpers

    let_it_be(:vulnerability) { create(:vulnerability, :with_finding, project: project) }
    let_it_be(:jira_integration) do
      create(:jira_integration, {
        project: project,
        project_key: "GL",
        vulnerabilities_enabled: true,
        vulnerabilities_issuetype: '10001'
      })
    end

    before do
      stub_request(:get, "https://jira.example.com/rest/api/2/project/GL")
        .to_return(status: 200, headers: { 'content-type' => 'application/json' }, body: [].to_json)

      stub_request(:post, "https://jira.example.com/rest/api/2/issue")
        .to_return(status: 200, headers: { 'content-type' => 'application/json' }, body: { id: '1000' }.to_json)
    end

    it "has access via a custom role" do
      post_graphql_mutation(graphql_mutation(:vulnerability_external_issue_link_create, {
        id: vulnerability.to_global_id.to_s,
        link_type: 'CREATED',
        external_tracker: 'JIRA'
      }), current_user: user)

      expect(response).to have_gitlab_http_status(:success)
      mutation_response = graphql_mutation_response(:vulnerability_external_issue_link_create)
      expect(mutation_response).to be_present
      expect(mutation_response["externalIssueLink"]).to be_present
      expect(mutation_response["errors"]).to be_empty
    end
  end

  describe Mutations::Vulnerabilities::CreateIssueLink do
    include GraphqlHelpers

    let_it_be(:issue) { create(:issue, project: project) }
    let_it_be(:vulnerability) { create(:vulnerability, project: project) }

    it "has access via a custom role" do
      post_graphql_mutation(graphql_mutation(:vulnerability_issue_link_create, {
        issue_id: issue.to_global_id.to_s,
        vulnerability_ids: [vulnerability.to_global_id.to_s]
      }), current_user: user)

      expect(response).to have_gitlab_http_status(:success)
      mutation_response = graphql_mutation_response(:vulnerability_issue_link_create)
      expect(mutation_response).to be_present
      expect(mutation_response["issueLinks"]).to be_present
      expect(mutation_response["errors"]).to be_empty
    end
  end

  describe Mutations::Vulnerabilities::DestroyExternalIssueLink do
    include GraphqlHelpers

    let_it_be(:vulnerability) { create(:vulnerability, project: project) }
    let_it_be(:external_issue_link) { create(:vulnerabilities_external_issue_link, vulnerability: vulnerability) }

    it "has access via a custom role" do
      post_graphql_mutation(graphql_mutation(:vulnerability_external_issue_link_destroy, {
        id: external_issue_link.to_global_id.to_s
      }), current_user: user)

      expect(response).to have_gitlab_http_status(:success)
      mutation_response = graphql_mutation_response(:vulnerability_external_issue_link_destroy)
      expect(mutation_response).to be_present
      expect(mutation_response["errors"]).to be_empty
    end
  end

  describe Mutations::Vulnerabilities::Dismiss do
    include GraphqlHelpers

    let_it_be(:vulnerability) { create(:vulnerability, :with_findings, project: project) }

    it "has access via a custom role" do
      post_graphql_mutation(graphql_mutation(:vulnerability_dismiss, {
        id: vulnerability.to_global_id.to_s,
        comment: "comment",
        dismissal_reason: "USED_IN_TESTS"
      }), current_user: user)

      expect(response).to have_gitlab_http_status(:success)
      mutation_response = graphql_mutation_response(:vulnerability_dismiss)
      expect(mutation_response).to be_present
      expect(mutation_response["vulnerability"]).to be_present
      expect(mutation_response["errors"]).to be_empty
    end
  end

  describe Mutations::Vulnerabilities::Resolve do
    include GraphqlHelpers

    let_it_be(:vulnerability) { create(:vulnerability, :with_findings, project: project) }

    it "has access via a custom role" do
      post_graphql_mutation(graphql_mutation(:vulnerability_resolve, {
        id: vulnerability.to_global_id.to_s,
        comment: "resolved"
      }), current_user: user)

      expect(response).to have_gitlab_http_status(:success)
      mutation_response = graphql_mutation_response(:vulnerability_resolve)
      expect(mutation_response).to be_present
      expect(mutation_response["vulnerability"]).to be_present
      expect(mutation_response["errors"]).to be_empty
    end
  end

  describe Mutations::Vulnerabilities::RevertToDetected do
    include GraphqlHelpers

    let_it_be(:vulnerability) { create(:vulnerability, :dismissed, :with_findings, project: project) }

    it "has access via a custom role" do
      post_graphql_mutation(graphql_mutation(:vulnerability_revert_to_detected, {
        id: vulnerability.to_global_id.to_s,
        comment: "comment"
      }), current_user: user)

      expect(response).to have_gitlab_http_status(:success)
      mutation_response = graphql_mutation_response(:vulnerability_revert_to_detected)
      expect(mutation_response).to be_present
      expect(mutation_response["vulnerability"]).to be_present
      expect(mutation_response["errors"]).to be_empty
    end
  end
end
