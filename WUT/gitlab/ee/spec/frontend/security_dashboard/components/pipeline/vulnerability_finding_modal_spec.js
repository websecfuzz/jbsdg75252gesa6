import {
  GlModal,
  GlFormInput,
  GlFormGroup,
  GlCollapsibleListbox,
  GlListboxItem,
  GlSprintf,
  GlTabs,
  GlTab,
} from '@gitlab/ui';
import Vue, { nextTick } from 'vue';
import VueApollo from 'vue-apollo';
import waitForPromises from 'helpers/wait_for_promises';
import createMockApollo from 'helpers/mock_apollo_helper';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import { stubComponent, RENDER_ALL_SLOTS_TEMPLATE } from 'helpers/stub_component';
import VulnerabilityFindingModal, {
  STATE_DETECTED,
  STATE_DISMISSED,
  STATE_RESOLVED,
  VULNERABILITY_POLLING_INTERVAL,
} from 'ee/security_dashboard/components/pipeline/vulnerability_finding_modal.vue';
import download from '~/lib/utils/downloader';
import { visitUrl } from '~/lib/utils/url_utility';
import { ESC_KEY } from '~/lib/utils/keys';
import DismissalNote from 'ee/vue_shared/security_reports/components/dismissal_note.vue';
import EventItem from 'ee/vue_shared/security_reports/components/event_item.vue';
import SplitButton from 'ee/vue_shared/security_reports/components/split_button.vue';
import ResolveWithAiButton from 'ee/security_dashboard/components/pipeline/resolve_with_ai_button.vue';
import VulnerabilityFindingModalDetails from 'ee/security_dashboard/components/pipeline/vulnerability_finding_modal_details.vue';
import VulnerabilityDismissalReason from 'ee/security_dashboard/components/pipeline/vulnerability_dismissal_reason.vue';
import securityReportFindingQuery from 'ee/security_dashboard/graphql/queries/security_report_finding.query.graphql';
import vulnerabilityExternalIssuesQuery from 'ee/security_dashboard/graphql/queries/vulnerability_external_issues.query.graphql';
import dismissFindingMutation from 'ee/security_dashboard/graphql/mutations/dismiss_finding.mutation.graphql';
import createMergeRequestMutation from 'ee/security_dashboard/graphql/mutations/finding_create_merge_request.mutation.graphql';
import securityFindingRevertToDetected from 'ee/security_dashboard/graphql/mutations/revert_finding_to_detected.mutation.graphql';
import createIssueMutation from 'ee/security_dashboard/graphql/mutations/finding_create_issue.mutation.graphql';
import createExternalIssueMutation from 'ee/security_dashboard/graphql/mutations/finding_create_jira_issue.mutation.graphql';
import { VULNERABILITY_TAB_NAMES } from 'ee/vulnerabilities/constants';
import VulnerabilityCodeFlow from 'ee/vue_shared/components/code_flow/vulnerability_code_flow.vue';
import {
  getPipelineSecurityReportFindingResponse,
  getVulnerabilityExternalIssuesQueryResponse,
  pipelineSecurityReportFinding,
  securityFindingDismissMutationResponse,
  securityFindingRevertToDetectedMutationResponse,
  securityFindingCreateMergeRequestMutationResponse,
  securityFindingCreateIssueMutationResponse,
  securityFindingCreateExternalIssueMutationResponse,
} from './mock_data';

jest.mock('~/lib/utils/downloader');
jest.mock('~/lib/utils/url_utility');

Vue.use(VueApollo);

const TEST_FINDING = pipelineSecurityReportFinding;
const TEST_PIPELINE_IID = 1;
const TEST_PIPELINE_SOURCE_BRANCH = 'feature-branch';
const TEST_MERGE_REQUEST_ID = 150;
const TEST_PROJECT_FULL_PATH = 'path/to/my/project';
const TEST_ISSUE = {
  id: '1',
  linkType: 'CREATED',
  issue: {
    id: '2',
    iid: 2,
    webUrl: 'http://gdk.test:3000/secure-ex/security-reports/-/issues/2',
    createdAt: '2023-01-25T21:41:34Z',
    author: {
      id: 'gid://gitlab/User/1',
      name: 'Administrator',
      username: 'root',
      webUrl: 'http://gdk.test:3000/root',
    },
  },
};

describe('ee/security_dashboard/components/pipeline/vulnerability_finding_modal.vue', () => {
  let wrapper;
  let modalMockMethods;
  let dismissFindingMutationResolver;

  const createMockApolloProvider = ({ handlers = {} } = {}) => {
    dismissFindingMutationResolver =
      handlers.dismissMutation ||
      jest.fn().mockResolvedValue(securityFindingDismissMutationResponse);
    const requestHandlers = [
      [
        securityReportFindingQuery,
        handlers.securityReportFindingQuery ||
          jest.fn().mockResolvedValue(getPipelineSecurityReportFindingResponse()),
      ],
      [
        vulnerabilityExternalIssuesQuery,
        handlers.vulnerabilityExternalIssuesQuery ||
          jest.fn().mockResolvedValue(getVulnerabilityExternalIssuesQueryResponse()),
      ],
      [dismissFindingMutation, dismissFindingMutationResolver],
      [
        securityFindingRevertToDetected,
        handlers.revertToDetectedMutation ||
          jest.fn().mockResolvedValue(securityFindingRevertToDetectedMutationResponse),
      ],
      [
        createMergeRequestMutation,
        handlers.createMergeRequestMutation ||
          jest.fn().mockResolvedValue(securityFindingCreateMergeRequestMutationResponse),
      ],
      [
        createIssueMutation,
        handlers.createIssueMutation ||
          jest.fn().mockResolvedValue(securityFindingCreateIssueMutationResponse),
      ],
      [
        createExternalIssueMutation,
        handlers.createExternalIssueMutation ||
          jest.fn().mockResolvedValue(securityFindingCreateExternalIssueMutationResponse),
      ],
    ];

    return createMockApollo(requestHandlers);
  };

  const createWrapper = ({
    responseHandlers,
    propsData,
    glAbilities: { resolveVulnerabilityWithAi = true } = {},
    ...options
  } = {}) => {
    modalMockMethods = {
      hide: jest.fn(),
      setFocus: jest.fn(),
    };
    wrapper = shallowMountExtended(VulnerabilityFindingModal, {
      propsData: {
        findingUuid: TEST_FINDING.uuid,
        pipelineIid: TEST_PIPELINE_IID,
        branchRef: TEST_PIPELINE_SOURCE_BRANCH,
        projectFullPath: TEST_PROJECT_FULL_PATH,
        mergeRequestId: TEST_MERGE_REQUEST_ID,
        ...propsData,
      },
      stubs: {
        GlModal: stubComponent(GlModal, {
          template: RENDER_ALL_SLOTS_TEMPLATE,
          methods: modalMockMethods,
        }),
        SplitButton,
        GlCollapsibleListbox,
        GlListboxItem,
        GlSprintf,
      },
      apolloProvider: createMockApolloProvider({
        handlers: responseHandlers,
      }),
      provide: {
        glAbilities: { resolveVulnerabilityWithAi },
      },
      ...options,
    });
  };

  const findModal = () => wrapper.findComponent(GlModal);
  const findVulnerabilityDetails = () => wrapper.findComponent(VulnerabilityFindingModalDetails);
  const findVulnerabilityCodeFlow = () => wrapper.findComponent(VulnerabilityCodeFlow);
  const findErrorAlert = () => wrapper.findByTestId('error-alert');
  const findNoFindingAlert = () => wrapper.findByTestId('no-finding-alert');
  const findLoadingIndicators = () => [
    wrapper.findByTestId('title-loading-indicator'),
    wrapper.findByTestId('content-loading-indicator'),
  ];
  const findDismissButton = () => wrapper.findByTestId('dismiss-button');
  const findUndoDismissButton = () => wrapper.findByTestId('undo-dismiss-button');
  const findCancelButton = () => wrapper.findByTestId('cancel-button');
  const findTabs = () => wrapper.findComponent(GlTabs);
  const findAllTab = () => wrapper.findAllComponents(GlTab);
  const findTabAtIndex = (index) => findAllTab().at(index);
  const findCancelEditButton = () => wrapper.findByTestId('cancel-editing-dismissal');
  const findConfirmDismissalButton = () => wrapper.findByTestId('save-editing-dismissal');
  const findDismissalEditSection = () => wrapper.findByTestId('dismissal-edit-section');
  const findVulnerabilityDismissalReason = () =>
    wrapper.findComponent(VulnerabilityDismissalReason);
  const findCommentFormGroup = () => wrapper.findComponent(GlFormGroup);
  const findCommentInput = () => findDismissalEditSection().findComponent(GlFormInput);
  const findDismissalNote = () => wrapper.findComponent(DismissalNote);

  const expectModalToBeHiddenAfter = async ({ action }) => {
    expect(modalMockMethods.hide).not.toHaveBeenCalled();

    await action();

    expect(modalMockMethods.hide).toHaveBeenCalled();
  };

  const waitForFindingToBeLoaded = waitForPromises;
  const waitForFindingToBeDismissed = waitForPromises;

  describe('modal instance', () => {
    beforeEach(async () => {
      createWrapper();
      await waitForPromises();
    });

    it('gets passed the correct props', async () => {
      await waitForFindingToBeLoaded();

      expect(findModal().props()).toMatchObject({
        modalId: expect.any(String),
        title: TEST_FINDING.title,
      });
    });

    it('sets "Error" as the modal title when the finding is empty', () => {
      createWrapper({ propsData: {} });

      expect(findModal().props('title')).toBe('Error');
    });

    it('makes the component emit "hidden" when the modal gets closed', () => {
      expect(wrapper.emitted('hidden')).toBeUndefined();

      findModal().vm.$emit('hidden');

      expect(wrapper.emitted('hidden')).toHaveLength(1);
    });

    describe('footer', () => {
      it('renders as expected', () => {
        const findFooter = () => wrapper.findByTestId('slot-modal-footer');
        expect(findFooter().exists()).toBe(true);
      });

      it('contains a "cancel" button that will hide the modal', () => {
        expectModalToBeHiddenAfter({
          action: () => {
            findCancelButton().vm.$emit('click');
          },
        });
      });

      it('contains a "dismiss" button', () => {
        expect(findDismissButton().exists()).toBe(true);
      });
    });
  });

  describe('when loading', () => {
    beforeEach(() => {
      createWrapper();
    });

    it('does not show tabs', () => {
      expect(findTabs().exists()).toBe(false);
    });

    it('does not show an error alert', () => {
      expect(findErrorAlert().exists()).toBe(false);
    });

    it('does not show a no finding alert', () => {
      expect(findNoFindingAlert().exists()).toBe(false);
    });

    it('shows a skeleton loaders', () => {
      findLoadingIndicators().forEach((loadingIndicator) => {
        expect(loadingIndicator.exists()).toBe(true);
      });
    });
  });

  describe('when loaded successfully', () => {
    beforeEach(async () => {
      createWrapper();
      await waitForFindingToBeLoaded();
    });

    it('does not show an error alert', () => {
      expect(findErrorAlert().exists()).toBe(false);
    });

    it('does not show a no finding alert', () => {
      expect(findNoFindingAlert().exists()).toBe(false);
    });

    it('does not show skeleton loaders', () => {
      findLoadingIndicators().forEach((loadingIndicator) => {
        expect(loadingIndicator.exists()).toBe(false);
      });
    });

    it(`shows the finding's title within the modal's header`, () => {
      expect(wrapper.findByRole('heading').text()).toBe(TEST_FINDING.title);
    });

    describe('when `details.codeFlows` object is not empty', () => {
      beforeEach(async () => {
        createWrapper({});
        await waitForPromises();
      });

      it('should open the first tab by default', () => {
        expect(findTabs().attributes('value')).toBe('0');
      });

      it('should emit redirectToCodeFlowTab when redirect event is triggered', async () => {
        await findVulnerabilityDetails().vm.$emit('redirectToCodeFlowTab');
        expect(findTabs().attributes('value')).toBe('1');
      });

      describe.each`
        title                                | finderFn                     | index
        ${VULNERABILITY_TAB_NAMES.DETAILS}   | ${findVulnerabilityDetails}  | ${0}
        ${VULNERABILITY_TAB_NAMES.CODE_FLOW} | ${findVulnerabilityCodeFlow} | ${1}
      `('Tabs', ({ title, finderFn, index }) => {
        it(`renders tab with a title ${title} at index ${index}`, () => {
          expect(findTabAtIndex(index).attributes('title')).toBe(title);
        });

        it(`renders ${title} component`, () => {
          expect(finderFn().exists()).toBe(true);
        });
      });
    });

    describe('when `details.codeFlows` object is empty', () => {
      it('checks code flow button functionality', async () => {
        const response = getPipelineSecurityReportFindingResponse({
          withoutFindingData: true,
        });
        createWrapper({
          responseHandlers: {
            securityReportFindingQuery: jest.fn().mockResolvedValue(response),
          },
        });
        await waitForFindingToBeLoaded();
        expect(findTabs().exists()).toBe(false);
      });
    });

    describe('finding details', () => {
      it('displays details about the given vulnerability finding', () => {
        expect(findVulnerabilityDetails().exists()).toBe(true);
      });
    });
  });

  describe('with error response', () => {
    beforeEach(async () => {
      createWrapper({
        responseHandlers: { securityReportFindingQuery: jest.fn().mockRejectedValue() },
      });
      await waitForFindingToBeLoaded();
    });

    it(`shows an error message within the modal's heading`, () => {
      expect(wrapper.findByRole('heading').text()).toBe('Error');
    });

    it('shows an error alert with the correct error message', () => {
      expect(findErrorAlert().text()).toBe(
        'There was an error fetching the finding. Please try again.',
      );
    });

    it('does not show a no finding alert', () => {
      expect(findNoFindingAlert().exists()).toBe(false);
    });
  });

  describe('with empty data', () => {
    beforeEach(async () => {
      createWrapper({
        responseHandlers: {
          securityReportFindingQuery: jest
            .fn()
            .mockResolvedValue(
              getPipelineSecurityReportFindingResponse({ withoutFindingData: true }),
            ),
        },
      });
      await waitForFindingToBeLoaded();
    });

    it(`shows an error message within the modal's heading`, () => {
      expect(wrapper.findByRole('heading').text()).toBe('Error');
    });

    it('does not show an error alert', () => {
      expect(findErrorAlert().exists()).toBe(false);
    });

    it('shows a no finding alert with the correct message', () => {
      expect(findNoFindingAlert().text()).toBe(
        'There was an error fetching the finding. The security report for this pipeline may have expired. To generate a new security report, go the Pipelines tab and run a pipeline.',
      );
    });
  });

  describe('state change', () => {
    describe('undo dismiss', () => {
      it("updates to 'DETECTED'", async () => {
        const firstResponse = getPipelineSecurityReportFindingResponse({
          overrides: {
            state: STATE_DISMISSED,
          },
        });
        const secondResponse = getPipelineSecurityReportFindingResponse({
          overrides: {
            state: STATE_DETECTED,
          },
        });
        const mockHandler = jest
          .fn()
          .mockResolvedValueOnce(firstResponse)
          .mockResolvedValueOnce(secondResponse);
        createWrapper({
          responseHandlers: {
            securityReportFindingQuery: mockHandler,
          },
        });

        await waitForFindingToBeLoaded();
        expect(findVulnerabilityDetails().props('vulnerability').state).toBe(STATE_DISMISSED);

        findUndoDismissButton().vm.$emit('click');
        await waitForFindingToBeDismissed();

        expect(findVulnerabilityDetails().props('vulnerability').state).toBe(STATE_DETECTED);
      });

      describe('success', () => {
        beforeEach(async () => {
          const response = getPipelineSecurityReportFindingResponse({
            overrides: {
              state: STATE_DISMISSED,
            },
          });
          createWrapper({
            responseHandlers: {
              securityReportFindingQuery: jest.fn().mockResolvedValue(response),
            },
          });
          await waitForFindingToBeLoaded();
        });

        it('emits "detected" on success', async () => {
          expect(wrapper.emitted('detected')).toBeUndefined();

          findUndoDismissButton().vm.$emit('click');
          await waitForFindingToBeDismissed();

          expect(wrapper.emitted('detected')).toBeDefined();
        });

        it('hides the modal', () => {
          expectModalToBeHiddenAfter({
            action: async () => {
              findUndoDismissButton().vm.$emit('click');
              await waitForFindingToBeDismissed();
            },
          });
        });
      });

      describe('error', () => {
        it('shows an error alert when the undo dismiss fails', async () => {
          const response = getPipelineSecurityReportFindingResponse({
            overrides: {
              state: STATE_DISMISSED,
            },
          });
          createWrapper({
            responseHandlers: {
              securityReportFindingQuery: jest.fn().mockResolvedValue(response),
              dismissMutation: jest.fn().mockRejectedValue(),
              revertToDetectedMutation: jest.fn().mockRejectedValue(),
            },
          });
          await waitForFindingToBeLoaded();
          expect(findErrorAlert().exists()).toBe(false);

          findUndoDismissButton().vm.$emit('click');
          await waitForFindingToBeDismissed();

          expect(findErrorAlert().text()).toBe('There was an error reverting the dismissal.');
        });
      });
    });

    describe('dismiss', () => {
      const dismiss = async () => {
        findDismissButton().vm.$emit('click');
        await nextTick();

        findVulnerabilityDismissalReason().vm.$emit('input', 'acceptable_risk');
        findCommentInput().vm.$emit('input', 'test comment');
        findConfirmDismissalButton().vm.$emit('click');

        await waitForFindingToBeDismissed();
      };

      it("updates to 'DISMISSED' with dismissal reason", async () => {
        const firstResponse = getPipelineSecurityReportFindingResponse({
          overrides: {
            state: STATE_DETECTED,
          },
        });
        const secondResponse = getPipelineSecurityReportFindingResponse({
          overrides: {
            state: STATE_DISMISSED,
          },
        });
        const mockHandler = jest
          .fn()
          .mockResolvedValueOnce(firstResponse)
          .mockResolvedValueOnce(secondResponse);
        createWrapper({
          responseHandlers: {
            securityReportFindingQuery: mockHandler,
          },
        });

        await waitForFindingToBeLoaded();
        expect(findVulnerabilityDetails().props('vulnerability').state).toBe(STATE_DETECTED);

        await dismiss();

        expect(dismissFindingMutationResolver).toHaveBeenCalledWith(
          expect.objectContaining({
            dismissalReason: 'ACCEPTABLE_RISK',
          }),
        );
        expect(findVulnerabilityDetails().props('vulnerability').state).toBe(STATE_DISMISSED);
      });

      describe('success', () => {
        beforeEach(async () => {
          const response = getPipelineSecurityReportFindingResponse({
            overrides: {
              state: STATE_DETECTED,
            },
          });
          createWrapper({
            responseHandlers: {
              securityReportFindingQuery: jest.fn().mockResolvedValue(response),
            },
          });
          await waitForFindingToBeLoaded();
        });

        it('emits "dismissed" on success', async () => {
          expect(wrapper.emitted('dismissed')).toBeUndefined();

          await dismiss();

          expect(wrapper.emitted('dismissed')).toBeDefined();
        });

        it('hides the modal', () => {
          expectModalToBeHiddenAfter({
            action: async () => {
              await dismiss();
            },
          });
        });
      });

      describe('error', () => {
        it('shows an error alert when the dismiss fails', async () => {
          const response = getPipelineSecurityReportFindingResponse({
            overrides: {
              state: STATE_DETECTED,
            },
          });
          createWrapper({
            responseHandlers: {
              securityReportFindingQuery: jest.fn().mockResolvedValue(response),
              dismissMutation: jest.fn().mockRejectedValue(),
              revertToDetectedMutation: jest.fn().mockRejectedValue(),
            },
          });
          await waitForFindingToBeLoaded();

          expect(findErrorAlert().exists()).toBe(false);

          await dismiss();

          expect(findErrorAlert().text()).toBe(
            'There was an error dismissing the finding. Please try again.',
          );
        });
      });

      describe('without existing feedback', () => {
        const TEST_CURRENT_USER_ID = '1';
        const TEST_CURRENT_USER_NAME = 'root';
        const TEST_CURRENT_USER_FULL_NAME = 'root user';

        const mockDismissFindingMutation = jest.fn().mockResolvedValue({
          data: {
            securityFindingDismiss: {
              errors: [],
            },
          },
        });

        beforeEach(async () => {
          window.gon = {
            current_user_id: TEST_CURRENT_USER_ID,
            current_username: TEST_CURRENT_USER_NAME,
            current_user_fullname: TEST_CURRENT_USER_FULL_NAME,
          };
          createWrapper({
            responseHandlers: {
              dismissMutation: mockDismissFindingMutation,
            },
          });
          await waitForPromises();
        });

        it('does not show the dismissal edit section', () => {
          expect(findDismissalEditSection().exists()).toBe(false);
        });

        it('does not render the dismissal notes section', async () => {
          createWrapper();
          await waitForPromises();

          expect(findDismissalNote().exists()).toBe(false);

          await findDismissButton().vm.$emit('click');
          // Should also not render when adding a dismissal comment
          expect(findDismissalNote().exists()).toBe(false);
        });

        it('contains a button to dismiss', () => {
          expect(findDismissButton().text()).toBe('Dismiss vulnerability');
        });

        describe('when the "Dismiss vulnerability" button is clicked', () => {
          beforeEach(async () => {
            findDismissButton().vm.$emit('click');
            await nextTick();
          });

          it('should show the dismissal edit section', () => {
            expect(findDismissalEditSection().exists()).toBe(true);
          });

          it('should hide the dismiss button', () => {
            expect(findDismissButton().exists()).toBe(false);
          });

          it('should show "Confirm dismissal" button', () => {
            expect(findConfirmDismissalButton().text()).toBe('Confirm dismissal');
          });

          describe('edit section', () => {
            it('shows information about the current user', () => {
              expect(findDismissalEditSection().findComponent(EventItem).props()).toMatchObject({
                author: {
                  id: TEST_CURRENT_USER_ID,
                  username: TEST_CURRENT_USER_NAME,
                  name: TEST_CURRENT_USER_FULL_NAME,
                  state: 'active',
                },
              });
            });

            it('contains a dismissal reason listbox', () => {
              expect(findVulnerabilityDismissalReason().exists()).toBe(true);
              expect(findVulnerabilityDismissalReason().props()).toMatchObject({
                value: null,
                state: null,
              });
            });

            it('contains an input that has the correct placeholder, label, and invalid feedback', () => {
              expect(findCommentInput().attributes('placeholder')).toBe(
                'Add a comment or reason for dismissal',
              );
              expect(findCommentFormGroup().attributes('label')).toBe('Comment (required)');
              expect(findCommentFormGroup().attributes('invalid-feedback')).toBe(
                'A comment is required when dismissing.',
              );
            });

            it('closes the edit section when the "Esc" key is pressed in comment input', async () => {
              expect(findDismissalEditSection().exists()).toBe(true);
              expect(modalMockMethods.setFocus).not.toHaveBeenCalled();

              findCommentInput().vm.$emit(
                'keydown',
                new KeyboardEvent('keydown', { key: ESC_KEY }),
              );
              await nextTick();

              expect(modalMockMethods.setFocus).toHaveBeenCalled();
              expect(findDismissalEditSection().exists()).toBe(false);
            });

            it('shows an input to enter a comment and dismiss with it', async () => {
              expect(mockDismissFindingMutation).not.toHaveBeenCalled();

              findVulnerabilityDismissalReason().vm.$emit('input', 'acceptable_risk');
              const comment = 'dismissed because the finding is a false-positive';
              findCommentInput().vm.$emit('input', comment);

              findConfirmDismissalButton().vm.$emit('click');
              await waitForPromises();

              expect(mockDismissFindingMutation).toHaveBeenCalledTimes(1);
              const [firstCall] = mockDismissFindingMutation.mock.calls;
              expect(firstCall[0].comment).toBe(comment);
              expect(firstCall[0].dismissalReason).toBe('ACCEPTABLE_RISK');

              expect(findCommentFormGroup().attributes('state')).toBe('true');
              expect(findVulnerabilityDismissalReason().props('state')).toBe(true);
            });

            it('shows error and does not dismiss when dismissal reason or comment it not provided', async () => {
              findConfirmDismissalButton().vm.$emit('click');

              await waitForPromises();

              expect(mockDismissFindingMutation).not.toHaveBeenCalled();
              expect(findCommentFormGroup().attributes('state')).toBe(undefined);
              expect(findVulnerabilityDismissalReason().props('state')).toBe(false);
            });

            it('cancels commenting', async () => {
              expect(findDismissalEditSection().exists()).toBe(true);

              findCancelEditButton().vm.$emit('click');
              await nextTick();

              expect(findDismissalEditSection().exists()).toBe(false);
            });
          });
        });
      });

      describe('with existing feedback', () => {
        const TEST_DISMISSED_AT = '2022-10-16T22:42:02.975Z';
        const TEST_STATE_COMMENT = 'false positive';
        const TEST_DISMISSED_BY = {
          id: 1,
          name: 'Admin',
          username: 'admin',
          webUrl: 'http://gitlab.com/admin',
        };
        const TEST_DISMISSAL_REASON = 'MITIGATING_CONTROL';
        const TEST_PROJECT = {
          webUrl: 'http://gitlab.com/gitlab-org/security/gitlab',
          nameWithNamespace: 'GitLab/Security/GitLab',
        };

        beforeEach(async () => {
          createWrapper({
            responseHandlers: {
              securityReportFindingQuery: jest.fn().mockResolvedValue(
                getPipelineSecurityReportFindingResponse({
                  overrides: {
                    project: TEST_PROJECT,
                    state: STATE_DISMISSED,
                    dismissedAt: TEST_DISMISSED_AT,
                    stateComment: TEST_STATE_COMMENT,
                    dismissedBy: TEST_DISMISSED_BY,
                    dismissalReason: TEST_DISMISSAL_REASON,
                  },
                }),
              ),
            },
          });
          await waitForPromises();
        });

        it('renders dismissal notes', () => {
          expect(findDismissalNote().props()).toMatchObject({
            project: {
              url: TEST_PROJECT.webUrl,
              value: TEST_PROJECT.nameWithNamespace,
            },
            feedback: {
              created_at: TEST_DISMISSED_AT,
              comment_details: {
                comment_author: TEST_DISMISSED_BY,
                comment: TEST_STATE_COMMENT,
              },
              author: TEST_DISMISSED_BY,
              dismissalReason: TEST_DISMISSAL_REASON,
            },
          });
        });

        it('shows "cancel" and "save" buttons when editing the dismissal', async () => {
          expect(findCancelEditButton().exists()).toBe(false);
          expect(findConfirmDismissalButton().exists()).toBe(false);

          findDismissalNote().vm.$emit('editDismissal');
          await nextTick();

          expect(findCancelEditButton().exists()).toBe(true);
          expect(findConfirmDismissalButton().exists()).toBe(true);
        });

        it('allows the existing comment and dismissal reason to be edited', async () => {
          expect(findDismissalNote().props('isEditingDismissal')).toBe(false);

          findDismissalNote().vm.$emit('editDismissal');
          await nextTick();

          expect(findDismissalNote().props('isEditingDismissal')).toBe(true);
        });

        describe('with no dismissed by', () => {
          beforeEach(async () => {
            createWrapper({
              responseHandlers: {
                securityReportFindingQuery: jest.fn().mockResolvedValue(
                  getPipelineSecurityReportFindingResponse({
                    overrides: {
                      project: TEST_PROJECT,
                      state: STATE_DISMISSED,
                      dismissedAt: TEST_DISMISSED_AT,
                      stateComment: TEST_STATE_COMMENT,
                      dismissedBy: null,
                      dismissalReason: TEST_DISMISSAL_REASON,
                    },
                  }),
                ),
              },
            });
            await waitForPromises();
          });

          it('renders the dismissal notes without the author', () => {
            expect(findDismissalNote().props()).toMatchObject({
              project: {
                url: TEST_PROJECT.webUrl,
                value: TEST_PROJECT.nameWithNamespace,
              },
              feedback: {
                created_at: TEST_DISMISSED_AT,
                comment_details: {
                  comment_author: {},
                  comment: TEST_STATE_COMMENT,
                },
                author: {},
                dismissalReason: TEST_DISMISSAL_REASON,
              },
            });
          });
        });
      });
    });
  });

  describe('footer actions', () => {
    const findSplitButton = () => wrapper.findComponent(SplitButton);
    const findDownloadPatchButton = () => wrapper.findByTestId('download-patch-button');
    const findCreateMergeRequestButton = () => wrapper.findByTestId('create-merge-request-button');
    const emitSplitButtonEvent = (eventName) => {
      findSplitButton().vm.$emit(eventName);
      return nextTick();
    };

    describe('without remediations', () => {
      beforeEach(async () => {
        createWrapper({
          responseHandlers: {
            securityReportFindingQuery: jest.fn().mockResolvedValue(
              getPipelineSecurityReportFindingResponse({
                overrides: {
                  remediations: [],
                },
              }),
            ),
          },
        });
        await waitForPromises();
      });

      it('should not show the download patch button', () => {
        expect(findDownloadPatchButton().exists()).toBe(false);
      });

      it('should not show the create merge request button', () => {
        expect(findCreateMergeRequestButton().exists()).toBe(false);
      });
    });

    describe('with remediations', () => {
      const TEST_REMEDIATION = { diff: 'SGVsbG8gR2l0TGFi', summary: 'Upgrade libcurl' };

      describe('when finding is resolved', () => {
        beforeEach(async () => {
          createWrapper({
            responseHandlers: {
              securityReportFindingQuery: jest.fn().mockResolvedValue(
                getPipelineSecurityReportFindingResponse({
                  overrides: {
                    state: STATE_RESOLVED,
                    remediations: [TEST_REMEDIATION],
                  },
                }),
              ),
            },
          });
          await waitForPromises();
        });

        it('should not show the download patch button', () => {
          expect(findDownloadPatchButton().exists()).toBe(false);
        });

        it('should not show the create merge request button', () => {
          expect(findCreateMergeRequestButton().exists()).toBe(false);
        });
      });

      describe('when finding has an existing merge request', () => {
        beforeEach(async () => {
          createWrapper({
            responseHandlers: {
              securityReportFindingQuery: jest.fn().mockResolvedValue(
                getPipelineSecurityReportFindingResponse({
                  overrides: {
                    state: STATE_DETECTED,
                    mergeRequest: {
                      iid: '1',
                      webUrl: 'http://gitlab.com/merge-request',
                    },
                    remediations: [TEST_REMEDIATION],
                  },
                }),
              ),
            },
          });
          await waitForPromises();
        });

        it('should not show the download patch button', () => {
          expect(findDownloadPatchButton().exists()).toBe(false);
        });

        it('should not show the create merge request button', () => {
          expect(findCreateMergeRequestButton().exists()).toBe(false);
        });
      });

      describe('when the finding is unresolved an there is no existing merge request', () => {
        describe.each`
          hasDiff  | presentOnDefaultBranch | shouldShowDownloadPatch | shouldShowCreateMergeRequest
          ${true}  | ${true}                | ${true}                 | ${true}
          ${true}  | ${false}               | ${true}                 | ${false}
          ${false} | ${true}                | ${false}                | ${true}
          ${false} | ${false}               | ${false}                | ${false}
        `(
          'the finding has diff data is "$hasDiff" and is present on the default branch is "$presentOnDefaultBranch"',
          ({
            hasDiff,
            presentOnDefaultBranch,
            shouldShowDownloadPatch,
            shouldShowCreateMergeRequest,
          }) => {
            beforeEach(async () => {
              createWrapper({
                responseHandlers: {
                  securityReportFindingQuery: jest.fn().mockResolvedValue(
                    getPipelineSecurityReportFindingResponse({
                      overrides: {
                        state: STATE_DETECTED,
                        vulnerability: {
                          mergeRequest: null,
                          presentOnDefaultBranch,
                        },
                        remediations: [
                          {
                            diff: hasDiff ? TEST_REMEDIATION.diff : null,
                          },
                        ],
                      },
                    }),
                  ),
                },
              });

              await waitForPromises();
            });

            it(`${
              shouldShowDownloadPatch ? 'should' : 'should not'
            } render the download-patch button`, () => {
              expect(findDownloadPatchButton().exists()).toBe(shouldShowDownloadPatch);
            });

            it(`${
              shouldShowCreateMergeRequest ? 'should' : 'should not'
            } render the create-merge-request button`, () => {
              expect(findCreateMergeRequestButton().exists()).toBe(shouldShowCreateMergeRequest);
            });
          },
        );
      });

      describe('download patch button', () => {
        beforeEach(async () => {
          createWrapper({
            responseHandlers: {
              securityReportFindingQuery: jest.fn().mockResolvedValue(
                getPipelineSecurityReportFindingResponse({
                  overrides: {
                    vulnerability: {
                      mergeRequest: null,
                    },
                    remediations: [TEST_REMEDIATION],
                  },
                }),
              ),
            },
          });

          await waitForPromises();
        });

        it('should trigger a file-download with the remediation diff when the download button is clicked', () => {
          expect(download).not.toHaveBeenCalled();

          emitSplitButtonEvent('download-patch');

          expect(download).toHaveBeenCalledWith({
            fileData: TEST_REMEDIATION.diff,
            fileName: 'remediation.patch',
          });
        });
      });

      describe('create merge request', () => {
        const TEST_MERGE_REQUEST = { id: '1', iid: '1', webUrl: 'https://gitlab.com' };
        const createMergeRequestMutationHandler = jest.fn().mockResolvedValue({
          data: {
            securityFindingCreateMergeRequest: {
              errors: [],
              mergeRequest: TEST_MERGE_REQUEST,
            },
          },
        });

        describe('success', () => {
          beforeEach(async () => {
            createWrapper({
              responseHandlers: {
                createMergeRequestMutation: createMergeRequestMutationHandler,
                securityReportFindingQuery: jest.fn().mockResolvedValue(
                  getPipelineSecurityReportFindingResponse({
                    overrides: {
                      vulnerability: {
                        mergeRequest: null,
                      },
                      remediations: [TEST_REMEDIATION],
                    },
                  }),
                ),
              },
            });

            await waitForPromises();
          });

          it('should trigger a create merge request mutation when the button is clicked', () => {
            expect(createMergeRequestMutationHandler).not.toHaveBeenCalled();

            emitSplitButtonEvent('create-merge-request');

            expect(createMergeRequestMutationHandler).toHaveBeenCalledWith({
              uuid: pipelineSecurityReportFinding.uuid,
            });
          });

          it('should show a loading state when the mutation is in flight', async () => {
            expect(findSplitButton().props('loading')).toBe(false);

            await emitSplitButtonEvent('create-merge-request');

            expect(findSplitButton().props('loading')).toBe(true);
          });

          it('should redirect to the merge request when the mutation is successful', async () => {
            expect(visitUrl).not.toHaveBeenCalled();

            emitSplitButtonEvent('create-merge-request');
            await waitForPromises();

            expect(visitUrl).toHaveBeenCalledWith(TEST_MERGE_REQUEST.webUrl);
          });
        });

        describe('error', () => {
          beforeEach(async () => {
            createWrapper({
              responseHandlers: {
                createMergeRequestMutation: jest
                  .fn()
                  .mockRejectedValue(new Error('mutation failed')),
                securityReportFindingQuery: jest.fn().mockResolvedValue(
                  getPipelineSecurityReportFindingResponse({
                    overrides: {
                      vulnerability: {
                        mergeRequest: null,
                      },
                      remediations: [TEST_REMEDIATION],
                    },
                  }),
                ),
              },
            });

            await waitForPromises();
          });

          it('should show an error when the mutation fails', async () => {
            expect(findErrorAlert().exists()).toBe(false);

            emitSplitButtonEvent('create-merge-request');
            await waitForPromises();

            expect(findErrorAlert().exists()).toBe(true);
          });
        });
      });
    });

    describe('GitLab issue creation', () => {
      const findCreateIssueButton = () => wrapper.findByTestId('create-issue-button');
      const clickCreateIssueButton = () => {
        return findCreateIssueButton().vm.$emit('click');
      };

      describe.each`
        description                                                        | adminVulnerability | createIssue | hasExistingIssue | shouldShowCreateIssueButton
        ${'user has permissions and there is no existing issue'}           | ${true}            | ${true}     | ${false}         | ${true}
        ${'user has permissions and there is an existing issue'}           | ${true}            | ${true}     | ${true}          | ${false}
        ${'user is developer and there is no existing issue'}              | ${false}           | ${true}     | ${false}         | ${true}
        ${'user is developer and there is an existing issue'}              | ${false}           | ${true}     | ${true}          | ${false}
        ${'user does not have permissions and there is no existing issue'} | ${false}           | ${false}    | ${false}         | ${false}
        ${'user does not have permissions and there is an existing issue'} | ${false}           | ${false}    | ${true}          | ${false}
      `(
        'when the $description',
        ({ adminVulnerability, createIssue, hasExistingIssue, shouldShowCreateIssueButton }) => {
          beforeEach(async () => {
            createWrapper({
              responseHandlers: {
                securityReportFindingQuery: jest.fn().mockResolvedValue(
                  getPipelineSecurityReportFindingResponse({
                    overrides: {
                      vulnerability: null,
                      issueLinks: {
                        nodes: hasExistingIssue ? [TEST_ISSUE] : [],
                      },
                      userPermissions: {
                        adminVulnerability,
                        createIssue,
                      },
                    },
                  }),
                ),
              },
            });

            await waitForPromises();
          });

          it(`${
            shouldShowCreateIssueButton ? 'should' : 'should not'
          } show the "create issue" button`, () => {
            expect(findCreateIssueButton().exists()).toBe(shouldShowCreateIssueButton);
          });
        },
      );

      it('should show a loading state when the mutation is in flight', async () => {
        createWrapper();

        await waitForPromises();

        expect(findCreateIssueButton().props('loading')).toBe(false);

        await clickCreateIssueButton();

        expect(findCreateIssueButton().props('loading')).toBe(true);
      });

      it('should not show a loading state after the mutation fails', async () => {
        createWrapper({
          responseHandlers: {
            createIssueMutation: jest.fn().mockRejectedValue(new Error('mutation failed')),
          },
        });

        await waitForPromises();

        await clickCreateIssueButton();

        expect(findCreateIssueButton().props('loading')).toBe(true);
        await waitForPromises();

        expect(findCreateIssueButton().props('loading')).toBe(false);
      });

      describe.each`
        description               | withRemediations | createIssueEvent
        ${'with remediations'}    | ${true}          | ${() => emitSplitButtonEvent('create-issue')}
        ${'without remediations'} | ${false}         | ${clickCreateIssueButton}
      `('$description', ({ withRemediations, createIssueEvent }) => {
        const responseHandlers = {
          securityReportFindingQuery: jest.fn().mockResolvedValue(
            getPipelineSecurityReportFindingResponse({
              overrides: {
                vulnerability: {
                  mergeRequest: null,
                },
                remediations: withRemediations ? [{ diff: 'SGVsbG8gR2l0TGFi' }] : null,
              },
            }),
          ),
        };

        it('should show an error when the mutation fails', async () => {
          createWrapper({
            responseHandlers: {
              createIssueMutation: jest.fn().mockRejectedValue(new Error('mutation failed')),
              ...responseHandlers,
            },
          });
          await waitForPromises();

          expect(findErrorAlert().exists()).toBe(false);

          createIssueEvent();
          await waitForPromises();

          expect(findErrorAlert().exists()).toBe(true);
        });

        it('should create a new issue and redirect to it when the mutation is successful', async () => {
          const createIssueMutationHandler = jest
            .fn()
            .mockResolvedValue(securityFindingCreateIssueMutationResponse);

          createWrapper({
            responseHandlers: {
              createIssueMutation: createIssueMutationHandler,
              ...responseHandlers,
            },
          });
          await waitForPromises();

          expect(visitUrl).not.toHaveBeenCalled();
          expect(createIssueMutationHandler).not.toHaveBeenCalled();

          await createIssueEvent();
          await waitForPromises();

          expect(createIssueMutationHandler).toHaveBeenCalledWith({
            findingUuid: pipelineSecurityReportFinding.uuid,
            projectId: pipelineSecurityReportFinding.project.id,
          });
          expect(visitUrl).toHaveBeenNthCalledWith(
            1,
            securityFindingCreateIssueMutationResponse.data.securityFindingCreateIssue.issue.webUrl,
          );
        });
      });
    });

    describe('Jira issue creation', () => {
      let createExternalIssueMutationHandler;

      const findCreateJiraIssueButton = () => wrapper.findByTestId('create-jira-issue-button');
      const clickCreateJiraIssueButton = () => {
        findCreateJiraIssueButton().vm.$emit('click');
        return nextTick();
      };

      describe('with Jira integration disabled', () => {
        beforeEach(async () => {
          createWrapper();
          await waitForPromises();
        });

        it('should not show the "create jira issue" button', () => {
          expect(findCreateJiraIssueButton().exists()).toBe(false);
        });
      });

      describe('with Jira integration enabled', () => {
        describe('with an existing Jira issue', () => {
          beforeEach(async () => {
            createWrapper({
              responseHandlers: {
                securityReportFindingQuery: jest.fn().mockResolvedValue(
                  getPipelineSecurityReportFindingResponse({
                    overrides: {
                      issueLinks: {
                        nodes: [{ issueType: 'CREATED', externalIssue: { title: 'JIRA-123' } }],
                      },
                    },
                  }),
                ),
              },
            });
            await waitForPromises();
          });

          it('should not show the "create jira issue" button', () => {
            expect(findCreateJiraIssueButton().exists()).toBe(false);
          });
        });

        describe('success', () => {
          beforeEach(async () => {
            createExternalIssueMutationHandler = jest
              .fn()
              .mockResolvedValue(securityFindingCreateExternalIssueMutationResponse);

            createWrapper({
              responseHandlers: {
                createExternalIssueMutation: createExternalIssueMutationHandler,
                securityReportFindingQuery: jest.fn().mockResolvedValue(
                  getPipelineSecurityReportFindingResponse({
                    overrides: {
                      project: {
                        hasJiraVulnerabilityIssueCreationEnabled: true,
                      },
                    },
                  }),
                ),
              },
            });
            await waitForPromises();
          });

          it('should show a loading state when the mutation is in flight', async () => {
            createWrapper({
              responseHandlers: {
                createExternalIssueMutation: createExternalIssueMutationHandler,
                securityReportFindingQuery: jest.fn().mockResolvedValue(
                  getPipelineSecurityReportFindingResponse({
                    overrides: {
                      project: {
                        hasJiraVulnerabilityIssueCreationEnabled: true,
                      },
                    },
                  }),
                ),
              },
            });

            await waitForPromises();

            expect(findCreateJiraIssueButton().props('loading')).toBe(false);

            await clickCreateJiraIssueButton();

            expect(findCreateJiraIssueButton().props('loading')).toBe(true);
          });

          describe.each`
            description               | withRemediations | createIssueEvent
            ${'with remediations'}    | ${true}          | ${() => emitSplitButtonEvent('create-jira-issue')}
            ${'without remediations'} | ${false}         | ${clickCreateJiraIssueButton}
          `('$description', ({ withRemediations, createIssueEvent }) => {
            beforeEach(async () => {
              createExternalIssueMutationHandler = jest
                .fn()
                .mockResolvedValue(securityFindingCreateExternalIssueMutationResponse);

              createWrapper({
                responseHandlers: {
                  createExternalIssueMutation: createExternalIssueMutationHandler,
                  securityReportFindingQuery: jest.fn().mockResolvedValue(
                    getPipelineSecurityReportFindingResponse({
                      overrides: {
                        project: {
                          hasJiraVulnerabilityIssueCreationEnabled: true,
                        },
                        vulnerability: {
                          mergeRequest: null,
                        },
                        remediations: withRemediations ? [{ diff: 'SGVsbG8gR2l0TGFi' }] : null,
                      },
                    }),
                  ),
                },
              });
              await waitForPromises();
            });

            it('should call the mutation when the button is clicked', async () => {
              expect(createExternalIssueMutationHandler).not.toHaveBeenCalled();

              await createIssueEvent();

              expect(createExternalIssueMutationHandler).toHaveBeenCalledWith({
                vulnerabilityId: pipelineSecurityReportFinding.vulnerability.id,
              });
            });

            it('should redirect to the new issue when the mutation is successful', async () => {
              expect(visitUrl).not.toHaveBeenCalled();

              await createIssueEvent();
              await nextTick();
              await waitForPromises();

              expect(visitUrl).toHaveBeenCalledWith('https://jira.com/1', true);
            });
          });
        });

        describe('error', () => {
          beforeEach(async () => {
            createWrapper({
              responseHandlers: {
                createExternalIssueMutation: jest
                  .fn()
                  .mockRejectedValue(new Error('mutation failed')),
                securityReportFindingQuery: jest.fn().mockResolvedValue(
                  getPipelineSecurityReportFindingResponse({
                    overrides: {
                      project: {
                        hasJiraVulnerabilityIssueCreationEnabled: true,
                      },
                    },
                  }),
                ),
              },
            });
            await waitForPromises();
          });

          it('should show an error when the mutation fails', async () => {
            expect(findErrorAlert().exists()).toBe(false);

            await clickCreateJiraIssueButton();
            expect(findCreateJiraIssueButton().props('loading')).toBe(true);
            await waitForPromises();

            expect(findErrorAlert().text()).toBe(
              'There was an error creating a Jira issue for the finding. Please try again.',
            );
            expect(findCreateJiraIssueButton().props('loading')).toBe(false);
          });
        });

        describe('polling', () => {
          const advanceToNextFetch = (milliseconds) => {
            jest.advanceTimersByTime(milliseconds);
          };

          describe('success', () => {
            beforeEach(async () => {
              const vulnerabilityQueryHandler = jest
                .fn()
                .mockResolvedValueOnce(
                  getVulnerabilityExternalIssuesQueryResponse({ externalIssues: [] }),
                )
                .mockResolvedValue(getVulnerabilityExternalIssuesQueryResponse());

              createWrapper({
                responseHandlers: {
                  vulnerabilityExternalIssuesQuery: vulnerabilityQueryHandler,
                  securityReportFindingQuery: jest.fn().mockResolvedValue(
                    getPipelineSecurityReportFindingResponse({
                      overrides: {
                        project: {
                          hasJiraVulnerabilityIssueCreationEnabled: true,
                        },
                      },
                    }),
                  ),
                },
              });
              await waitForPromises();
            });

            it('should poll the mutation until the issue is created', async () => {
              await clickCreateJiraIssueButton();
              await waitForPromises();

              expect(findCreateJiraIssueButton().props('loading')).toBe(true);
              expect(visitUrl).not.toHaveBeenCalled();

              advanceToNextFetch(VULNERABILITY_POLLING_INTERVAL);
              await waitForPromises();

              expect(findCreateJiraIssueButton().props('loading')).toBe(false);
              expect(visitUrl).toHaveBeenCalledWith('https://jira.com/1', true);
            });
          });

          describe('error', () => {
            beforeEach(async () => {
              const vulnerabilityQueryHandler = jest
                .fn()
                .mockResolvedValueOnce(
                  getVulnerabilityExternalIssuesQueryResponse({
                    externalIssues: [],
                  }),
                )
                .mockRejectedValue(new Error('query failed'));

              createWrapper({
                responseHandlers: {
                  vulnerabilityExternalIssuesQuery: vulnerabilityQueryHandler,
                  securityReportFindingQuery: jest.fn().mockResolvedValue(
                    getPipelineSecurityReportFindingResponse({
                      overrides: {
                        project: {
                          hasJiraVulnerabilityIssueCreationEnabled: true,
                        },
                      },
                    }),
                  ),
                },
              });
              await waitForPromises();
            });

            it('should stop the loading indicator and render an error message', async () => {
              await clickCreateJiraIssueButton();
              await waitForPromises();

              expect(findErrorAlert().exists()).toBe(false);
              expect(findCreateJiraIssueButton().props('loading')).toBe(true);

              advanceToNextFetch(VULNERABILITY_POLLING_INTERVAL);
              await waitForPromises();

              expect(findCreateJiraIssueButton().props('loading')).toBe(false);
              expect(findErrorAlert().text()).toBe(
                'There was an error creating a Jira issue for the finding. Please try again.',
              );
            });
          });
        });
      });
    });

    describe('can admin vulnerability', () => {
      it.each`
        adminVulnerability | state              | dismissButtonShown | undoDismissButtonShown
        ${true}            | ${STATE_DETECTED}  | ${true}            | ${false}
        ${false}           | ${STATE_DETECTED}  | ${false}           | ${false}
        ${true}            | ${STATE_DISMISSED} | ${false}           | ${true}
        ${false}           | ${STATE_DISMISSED} | ${false}           | ${false}
      `(
        'shows/hides the dismiss/revert button when adminVulnerability = $adminVulnerability and finding state = $state',
        async ({ adminVulnerability, state, dismissButtonShown, undoDismissButtonShown }) => {
          const responseData = getPipelineSecurityReportFindingResponse({
            overrides: { state, userPermissions: { adminVulnerability } },
          });
          const responseHandlers = {
            securityReportFindingQuery: jest.fn().mockResolvedValue(responseData),
          };

          createWrapper({ responseHandlers });
          await waitForPromises();

          expect(findDismissButton().exists()).toBe(dismissButtonShown);
          expect(findUndoDismissButton().exists()).toBe(undoDismissButtonShown);
        },
      );
    });

    describe('resolve with AI', () => {
      const findResolveWithAIButton = () => wrapper.findComponent(ResolveWithAiButton);

      it.each`
        glAbilities                              | graphQLFinding                    | shouldShowResolveWithAIButton
        ${{ resolveVulnerabilityWithAi: true }}  | ${{ aiResolutionEnabled: true }}  | ${true}
        ${{ resolveVulnerabilityWithAi: true }}  | ${{ aiResolutionEnabled: false }} | ${false}
        ${{ resolveVulnerabilityWithAi: false }} | ${{ aiResolutionEnabled: true }}  | ${false}
      `(
        'shows the "Resolve with AI" button: "$shouldShowResolveWithAIButton"',
        async ({ glAbilities, graphQLFinding, shouldShowResolveWithAIButton }) => {
          createWrapper({
            responseHandlers: {
              securityReportFindingQuery: jest.fn().mockResolvedValue(
                getPipelineSecurityReportFindingResponse({
                  overrides: {
                    ...graphQLFinding,
                  },
                }),
              ),
            },
            provide: {
              glAbilities,
            },
          });

          await waitForPromises();

          expect(findResolveWithAIButton().exists()).toBe(shouldShowResolveWithAIButton);
        },
      );

      describe('when the "Resolve with AI" button is visible', () => {
        const createWrapperWithAiResolutionEnabled = async ({
          projectVisibility = 'private',
        } = {}) => {
          createWrapper({
            responseHandlers: {
              securityReportFindingQuery: jest.fn().mockResolvedValue(
                getPipelineSecurityReportFindingResponse({
                  overrides: {
                    project: {
                      visibility: projectVisibility,
                    },
                  },
                }),
              ),
            },
            provide: {
              glAbilities: { resolveVulnerabilityWithAi: true },
            },
          });

          await waitForPromises();
        };

        it.each`
          projectVisibility | shouldShowPublicProjectWarning
          ${'public'}       | ${true}
          ${'private'}      | ${false}
          ${'internal'}     | ${false}
        `(
          'should show the public-project warning: "$shouldShowPublicProjectWarning" when the project-visibility is "$projectVisibility"',
          async ({ projectVisibility, shouldShowPublicProjectWarning }) => {
            await createWrapperWithAiResolutionEnabled({
              projectVisibility,
            });

            expect(findResolveWithAIButton().props()).toMatchObject({
              vulnerabilityId: pipelineSecurityReportFinding.vulnerability.id,
              findingUuid: TEST_FINDING.uuid,
              mergeRequestId: TEST_MERGE_REQUEST_ID,
              showPublicProjectWarning: shouldShowPublicProjectWarning,
            });
          },
        );

        it('emits "resolveWithAiSuccess" the modal when the "success" event is emitted', async () => {
          await createWrapperWithAiResolutionEnabled();

          expect(wrapper.emitted('resolveWithAiSuccess')).toBeUndefined();

          findResolveWithAIButton().vm.$emit('success');

          expect(wrapper.emitted('resolveWithAiSuccess')).toHaveLength(1);
        });

        it('shows the error alert when the "error" event is emitted', async () => {
          await createWrapperWithAiResolutionEnabled();

          expect(findErrorAlert().exists()).toBe(false);

          const errorMessage = 'An unexpected error occured';
          findResolveWithAIButton().vm.$emit('error', errorMessage);
          await nextTick();

          expect(findErrorAlert().text()).toBe(errorMessage);
        });

        it('resets the error alert when "resolveStart" event is emitted', async () => {
          await createWrapperWithAiResolutionEnabled();

          findResolveWithAIButton().vm.$emit('error', 'An unexpected error occured');
          await nextTick();

          expect(findErrorAlert().exists()).toBe(true);

          findResolveWithAIButton().vm.$emit('resolveStart');
          await nextTick();

          expect(findErrorAlert().exists()).toBe(false);
        });
      });
    });
  });
});
