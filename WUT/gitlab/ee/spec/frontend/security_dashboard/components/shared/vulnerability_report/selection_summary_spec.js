import { GlLink, GlAlert, GlCollapsibleListbox, GlSprintf } from '@gitlab/ui';
import { nextTick } from 'vue';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import {
  DASHBOARD_TYPE_GROUP,
  DASHBOARD_TYPE_PROJECT,
  DASHBOARD_TYPE_INSTANCE,
  DASHBOARD_TYPE_PIPELINE,
} from 'ee/security_dashboard/constants';
import SelectionSummary from 'ee/security_dashboard/components/shared/vulnerability_report/selection_summary.vue';
import BulkChangeStatus from 'ee/security_dashboard/components/shared/vulnerability_report/bulk_change_status.vue';
import AttachExistingIssue from 'ee/security_dashboard/components/shared/vulnerability_report/attach_existing_issue.vue';
import BulkChangeSeverity from 'ee/security_dashboard/components/shared/vulnerability_report/bulk_change_severity.vue';
import AttachNewIssue from 'ee/security_dashboard/components/shared/vulnerability_report/attach_new_issue.vue';

const mockVulnerabilities = {
  single: [{ id: 'gid://gitlab/Vulnerability/54' }],
  multiple: [
    { id: 'gid://gitlab/Vulnerability/54' },
    { id: 'gid://gitlab/Vulnerability/56' },
    { id: 'gid://gitlab/Vulnerability/58' },
  ],
  rejected: [{ id: 'gid://gitlab/Vulnerability/54' }, { id: 'gid://gitlab/Vulnerability/56' }],
};

describe('Selection Summary component', () => {
  let wrapper;

  const findGlAlert = () => wrapper.findComponent(GlAlert);
  const findSelectedVulnerabilities = () => wrapper.findByTestId('selected-vulnerabilities');
  const findActionListbox = () => wrapper.findComponent(GlCollapsibleListbox);
  const findBulkChangeStatus = () => wrapper.findComponent(BulkChangeStatus);
  const findAttachExistingIssue = () => wrapper.findComponent(AttachExistingIssue);
  const findBulkChangeSeverity = () => wrapper.findComponent(BulkChangeSeverity);
  const findAttachNewIssue = () => wrapper.findComponent(AttachNewIssue);

  const selectAction = async (action) => {
    findActionListbox().vm.$emit('select', action);
    await nextTick();
  };

  const createComponent = ({
    selectedVulnerabilities = [],
    dashboardType = DASHBOARD_TYPE_PROJECT,
    enhancedVulnerabilityBulkActions = true,
    hideVulnerabilitySeverityOverride = false,
    newIssueAttachmentFromVulnerabilityBulkAction = true,
  } = {}) => {
    wrapper = shallowMountExtended(SelectionSummary, {
      stubs: {
        GlAlert,
        GlSprintf,
        GlLink,
      },
      propsData: {
        selectedVulnerabilities,
      },
      provide: {
        glFeatures: {
          enhancedVulnerabilityBulkActions,
          hideVulnerabilitySeverityOverride,
          newIssueAttachmentFromVulnerabilityBulkAction,
        },
        dashboardType,
      },
    });
  };

  describe('with 1 vulnerability selected', () => {
    beforeEach(() => {
      createComponent({ selectedVulnerabilities: mockVulnerabilities.single });
    });

    it('displays correct selection count', () => {
      expect(findSelectedVulnerabilities().text()).toBe('1 Selected');
    });

    it('shows action listbox with correct options', () => {
      expect(findActionListbox().exists()).toBe(true);
      expect(findActionListbox().props('items')).toEqual([
        { value: 'status', text: 'Change status' },
        { value: 'severity', text: 'Change severity' },
        { value: 'attach_existing', text: 'Attach to existing issue' },
        { value: 'attach_new', text: 'Attach to new issue' },
      ]);
    });

    it('hides all bulk action sub components initially', () => {
      expect(findBulkChangeStatus().exists()).toBe(false);
      expect(findBulkChangeSeverity().exists()).toBe(false);
      expect(findAttachExistingIssue().exists()).toBe(false);
      expect(findAttachNewIssue().exists()).toBe(false);
    });
  });

  describe('with multiple vulnerabilities selected', () => {
    beforeEach(() => {
      createComponent({ selectedVulnerabilities: mockVulnerabilities.multiple });
    });

    it('displays correct selection count', () => {
      expect(findSelectedVulnerabilities().text()).toBe('3 Selected');
    });
  });

  describe('bulk status changes', () => {
    beforeEach(() => {
      createComponent({ selectedVulnerabilities: mockVulnerabilities.single });
      selectAction('status');
    });

    it('shows bulk change status component after selecting status action', () => {
      expect(findAttachExistingIssue().exists()).toBe(false);
      expect(findAttachNewIssue().exists()).toBe(false);
      expect(findBulkChangeSeverity().exists()).toBe(false);
      expect(findBulkChangeStatus().exists()).toBe(true);
      expect(findBulkChangeStatus().props()).toEqual({
        selectedVulnerabilities: mockVulnerabilities.single,
      });
    });

    it('emits vulnerabilities-updated event correctly', () => {
      const updatedVulnerabilities = [1];
      findBulkChangeStatus().vm.$emit('vulnerabilities-updated', updatedVulnerabilities);
      expect(wrapper.emitted('vulnerabilities-updated')).toEqual([[updatedVulnerabilities]]);
    });
  });

  describe('bulk severity changes', () => {
    beforeEach(() => {
      createComponent({ selectedVulnerabilities: mockVulnerabilities.single });
      selectAction('severity');
    });

    it('shows bulk change severity component after selecting severity action', () => {
      expect(findAttachExistingIssue().exists()).toBe(false);
      expect(findAttachNewIssue().exists()).toBe(false);
      expect(findBulkChangeStatus().exists()).toBe(false);
      expect(findBulkChangeSeverity().exists()).toBe(true);
      expect(findBulkChangeSeverity().props()).toEqual({
        selectedVulnerabilities: mockVulnerabilities.single,
      });
    });

    it('emits vulnerabilities-updated event correctly', () => {
      const updatedVulnerabilities = [1];
      findBulkChangeSeverity().vm.$emit('vulnerabilities-updated', updatedVulnerabilities);
      expect(wrapper.emitted('vulnerabilities-updated')).toEqual([[updatedVulnerabilities]]);
    });
  });

  describe('attach existing issue', () => {
    beforeEach(() => {
      createComponent({ selectedVulnerabilities: mockVulnerabilities.single });
      selectAction('attach_existing');
    });

    it('shows attach existing issue component after selecting "attach_existing" action', () => {
      expect(findBulkChangeStatus().exists()).toBe(false);
      expect(findBulkChangeSeverity().exists()).toBe(false);
      expect(findAttachNewIssue().exists()).toBe(false);
      expect(findAttachExistingIssue().exists()).toBe(true);
      expect(findAttachExistingIssue().props()).toEqual({
        selectedVulnerabilities: mockVulnerabilities.single,
      });
    });

    it('emits vulnerabilities-updated event correctly', () => {
      const updatedVulnerabilities = [1];
      findAttachExistingIssue().vm.$emit('vulnerabilities-updated', updatedVulnerabilities);
      expect(wrapper.emitted('vulnerabilities-updated')).toEqual([[updatedVulnerabilities]]);
    });
  });

  describe.each`
    action               | findFn
    ${'status'}          | ${findBulkChangeStatus}
    ${'severity'}        | ${findBulkChangeSeverity}
    ${'attach_existing'} | ${findAttachExistingIssue}
    ${'attach_new'}      | ${findAttachNewIssue}
  `('rejected vulnerabilities handling for $action', ({ action, findFn }) => {
    beforeEach(() => {
      createComponent({ selectedVulnerabilities: mockVulnerabilities.multiple });
      selectAction(action);
    });

    it('displays alert with rejected vulnerability IDs', async () => {
      findFn().vm.$emit('update-rejected', mockVulnerabilities.rejected);
      await nextTick();
      expect(findGlAlert().text()).toMatchInterpolatedText(
        'Failed updating vulnerabilities with the following IDs: 54, 56',
      );
    });

    it('clears alert and emits cancel event when cancelled', async () => {
      findFn().vm.$emit('update-rejected', mockVulnerabilities.rejected);
      findFn().vm.$emit('cancel');
      await nextTick();

      expect(findGlAlert().exists()).toBe(false);
      expect(wrapper.emitted('cancel-selection')).toHaveLength(1);
    });

    it(`clears alert when 'clear-rejected' event is emitted`, async () => {
      findFn().vm.$emit('update-rejected', mockVulnerabilities.rejected);
      await nextTick();
      expect(findGlAlert().exists()).toBe(true);
      findFn().vm.$emit('clear-rejected');
      await nextTick();
      expect(findGlAlert().exists()).toBe(false);
    });
  });

  describe('with hideVulnerabilitySeverityOverride disabled', () => {
    beforeEach(() => {
      createComponent({
        selectedVulnerabilities: mockVulnerabilities.single,
        hideVulnerabilitySeverityOverride: true,
      });
    });

    it('does not render `Change severity` action in listbox', () => {
      expect(findActionListbox().props('items')).toEqual([
        { value: 'status', text: 'Change status' },
        { value: 'attach_existing', text: 'Attach to existing issue' },
        { value: 'attach_new', text: 'Attach to new issue' },
      ]);
    });
  });

  describe.each`
    dashboardType              | expectedAttachExisting | expectedAttachNew
    ${DASHBOARD_TYPE_PROJECT}  | ${true}                | ${true}
    ${DASHBOARD_TYPE_GROUP}    | ${true}                | ${true}
    ${DASHBOARD_TYPE_INSTANCE} | ${false}               | ${false}
    ${DASHBOARD_TYPE_PIPELINE} | ${false}               | ${false}
  `(
    `when dashboardType is $dashboardType`,
    ({ dashboardType, expectedAttachExisting, expectedAttachNew }) => {
      const includesAction = (action) => {
        const actionListbox = findActionListbox();
        if (!actionListbox.exists()) {
          return false;
        }
        const items = actionListbox.props('items');
        if (!Array.isArray(items)) {
          return false;
        }
        return items.map((a) => a.value).includes(action);
      };

      beforeEach(() => {
        createComponent({
          selectedVulnerabilities: mockVulnerabilities.single,
          dashboardType,
        });
      });

      it(`${expectedAttachExisting ? 'shows' : 'does not show'} the attach to existing issue action`, () => {
        expect(includesAction('attach_existing')).toBe(expectedAttachExisting);
      });

      it(`${expectedAttachNew ? 'shows' : 'does not show'} the attach to new issue action`, () => {
        expect(includesAction('attach_new')).toBe(expectedAttachNew);
      });
    },
  );
});
