import Vue, { nextTick } from 'vue';
import { GlCollapsibleListbox, GlFormGroup } from '@gitlab/ui';
import VueApollo from 'vue-apollo';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import SelectProjectDropdown from 'ee/security_dashboard/components/shared/vulnerability_report/select_project_dropdown.vue';
import createMockApollo from 'helpers/mock_apollo_helper';
import getGroupProjects from 'ee/security_dashboard/graphql/queries/get_group_projects.query.graphql';
import waitForPromises from 'helpers/wait_for_promises';

describe('SelectProjectDropdown component', () => {
  const defaultFullPath = 'gitlab-org';

  const defaultNodes = [
    { id: '1', name: 'project-1', __typename: 'Project' },
    { id: '2', name: 'project-2', __typename: 'Project' },
  ];

  const defaultPageInfo = {
    __typename: 'PageInfo',
    hasNextPage: false,
    hasPreviousPage: false,
    startCursor: null,
    endCursor: 'end-cursor',
  };

  let wrapper;
  let requestHandler;

  const createResponseData = (nodes, hasNextPage = false) => ({
    data: {
      group: {
        id: '2',
        projects: {
          nodes,
          pageInfo: { ...defaultPageInfo, hasNextPage },
          __typename: 'ProjectConnection',
        },
        __typename: 'Group',
      },
    },
  });
  const mockApolloHandlers = (nodes = defaultNodes, hasNextPage = false) => {
    return jest.fn().mockResolvedValue(createResponseData(nodes, hasNextPage));
  };

  const createMockApolloProvider = (handler) => {
    Vue.use(VueApollo);

    requestHandler = handler;
    return createMockApollo([[getGroupProjects, requestHandler]]);
  };

  const findDropdown = () => wrapper.findComponent(GlCollapsibleListbox);
  const findFormGroup = () => wrapper.findComponent(GlFormGroup);
  const selectProjectById = (id) => findDropdown(id).vm.$emit('select', id);

  const createComponent = ({ handler = mockApolloHandlers(), props = {} } = {}) => {
    wrapper = shallowMountExtended(SelectProjectDropdown, {
      apolloProvider: createMockApolloProvider(handler),
      provide: {
        fullPath: defaultFullPath,
      },
      propsData: {
        valid: true,
        ...props,
      },
      stubs: { GlCollapsibleListbox },
    });
  };

  describe('default', () => {
    beforeEach(async () => {
      createComponent();
      await waitForPromises();
    });

    it('renders dropdown and form group', () => {
      expect(findDropdown().exists()).toBe(true);
      expect(findDropdown().props()).toMatchObject({ variant: 'default', category: 'primary' });
      expect(findDropdown().attributes('aria-invalid')).toBeUndefined();
      expect(findFormGroup().exists()).toBe(true);
      expect(findFormGroup().attributes('state')).toBe('true');
    });

    it('shows placeholder toggle text', () => {
      expect(findDropdown().props('toggleText')).toBe('Select project');
    });

    it('calls group projects query', () => {
      expect(requestHandler).toHaveBeenCalledWith({
        fullPath: defaultFullPath,
        search: '',
      });
    });

    it('sets correct items', () => {
      expect(findDropdown().props('items')).toMatchObject(
        defaultNodes.map((node) => ({ value: node.id, text: node.name })),
      );
    });
  });

  describe('when valid is `false`', () => {
    beforeEach(() => {
      createComponent({ props: { valid: false } });
    });

    it('sets state correctly for form group', () => {
      expect(findFormGroup().attributes('state')).toBeUndefined();
    });

    it('sets props correctly for dropdown', () => {
      expect(findDropdown().props()).toMatchObject({ variant: 'danger', category: 'secondary' });
      expect(findDropdown().attributes('aria-invalid')).toBe('true');
    });
  });

  describe('when value is set', () => {
    beforeEach(async () => {
      createComponent({ props: { value: '2' } });
      await waitForPromises();
    });

    it('sets correct toggle text', () => {
      expect(findDropdown().props('toggleText')).toBe('project-2');
    });

    it('sets "selected" correctly on the dropdown', () => {
      expect(findDropdown().props('selected')).toBe('2');
    });
  });

  describe('when selecting a project', () => {
    const projectId = '2';

    beforeEach(async () => {
      createComponent();
      await waitForPromises();
      selectProjectById(projectId);
    });

    it('emits "input" event', () => {
      expect(wrapper.emitted('input')).toMatchObject([[projectId]]);
    });
  });

  describe('when there is only one page of projects', () => {
    it('sets `infinite-scroll` to `false`', async () => {
      createComponent();
      await waitForPromises();

      expect(findDropdown().props('infiniteScroll')).toBe(false);
    });
  });

  describe('when there is more than a page of projects', () => {
    beforeEach(async () => {
      createComponent({ handler: mockApolloHandlers(defaultNodes, true) });
      await waitForPromises();
    });

    it('sets `infinite-scroll` to `true`', () => {
      expect(findDropdown().props('infiniteScroll')).toBe(true);
    });

    describe('when the "bottom-reached" event is called', () => {
      beforeEach(async () => {
        createComponent({ handler: mockApolloHandlers([], true) });
        await waitForPromises();
      });

      it('makes a query to fetch more projects', () => {
        findDropdown().vm.$emit('bottom-reached');
        expect(requestHandler).toHaveBeenCalledWith({
          fullPath: defaultFullPath,
          after: 'end-cursor',
          search: '',
        });
      });
    });

    describe('when a query is loading a new page of projects', () => {
      it('renders the loading spinner', async () => {
        createComponent({ handler: mockApolloHandlers([], true) });
        await waitForPromises();

        findDropdown().vm.$emit('bottom-reached');
        await nextTick();

        expect(findDropdown().props('loading')).toBe(true);
      });
    });
  });

  describe('when searching', () => {
    const searchNodes = [
      { id: '3', name: 'project-test-3', __typename: 'Project' },
      { id: '4', name: 'project-test-4', __typename: 'Project' },
    ];
    const searchTermWithSpace = ' project-test ';

    beforeEach(async () => {
      const searchHandler = jest
        .fn()
        .mockResolvedValueOnce(createResponseData(defaultNodes))
        .mockResolvedValueOnce(createResponseData(searchNodes));
      createComponent({ handler: searchHandler });
      await waitForPromises();
    });

    it('send `search` to query', async () => {
      findDropdown().vm.$emit('search', searchTermWithSpace);
      await waitForPromises();

      expect(requestHandler).toHaveBeenNthCalledWith(2, {
        fullPath: defaultFullPath,
        search: 'project-test',
      });
    });

    it('sets `searching` prop', async () => {
      findDropdown().vm.$emit('search', searchTermWithSpace);
      await nextTick();
      expect(findDropdown().props('searching')).toBe(true);
      expect(findDropdown().props('loading')).toBe(false);
      await waitForPromises();
      expect(findDropdown().props('searching')).toBe(false);
    });

    it('only show items matching `searchTerm`', async () => {
      findDropdown().vm.$emit('search', searchTermWithSpace);
      await waitForPromises();

      expect(
        findDropdown()
          .props('items')
          .map((item) => item.text),
      ).toEqual(['project-test-3', 'project-test-4']);
    });
  });
});
