import { GlCollapsibleListbox, GlFormInput, GlFormGroup } from '@gitlab/ui';
import Vue from 'vue';
import VueApollo from 'vue-apollo';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import BulkChangeSeverity from 'ee/security_dashboard/components/shared/vulnerability_report/bulk_change_severity.vue';
import { SEVERITY_LEVELS } from 'ee/security_dashboard/constants';
import { SEVERITY_CLASS_NAME_MAP } from 'ee/vue_shared/security_reports/components/constants';
import vulnerabilitiesSeverityOverride from 'ee/security_dashboard/graphql/mutations/vulnerabilities_severity_override.mutation.graphql';
import projectVulnerabilitiesQuery from 'ee/security_dashboard/graphql/queries/project_vulnerabilities.query.graphql';
import countsQuery from 'ee/security_dashboard/graphql/queries/vulnerability_severities_count.query.graphql';
import createMockApollo from 'helpers/mock_apollo_helper';
import waitForPromises from 'helpers/wait_for_promises';
import toast from '~/vue_shared/plugins/global_toast';
import * as Sentry from '~/sentry/sentry_browser_wrapper';

jest.mock('~/sentry/sentry_browser_wrapper');
jest.mock('~/vue_shared/plugins/global_toast');
Vue.use(VueApollo);

const mockVulnerabilitiesSeverityOverrideQueryResponse = {
  data: {
    vulnerabilitiesSeverityOverride: {
      errors: [],
      vulnerabilities: [
        {
          id: 'gid://gitlab/Vulnerability/111',
          severity: 'LOW',
          comment: 'test comment',
        },
      ],
    },
  },
};

describe('Bulk Change severity component', () => {
  let wrapper;

  const createApolloProvider = (...queries) => {
    return createMockApollo([...queries]);
  };

  const findForm = () => wrapper.find('form');
  const findSeverityFormGroup = () => wrapper.findByTestId('severity-form-group');
  const findSeverityListbox = () => wrapper.findByTestId('severity-listbox');
  const findListboxItem = (id) => wrapper.findByTestId(`listbox-item-${id}`);
  const findCommentFormGroup = () => wrapper.findByTestId('comment-form-group');
  const findCommentFormInput = () => wrapper.findComponent(GlFormInput);
  const findCancelButton = () => wrapper.findByTestId('cancel-button');
  const findSubmitButton = () => wrapper.find('[type="submit"]');
  const findIcon = (id) => wrapper.findByTestId(`severity-icon-${id}`);

  const selectSeverity = (severity) => {
    return findSeverityListbox().vm.$emit('select', severity);
  };

  const addComment = (comment) => {
    return findCommentFormInput().vm.$emit('input', comment);
  };

  const submitForm = async ({ state, comment } = {}) => {
    if (state) {
      await selectSeverity(state);
    }
    if (comment) {
      await addComment(comment);
    }
    return findForm().trigger('submit');
  };

  const createComponent = (
    { selectedVulnerabilities = [] } = {},
    apolloProvider,
    { vulnerabilitiesQuery, vulnerabilitiesCountsQuery } = {},
  ) => {
    wrapper = shallowMountExtended(BulkChangeSeverity, {
      stubs: {
        GlCollapsibleListbox,
        GlFormGroup,
      },
      propsData: {
        selectedVulnerabilities,
      },
      provide: {
        vulnerabilitiesQuery,
        vulnerabilitiesCountsQuery,
      },
      apolloProvider,
    });
  };

  beforeEach(() => {
    createComponent();
  });

  it('renders correctly', () => {
    expect(findSeverityListbox().exists()).toBe(true);
    expect(findCommentFormGroup().exists()).toBe(true);
    expect(findCancelButton().exists()).toBe(true);
    expect(findSubmitButton().exists()).toBe(true);
    expect(findSubmitButton().attributes('disabled')).toBeUndefined();
    expect(findSubmitButton().classes('js-no-auto-disable')).toBe(true);
  });

  describe('severity listbox', () => {
    it('shows the placeholder text when no severity is selected', () => {
      expect(findSeverityListbox().props('toggleText')).toBe('Select severity');
    });

    it('shows expected items', () => {
      const states = Object.keys(SEVERITY_LEVELS);
      expect(findSeverityListbox().props('items')).toHaveLength(states.length);

      states.forEach((state) => {
        const itemText = findListboxItem(state).text();
        expect(itemText).toBe(itemText);
      });
    });

    it.each(Object.entries(SEVERITY_LEVELS))(
      'shows the expected text in the listbox button when %s is clicked',
      async (value, text) => {
        await selectSeverity(value);
        expect(findSeverityListbox().props('toggleText')).toBe(text);
      },
    );

    it.each(Object.entries(SEVERITY_LEVELS))(
      'shows the expected icon and icon color in the listbox button when %s is clicked',
      async (value) => {
        await selectSeverity(value);
        expect(findIcon(value).props('name')).toBe(`severity-${value}`);
        expect(findIcon(value).classes(SEVERITY_CLASS_NAME_MAP[value])).toBe(true);
      },
    );

    it('shows error message when submitting without severity', async () => {
      await findForm().trigger('submit');
      expect(findSeverityFormGroup().attributes('state')).toBeUndefined();
    });

    it('clears error message when selecting', async () => {
      await submitForm();
      expect(findSeverityFormGroup().attributes('state')).toBeUndefined();
      await selectSeverity('high');
      expect(findSeverityFormGroup().attributes('state')).toBeDefined();
    });
  });

  describe('comment input', () => {
    it.each(Object.entries(SEVERITY_LEVELS))(
      'renders after selecting severity %s',
      async (state) => {
        await selectSeverity(state);
        expect(findCommentFormInput().exists()).toBe(true);
      },
    );

    it('shows error message when submitting without comment', async () => {
      await selectSeverity('high');
      expect(findCommentFormGroup().attributes('state')).toBeDefined();
      await findForm().trigger('submit');
      expect(findCommentFormGroup().attributes('state')).toBeUndefined();
    });

    it('clears error message when adding comment', async () => {
      await submitForm({ state: 'high' });
      expect(findCommentFormGroup().attributes('state')).toBeUndefined();
      await addComment('test comment');
      expect(findCommentFormGroup().attributes('state')).toBeDefined();
    });
  });

  describe('bulk severity change', () => {
    const selectedVulnerabilities = [
      { id: 'gid://gitlab/Vulnerability/111', severity: 'LOW' },
      { id: 'gid://gitlab/Vulnerability/222', severity: 'INFO' },
      { id: 'gid://gitlab/Vulnerability/333', severity: 'HIGH' },
    ];

    describe('when API call is successful', () => {
      let apolloProvider;
      const requestHandler = jest
        .fn()
        .mockResolvedValue(mockVulnerabilitiesSeverityOverrideQueryResponse);
      const selectedVulnerabilitiesIds = selectedVulnerabilities.map((v) => v.id);

      beforeEach(() => {
        apolloProvider = createApolloProvider([vulnerabilitiesSeverityOverride, requestHandler]);
        createComponent(
          {
            selectedVulnerabilities,
          },
          apolloProvider,
        );
      });

      it('calls the mutation with the expected data and emits an update for each vulnerability', async () => {
        expect(requestHandler).not.toHaveBeenCalled();
        await submitForm({
          state: 'info',
          comment: 'test comment',
        });
        await waitForPromises();
        expect(requestHandler).toHaveBeenCalledTimes(1);
        expect(requestHandler).toHaveBeenCalledWith(
          expect.objectContaining({
            severity: 'INFO',
            comment: 'test comment',
            vulnerabilityIds: selectedVulnerabilitiesIds,
          }),
        );
      });

      it('calls the toaster', async () => {
        expect(toast).not.toHaveBeenCalled();
        await submitForm({
          state: 'high',
          comment: 'test comment',
        });
        await waitForPromises();
        expect(toast).toHaveBeenLastCalledWith(
          `${selectedVulnerabilities.length} vulnerabilities set to high severity`,
        );
      });

      it('emits `vulnerabilities-updated` for each selected vulnerability', async () => {
        const eventName = 'vulnerabilities-updated';
        expect(wrapper.emitted(eventName)).toBeUndefined();

        await submitForm({
          state: 'low',
          comment: 'test comment',
        });
        await waitForPromises();

        const emittedEvents = wrapper.emitted(eventName);
        const firstEmittedEventPayload = emittedEvents[0][0];
        expect(emittedEvents).toHaveLength(1);
        expect(firstEmittedEventPayload).toEqual(selectedVulnerabilitiesIds);
        expect(wrapper.emitted('clear-rejected')).toHaveLength(1);
        expect(wrapper.emitted('update-rejected')).toBeUndefined();
      });
    });

    describe.each([
      {
        mutationHandler: jest.fn().mockResolvedValue({
          errors: [{ message: 'Something went wrong' }],
        }),
        expectedErrorMessage: 'Something went wrong',
      },
      {
        mutationHandler: jest.fn().mockRejectedValue(new Error('Error message')),
        expectedErrorMessage: 'Error message',
      },
    ])('when API call fails', ({ mutationHandler, expectedErrorMessage }) => {
      beforeEach(() => {
        const apolloProvider = createApolloProvider([
          vulnerabilitiesSeverityOverride,
          mutationHandler,
        ]);
        createComponent(
          {
            selectedVulnerabilities,
          },
          apolloProvider,
        );
      });

      it('sends the error to Sentry', async () => {
        expect(Sentry.captureException).not.toHaveBeenCalled();
        submitForm({
          state: 'wrong severity',
          comment: 'test comment',
        });
        await waitForPromises();

        expect(Sentry.captureException).toHaveBeenCalledTimes(1);
        expect(Sentry.captureException.mock.calls[0][0]).toEqual(new Error(expectedErrorMessage));
        expect(wrapper.emitted('update-rejected')).toEqual([[selectedVulnerabilities]]);
      });
    });
  });

  describe('refetch queries', () => {
    it.each([
      {
        mutationHandler: jest
          .fn()
          .mockResolvedValue(mockVulnerabilitiesSeverityOverrideQueryResponse),
      },
      {
        mutationHandler: jest.fn().mockRejectedValue(new Error('Error message')),
      },
    ])(
      'uses the refetch queries whether the mutation succeeds or fails',
      async ({ mutationHandler }) => {
        const apolloProvider = createApolloProvider([
          vulnerabilitiesSeverityOverride,
          mutationHandler,
        ]);
        createComponent({}, apolloProvider, {
          vulnerabilitiesQuery: projectVulnerabilitiesQuery,
          vulnerabilitiesCountsQuery: countsQuery,
        });

        expect(mutationHandler).not.toHaveBeenCalled();

        submitForm({
          state: 'info',
          comment: 'this is fine',
        });
        await waitForPromises();

        expect(mutationHandler).toHaveBeenCalledTimes(1);
      },
    );
  });
});
