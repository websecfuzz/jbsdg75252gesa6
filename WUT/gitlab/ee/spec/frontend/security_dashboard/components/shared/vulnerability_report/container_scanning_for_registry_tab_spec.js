import Vue from 'vue';
import VueApollo from 'vue-apollo';
import { GlAlert, GlEmptyState, GlSprintf } from '@gitlab/ui';
import { shallowMount } from '@vue/test-utils';
import createMockApollo from 'helpers/mock_apollo_helper';
import waitForPromises from 'helpers/wait_for_promises';
import component from 'ee/security_dashboard/components/shared/vulnerability_report/container_scanning_for_registry_tab.vue';
import VulnerabilityReportTab from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_report_tab.vue';
import {
  graphQLProjectContainerScanningForRegistryOnMock,
  graphQLProjectContainerScanningForRegistryOffMock,
} from 'ee_jest/packages_and_registries/container_registry/explorer/components/list_page/mock_data';
import { getProjectContainerScanning } from 'ee/packages_and_registries/container_registry/explorer/graphql/queries/get_project_container_scanning.query.graphql';
import { stubComponent, RENDER_ALL_SLOTS_TEMPLATE } from 'helpers/stub_component';

describe('Container scanning for registry', () => {
  let apolloProvider;
  let wrapper;

  const findVulnerabilityReportTab = () => wrapper.findComponent(VulnerabilityReportTab);
  const findBanner = () => wrapper.findComponent(GlAlert);
  const findEmptyState = () => wrapper.findComponent(GlEmptyState);

  const waitForApolloRequestRender = async () => {
    await waitForPromises();
  };

  const mountComponent = ({
    provide = {
      fullPath: 'project',
      securityConfigurationPath: '/path',
    },
    requestHandlers,
    containerScanningForRegistryMock,
  } = {}) => {
    Vue.use(VueApollo);

    const cacheOptions = {
      typePolicies: {
        Project: {
          fields: {
            containerScanningForRegistry: {
              read() {
                return containerScanningForRegistryMock;
              },
            },
          },
        },
      },
    };

    apolloProvider = createMockApollo(requestHandlers, {}, cacheOptions);

    apolloProvider.clients.defaultClient.writeQuery({
      query: getProjectContainerScanning,
      variables: {
        fullPath: provide.projectPath,
        securityConfigurationPath: provide.securityConfigurationPath,
      },
      data: graphQLProjectContainerScanningForRegistryOnMock.data,
    });

    wrapper = shallowMount(component, {
      apolloProvider,
      propsData: {
        isActiveTab: true,
      },
      stubs: {
        GlSprintf,
        VulnerabilityReportTab: stubComponent(VulnerabilityReportTab, {
          template: RENDER_ALL_SLOTS_TEMPLATE,
        }),
      },
      provide() {
        return {
          ...provide,
        };
      },
    });
  };

  it('renders the tab with info banner', async () => {
    const requestHandlers = [
      [
        getProjectContainerScanning,
        jest.fn().mockResolvedValue(graphQLProjectContainerScanningForRegistryOnMock),
      ],
    ];

    const containerScanningForRegistryMock =
      graphQLProjectContainerScanningForRegistryOnMock.data.project.containerScanningForRegistry;

    mountComponent({ requestHandlers, containerScanningForRegistryMock });

    await waitForApolloRequestRender();

    expect(findVulnerabilityReportTab().exists()).toBe(true);
    expect(findBanner().exists()).toBe(true);
    expect(findBanner().props('title')).toBe('Container Scanning for registry is active');
    expect(findBanner().text()).toContain(
      'Container Scanning for Registry scans the latest tag of each image. It scans for vulnerabilities in the container',
    );
    expect(findEmptyState().exists()).toBe(false);
  });

  it('renders the tab after banner dismissal', async () => {
    const requestHandlers = [
      [
        getProjectContainerScanning,
        jest.fn().mockResolvedValue(graphQLProjectContainerScanningForRegistryOnMock),
      ],
    ];

    const containerScanningForRegistryMock =
      graphQLProjectContainerScanningForRegistryOnMock.data.project.containerScanningForRegistry;

    mountComponent({ requestHandlers, containerScanningForRegistryMock });

    await waitForApolloRequestRender();

    findBanner().vm.$emit('dismiss');

    await Vue.nextTick();

    expect(findVulnerabilityReportTab().exists()).toBe(true);
    expect(findBanner().exists()).toBe(false);
    expect(findEmptyState().exists()).toBe(false);
  });

  it('renders the empty state', async () => {
    const requestHandlers = [
      [
        getProjectContainerScanning,
        jest.fn().mockResolvedValue(graphQLProjectContainerScanningForRegistryOffMock),
      ],
    ];

    const containerScanningForRegistryMock =
      graphQLProjectContainerScanningForRegistryOffMock.data.project.containerScanningForRegistry;

    mountComponent({ requestHandlers, containerScanningForRegistryMock });

    await waitForApolloRequestRender();

    expect(findVulnerabilityReportTab().exists()).toBe(true);
    expect(findBanner().exists()).toBe(false);
    expect(findEmptyState().exists()).toBe(true);
    expect(findEmptyState().text()).toContain(
      'Container Scanning for Registry scans the latest tag of each image for vulnerabilities.',
    );
    expect(findEmptyState().text()).toContain('How do I enable Container Scanning for Registry?');
  });
});
