import { GlFilteredSearch } from '@gitlab/ui';
import Vue from 'vue';
import VueRouter from 'vue-router';
import { isEqual } from 'lodash';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import waitForPromises from 'helpers/wait_for_promises';
import FilteredSearch from 'ee/security_dashboard/components/shared/filtered_search_v2/vulnerability_report_filtered_search.vue';
import StatusToken from 'ee/security_dashboard/components/shared/filtered_search_v2/tokens/status_token.vue';
import ActivityToken from 'ee/security_dashboard/components/shared/filtered_search_v2/tokens/activity_token.vue';
import {
  STATUS_TOKEN_DEFINITION,
  SEVERITY_TOKEN_DEFINITION,
  PROJECT_TOKEN_DEFINITION,
  IMAGE_TOKEN_DEFINITION,
  CLUSTER_TOKEN_DEFINITION,
  SCANNER_TOKEN_DEFINITION,
  ACTIVITY_TOKEN_DEFINITION,
  IDENTIFIER_TOKEN_DEFINITION,
  REPORT_TYPE_VENDOR_TOKEN_DEFINITION,
} from 'ee/security_dashboard/components/shared/filtered_search_v2/tokens/constants';
import { FILTERS } from 'ee/security_dashboard/components/shared/vulnerability_report/constants';

Vue.use(VueRouter);
const router = new VueRouter();

describe('Vulnerability Report Filtered Search component', () => {
  let wrapper;

  const findFilteredSearchComponent = () => wrapper.findComponent(GlFilteredSearch);

  const createWrapper = async ({
    query = {},
    availableFilters = [FILTERS.STATUS, FILTERS.ACTIVITY, FILTERS.PROJECT, FILTERS.CLUSTER],
    toolFilterType = 'scanner',
  } = {}) => {
    if (Object.keys(query).length > 0 && !isEqual(router.currentRoute.query, query)) {
      await router.replace({ query });
    }

    wrapper = shallowMountExtended(FilteredSearch, {
      propsData: {
        availableFilters,
      },
      provide: {
        scanners: [],
        toolFilterType,
      },
      router,
    });
  };

  const updateTokenValue = async (...args) => {
    const component = findFilteredSearchComponent().vm;

    component.$emit(
      'input',
      args.map(([tokenType, tokenValue]) => {
        return { type: tokenType, value: { data: tokenValue, operator: '||' } };
      }),
    );

    component.$emit('token-complete');

    // Wait for promises to pass under Vue 3.
    //
    // This isn't robust, but it seems like the least bad approach for now.
    // Ideally we'd wait explicitly for the navigation to be complete, but
    // that happens inside the implementation, so we can't await it in tests.
    //
    // - Adding router.beforeEach/afterEach hooks to set up a promise isn't
    //   sufficient. Even after afterEach is called, the navigation still
    //   isn't done.
    // - We could emit a new event in the implementation, e.g.,
    //   this.$router.push().then(() => { this.$emit('navigated') }), but
    //   that feels like a hack, as it'd just be for testing purposes.
    await waitForPromises();
  };

  describe('with empty query parameters', () => {
    beforeEach(() => {
      createWrapper();
    });

    it('should mount the component with the correct config', () => {
      const filteredSearch = findFilteredSearchComponent();

      expect(filteredSearch.props('placeholder')).toEqual('Search or filter vulnerabilities...');
      expect(filteredSearch.props('termsAsTokens')).toBe(false);
      expect(filteredSearch.props('value')).toEqual([
        {
          type: 'state',
          value: {
            data: StatusToken.defaultValues,
            operator: '||',
          },
        },
        {
          type: 'activity',
          value: {
            data: ActivityToken.defaultValues,
            operator: '||',
          },
        },
      ]);
    });

    it.each`
      name                                | availableFilters                                         | availableTokens
      ${'state'}                          | ${[FILTERS.STATUS]}                                      | ${[STATUS_TOKEN_DEFINITION]}
      ${'state and severity'}             | ${[FILTERS.STATUS, FILTERS.SEVERITY]}                    | ${[STATUS_TOKEN_DEFINITION, SEVERITY_TOKEN_DEFINITION]}
      ${'state and project'}              | ${[FILTERS.STATUS, FILTERS.PROJECT]}                     | ${[STATUS_TOKEN_DEFINITION, PROJECT_TOKEN_DEFINITION]}
      ${'state, image, project'}          | ${[FILTERS.STATUS, FILTERS.IMAGE, FILTERS.PROJECT]}      | ${[STATUS_TOKEN_DEFINITION, IMAGE_TOKEN_DEFINITION, PROJECT_TOKEN_DEFINITION]}
      ${'state and cluster'}              | ${[FILTERS.STATUS, FILTERS.CLUSTER]}                     | ${[STATUS_TOKEN_DEFINITION, CLUSTER_TOKEN_DEFINITION]}
      ${'state and activity'}             | ${[FILTERS.STATUS, FILTERS.ACTIVITY]}                    | ${[STATUS_TOKEN_DEFINITION, ACTIVITY_TOKEN_DEFINITION]}
      ${'state, scanner, identifier'}     | ${[FILTERS.STATUS, FILTERS.SCANNER, FILTERS.IDENTIFIER]} | ${[STATUS_TOKEN_DEFINITION, SCANNER_TOKEN_DEFINITION, IDENTIFIER_TOKEN_DEFINITION]}
      ${'state and report type (simple)'} | ${[FILTERS.STATUS, FILTERS.REPORT_TYPE_SIMPLE]}          | ${[STATUS_TOKEN_DEFINITION, REPORT_TYPE_VENDOR_TOKEN_DEFINITION]}
      ${'state and report type (vendor)'} | ${[FILTERS.STATUS, FILTERS.REPORT_TYPE_VENDOR]}          | ${[STATUS_TOKEN_DEFINITION, REPORT_TYPE_VENDOR_TOKEN_DEFINITION]}
    `(
      `passes the expected available tokens for filters '$name'`,
      ({ availableFilters, availableTokens }) => {
        createWrapper({ availableFilters });

        expect(findFilteredSearchComponent().props('availableTokens')).toEqual(availableTokens);
      },
    );

    it('should emit empty filters on clear', () => {
      findFilteredSearchComponent().vm.$emit('clear');

      // First event is triggered when mounted
      expect(wrapper.emitted('filters-changed')[1][0]).toEqual({});
    });
  });

  describe('with non-empty query parameters', () => {
    beforeEach(async () => {
      await createWrapper({
        availableFilters: [FILTERS.STATUS, FILTERS.SEVERITY, FILTERS.PROJECT, FILTERS.ACTIVITY],
        query: { severity: 'MEDIUM,LOW', projectId: '5,10' },
      });
    });

    it('should pass route parameters to the tokens', () => {
      expect(findFilteredSearchComponent().props('value')).toEqual([
        {
          type: 'state',
          value: {
            data: StatusToken.defaultValues,
            operator: '||',
          },
        },
        {
          type: 'severity',
          value: {
            data: ['MEDIUM', 'LOW'],
            operator: '||',
          },
        },
        {
          type: 'projectId',
          value: {
            data: ['5', '10'],
            operator: '||',
          },
        },
        {
          type: 'activity',
          value: {
            data: ActivityToken.defaultValues,
            operator: '||',
          },
        },
      ]);
    });
  });

  describe('with incorrect available-filters', () => {
    beforeEach(async () => {
      await createWrapper({
        availableFilters: ['does-not-exist'],
        query: {},
      });
    });

    it('does not throw an error', () => {
      expect(wrapper.exists()).toBe(true);
    });
  });

  describe('route and filters logic', () => {
    const defaultRouterQuery = { state: 'DETECTED' };

    beforeEach(async () => {
      await createWrapper({
        availableFilters: [FILTERS.STATUS, FILTERS.SEVERITY],
        query: defaultRouterQuery,
      });
    });

    describe('severity token', () => {
      it('should omit severity in the query when value is ALL', () => {
        findFilteredSearchComponent().vm.$emit('input', [{ severity: ['ALL'] }]);

        expect(router.currentRoute.query).toEqual({
          state: 'DETECTED',
        });
      });

      it('should omit severity in the query when value is null', () => {
        findFilteredSearchComponent().vm.$emit('input', [{ severity: null }]);

        expect(router.currentRoute.query).toEqual({
          state: 'DETECTED',
        });
      });

      it('should update severity value in the query when value is not empty', async () => {
        await updateTokenValue(['severity', ['MEDIUM', 'HIGH']]);

        expect(router.currentRoute.query).toEqual({
          severity: 'MEDIUM,HIGH',
          state: 'DETECTED',
        });

        expect(wrapper.emitted('filters-changed')[1][0]).toEqual({ severity: ['MEDIUM', 'HIGH'] });
      });
    });

    describe('handleTokenComplete', () => {
      beforeEach(async () => {
        createWrapper({
          query: { state: 'ALL' },
        });

        await updateTokenValue(['state', ['ALL']]);
      });

      it('should update query and filters when token-complete event is triggered', async () => {
        await updateTokenValue(['state', ['NEEDS_TRIAGE']], ['severity', ['MEDIUM', 'LOW']]);

        expect(wrapper.emitted('filters-changed')[1][0]).toEqual({
          state: ['NEEDS_TRIAGE'],
          severity: ['MEDIUM', 'LOW'],
          dismissalReason: [], // This comes from the StateToken.transformFilters
        });

        expect(router.currentRoute.query).toEqual({
          state: 'NEEDS_TRIAGE',
          severity: 'MEDIUM,LOW',
        });
      });

      it('should call transformQueryParams when the function is defined on a token', async () => {
        await updateTokenValue(
          ['state', ['CONFIRMED']],
          ['cluster', [{ value: 'test-agent', gid: 'gid://1' }]],
        );

        expect(router.currentRoute.query).toEqual({
          state: 'CONFIRMED',
          cluster: 'test-agent',
        });
      });
    });

    describe('handleTokenDestroy', () => {
      beforeEach(async () => {
        createWrapper({
          query: {
            severity: 'LOW',
          },
        });

        await waitForPromises();

        // Set a default state
        await updateTokenValue(
          ['activity', ['STILL_DETECTED']],
          ['state', ['DETECTED', 'CONFIRMED']],
          ['severity', ['MEDIUM', 'LOW']],
        );
      });

      it('should emit events for the initial state', () => {
        expect(wrapper.emitted('filters-changed')[1][0]).toEqual({
          dismissalReason: [],
          severity: ['MEDIUM', 'LOW'],
          state: ['DETECTED', 'CONFIRMED'],
          hasIssues: undefined,
          hasMergeRequest: undefined,
          hasRemediations: undefined,
          hasResolution: false,
        });

        expect(router.currentRoute.query).toEqual({
          severity: 'MEDIUM,LOW',
        });
      });

      it('should add ALL to the query parameter for tokens with default values', async () => {
        findFilteredSearchComponent().vm.$emit('token-destroy', { type: 'state' });
        await waitForPromises();

        expect(router.currentRoute.query).toEqual({
          state: 'ALL',
          severity: 'MEDIUM,LOW',
        });

        findFilteredSearchComponent().vm.$emit('token-destroy', { type: 'activity' });
        await waitForPromises();

        expect(router.currentRoute.query).toEqual({
          state: 'ALL',
          activity: 'ALL',
          severity: 'MEDIUM,LOW',
        });
      });
    });
  });
});
