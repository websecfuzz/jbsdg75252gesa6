import Vue, { nextTick } from 'vue';
import VueApollo from 'vue-apollo';
import * as Sentry from '~/sentry/sentry_browser_wrapper';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import AttachNewIssue from 'ee/security_dashboard/components/shared/vulnerability_report/attach_new_issue.vue';
import SelectProjectDropdown from 'ee/security_dashboard/components/shared/vulnerability_report/select_project_dropdown.vue';
import createMockApollo from 'helpers/mock_apollo_helper';
import vulnerabilitiesCreateIssueMutation from 'ee/security_dashboard/graphql/mutations/vulnerabilities_create_issue.mutation.graphql';
import waitForPromises from 'helpers/wait_for_promises';
import { visitUrl } from '~/lib/utils/url_utility';

jest.mock('~/lib/utils/url_utility', () => ({
  ...jest.requireActual('~/lib/utils/url_utility'),
  visitUrl: jest.fn().mockName('visitUrlMock'),
}));

const defaultCreateIssueResponse = {
  data: {
    vulnerabilitiesCreateIssue: {
      issue: {
        id: '1',
        webUrl: 'https://gdk.test:3000/group/project/issues/1',
      },
    },
  },
};

jest.mock('~/sentry/sentry_browser_wrapper');

Vue.use(VueApollo);

describe('Attach New Issue component', () => {
  let wrapper;

  const findForm = () => wrapper.find('form');
  const findSelectProjectDropdown = () => wrapper.findComponent(SelectProjectDropdown);
  const findCancelButton = () => wrapper.findByTestId('cancel-add-new-button');
  const findSubmitButton = () => wrapper.find('[type="submit"]');

  const createComponent = ({
    selectedVulnerabilities = [{ id: 'id_0' }, { id: 'id_1' }],
    apolloProvider,
    provide = {},
    vulnerabilitiesQuery,
    vulnerabilitiesCountsQuery,
  } = {}) => {
    wrapper = shallowMountExtended(AttachNewIssue, {
      apolloProvider,
      propsData: {
        selectedVulnerabilities,
      },
      provide: {
        vulnerabilitiesQuery,
        vulnerabilitiesCountsQuery,
        projectId: '1',
        ...provide,
      },
    });
  };

  beforeEach(createComponent);

  it('renders correctly', () => {
    expect(findSelectProjectDropdown().exists()).toBe(false);
    expect(findCancelButton().exists()).toBe(true);
    expect(findSubmitButton().exists()).toBe(true);
    expect(findSubmitButton().attributes('disabled')).toBeUndefined();
    expect(findSubmitButton().classes('js-no-auto-disable')).toBe(true);
  });

  describe('when group level', () => {
    beforeEach(() => {
      createComponent({ provide: { projectId: undefined } });
    });

    it('renders select project dropdown', () => {
      expect(findSelectProjectDropdown().props('valid')).toBe(true);
    });

    it('handles input event', async () => {
      const projectId = '2';
      findSelectProjectDropdown().vm.$emit('input', projectId);
      await nextTick();
      expect(findSelectProjectDropdown().props('value')).toBe(projectId);
    });
  });

  it('clicking cancel emits "cancel"', () => {
    findCancelButton().vm.$emit('click');
    expect(wrapper.emitted('cancel')).toHaveLength(1);
  });

  describe('form submit', () => {
    const requestHandler = jest.fn().mockResolvedValue(defaultCreateIssueResponse);
    let apolloProvider;

    beforeEach(() => {
      apolloProvider = createMockApollo([[vulnerabilitiesCreateIssueMutation, requestHandler]]);
      createComponent({ apolloProvider });
    });

    describe('successful vulnerabilities create issue API call', () => {
      it('calls the mutation with expected variables', async () => {
        await findForm().trigger('submit');
        await waitForPromises();

        expect(requestHandler).toHaveBeenCalledWith({
          project: 'gid://gitlab/Project/1',
          vulnerabilityIds: ['id_0', 'id_1'],
        });
        expect(wrapper.emitted('vulnerabilities-updated')).toEqual([[['id_0', 'id_1']]]);
      });

      it('emits "clear-rejected" event and "vulnerabilities-updated" event', async () => {
        await findForm().trigger('submit');

        expect(wrapper.emitted('clear-rejected')).toHaveLength(1);
        await waitForPromises();
        expect(wrapper.emitted('vulnerabilities-updated')).toEqual([[['id_0', 'id_1']]]);
      });

      it('sets loading state for submit button', async () => {
        await findForm().trigger('submit');

        expect(findSubmitButton().props('loading')).toBe(true);
        await waitForPromises();
        expect(findSubmitButton().props('loading')).toBe(false);
      });
    });

    describe('failed vulnerabilities create issue API call', () => {
      const failedRequestHandler = jest.fn().mockResolvedValue({
        data: {
          vulnerabilitiesCreateIssue: { issue: null, errors: ['Error message'] },
        },
      });
      beforeEach(() => {
        apolloProvider = createMockApollo([
          [vulnerabilitiesCreateIssueMutation, failedRequestHandler],
        ]);
        createComponent({ apolloProvider });
      });

      it('sends an error to Sentry', async () => {
        expect(Sentry.captureException).not.toHaveBeenCalled();

        await findForm().trigger('submit');
        await waitForPromises();

        expect(Sentry.captureException.mock.calls).toMatchObject([[['Error message']]]);
        expect(wrapper.emitted('update-rejected')).toMatchObject([
          [[{ id: 'id_0' }, { id: 'id_1' }]],
        ]);
      });
    });

    it('visits web url', async () => {
      await findForm().trigger('submit');
      await waitForPromises();
      expect(visitUrl).toHaveBeenCalledWith('https://gdk.test:3000/group/project/issues/1');
    });

    describe('when group level', () => {
      beforeEach(() => {
        apolloProvider = createMockApollo([[vulnerabilitiesCreateIssueMutation, requestHandler]]);
        createComponent({ apolloProvider, provide: { projectId: undefined } });
      });

      it('sets valid to `false` when project is not selected', async () => {
        expect(findSelectProjectDropdown().props('valid')).toBe(true);
        await findForm().trigger('submit');
        await waitForPromises();
        expect(findSelectProjectDropdown().props('valid')).toBe(false);
        expect(requestHandler).not.toHaveBeenCalled();
      });

      it('uses projectId from dropdown for query', async () => {
        const projectId = '2';
        findSelectProjectDropdown().vm.$emit('input', projectId);
        await nextTick();

        await findForm().trigger('submit');
        await waitForPromises();

        expect(requestHandler).toHaveBeenCalledWith({
          project: `gid://gitlab/Project/${projectId}`,
          vulnerabilityIds: ['id_0', 'id_1'],
        });
      });
    });
  });
});
