import { GlSprintf, GlLink, GlFriendlyWrap } from '@gitlab/ui';
import { trimText } from 'helpers/text_helper';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import { renderGFM } from '~/behaviors/markdown/render_gfm';
import { REPORT_TYPES_TO_HUMAN_READABLE } from 'ee/security_dashboard/components/shared/vulnerability_details_graphql/constants';
import Details from 'ee/security_dashboard/components/shared/vulnerability_details_graphql/index.vue';
import DetailsSection from 'ee/security_dashboard/components/shared/vulnerability_details_graphql/details_section.vue';
import DetailsSectionListItem from 'ee/security_dashboard/components/shared/vulnerability_details_graphql/details_section_list_item.vue';
import StatusBadge from 'ee/vue_shared/security_reports/components/status_badge.vue';
import SeverityBadge from 'ee/vue_shared/security_reports/components/severity_badge.vue';
import FalsePositiveAlert from 'ee/vulnerabilities/components/false_positive_alert.vue';
import CodeBlock from '~/vue_shared/components/code_block.vue';
import GenericReportSection from 'ee/vulnerabilities/components/generic_report/report_section_graphql.vue';
import VulnerabilityTraining from 'ee/vulnerabilities/components/vulnerability_training.vue';
import { vulnerabilityDetails } from 'ee_jest/security_dashboard/components/pipeline/mock_data';
import { getHttpString } from 'ee/vue_shared/security_reports/components/helpers';
import { HTTP_STATUS_OK } from '~/lib/utils/http_status';

const TEST_VULNERABILITY = {
  descriptionHtml: 'Description in <strong>HTML</strong>',
  description: 'Description in <strong>plain text</strong>',
  severity: 'HIGH',
  falsePositive: false,
  project: {
    name: 'Gitlab.com',
    webUrl: 'http://gitlab.com',
  },
  details: Object.values(vulnerabilityDetails),
  evidence: null,
  location: {
    file: 'my-file',
  },
  state: 'DETECTED',
};

jest.mock('~/behaviors/markdown/render_gfm');

describe('ee/security_dashboard/components/shared/vulnerability_details_graphql/index.vue', () => {
  let wrapper;

  const createComponent = (options = {}) => {
    wrapper = shallowMountExtended(Details, {
      propsData: {
        ...TEST_VULNERABILITY,
      },
      stubs: {
        GlSprintf,
        DetailsSection,
        DetailsSectionListItem,
      },
      ...options,
    });
  };

  const expectOptionalFieldsNotRendering = (optionalFields = []) => {
    it.each(optionalFields)('does not render the optional field: "%s"', (testId) => {
      expect(wrapper.findByTestId(testId).exists()).toBe(false);
    });
  };

  describe('false positive alert', () => {
    const findFalsePositiveAlert = () => wrapper.findComponent(FalsePositiveAlert);

    it('shows the false positive alert', () => {
      createComponent({
        propsData: {
          ...TEST_VULNERABILITY,
          falsePositive: true,
        },
      });

      expect(findFalsePositiveAlert().exists()).toBe(true);
    });

    it('does not show the false positive alert', () => {
      createComponent();

      expect(findFalsePositiveAlert().exists()).toBe(false);
    });
  });

  describe('description section', () => {
    beforeEach(createComponent);

    const findDescriptionSection = () => wrapper.findByTestId('description-section');
    const findDescriptionHtml = () => wrapper.findByTestId('description-html');

    it('has the correct heading', () => {
      expect(findDescriptionSection().props('heading')).toBe('Description');
    });

    it(`contains the vulnerability's HTML description`, () => {
      expect(findDescriptionSection().html()).toContain(TEST_VULNERABILITY.descriptionHtml);
    });

    it('renders gfm', () => {
      expect(renderGFM).toHaveBeenCalledWith(findDescriptionHtml().element);
    });

    describe('when descriptionHtml is not available', () => {
      beforeEach(() => {
        createComponent({
          propsData: {
            ...TEST_VULNERABILITY,
            descriptionHtml: '',
          },
        });
      });

      it(`contains the vulnerability's plaintext description`, () => {
        expect(findDescriptionSection().text()).toContain(TEST_VULNERABILITY.description);
      });
    });
  });

  describe('main section', () => {
    describe('required fields', () => {
      beforeEach(createComponent);

      expectOptionalFieldsNotRendering([
        'report-type-list-item',
        'scanner-list-item',
        'request-url-list-item',
      ]);

      it('renders the severity with a badge', () => {
        const severity = wrapper.findByTestId('severity-list-item');

        expect(severity.text()).toContain('Severity:');
        expect(severity.findComponent(SeverityBadge).exists()).toBe(true);
      });

      it('renders the project with a link to it', () => {
        const project = wrapper.findByTestId('project-list-item');

        expect(project.text()).toContain('Project:');
        expect(project.findComponent(GlLink).attributes('href')).toBe(
          TEST_VULNERABILITY.project.webUrl,
        );
      });
    });

    describe('optional fields', () => {
      it('renders the state with a badge', () => {
        createComponent({
          propsData: {
            ...TEST_VULNERABILITY,
            state: 'DETECTED',
          },
        });

        const status = wrapper.findByTestId('state-list-item');

        expect(status.text()).toContain('Status:');
        expect(status.findComponent(StatusBadge).props('state')).toBe('detected');
      });

      it.each(Object.entries(REPORT_TYPES_TO_HUMAN_READABLE))(
        'renders the report type: %s',
        (reportType, humanReadableReportType) => {
          createComponent({
            propsData: {
              ...TEST_VULNERABILITY,
              reportType,
            },
          });

          expect(wrapper.findByTestId('report-type-list-item').text()).toContain(
            humanReadableReportType,
          );
        },
      );

      describe('renders information about the used scanner', () => {
        const TEST_SCANNER_NAME = 'ESLint';
        const TEST_SCANNER_VERSION = '8.26.0';

        it.each`
          description                            | scanner                                                       | expectedText
          ${'a scanner with a name'}             | ${{ name: TEST_SCANNER_NAME }}                                | ${`Scanner: ${TEST_SCANNER_NAME}`}
          ${'a scanner with a name and version'} | ${{ name: TEST_SCANNER_NAME, version: TEST_SCANNER_VERSION }} | ${`Scanner: ${TEST_SCANNER_NAME} (version ${TEST_SCANNER_VERSION})`}
        `('renders $description', ({ scanner, expectedText }) => {
          createComponent({
            propsData: {
              ...TEST_VULNERABILITY,
              scanner,
            },
          });

          expect(wrapper.findByTestId('scanner-list-item').text()).toBe(expectedText);
        });

        describe('request URL', () => {
          const TEST_URL = 'https://example.com/index.html';
          const TEST_HOST = 'http://example.com';
          const TEST_PATH = '/index.html';

          it.each`
            description   | data                                                      | expectedUrl
            ${'evidence'} | ${{ evidence: { request: { url: TEST_URL } } }}           | ${TEST_URL}
            ${'location'} | ${{ location: { hostname: TEST_HOST, path: TEST_PATH } }} | ${`${TEST_HOST}${TEST_PATH}`}
          `(
            'renders a link to "$TEST_URL" when the $description data includes it',
            ({ data, expectedUrl }) => {
              createComponent({
                propsData: {
                  ...TEST_VULNERABILITY,
                  ...data,
                },
              });

              const requestUrlListItem = wrapper.findByTestId('request-url-list-item');

              expect(requestUrlListItem.findComponent(GlLink).attributes()).toMatchObject({
                href: expectedUrl,
                target: '_blank',
              });
              expect(requestUrlListItem.findComponent(GlFriendlyWrap).attributes('text')).toBe(
                expectedUrl,
              );
            },
          );
        });
      });

      describe('evidence', () => {
        const findEvidenceListItem = () => wrapper.findByTestId('evidence-list-item');

        it('is rendered', () => {
          const summary = 'Invalid status codes indicate an error.';

          createComponent({
            propsData: {
              ...TEST_VULNERABILITY,
              evidence: { summary },
            },
          });
          expect(findEvidenceListItem().text()).toContain(summary);
          expect(findEvidenceListItem().props('label')).toBe('Evidence:');
        });

        it('is not rendered', () => {
          createComponent();

          expect(findEvidenceListItem().exists()).toBe(false);
        });
      });
    });
  });

  describe('request/response section', () => {
    const findRequestResponseSection = () => wrapper.findByTestId('request-response-section');
    const findRequestItem = () => wrapper.findByTestId('request-item');
    const findResponseItem = () => wrapper.findByTestId('response-item');
    const findRecordedResponseItem = () => wrapper.findByTestId('recorded-response-item');
    const request = {
      url: 'http://example.com/requestUrl',
      body: 'request body',
      method: 'request method',
      headers: [
        { name: 'headers name - 1', value: 'headers value - 1' },
        { name: 'headers name - 2', value: 'headers value - 2' },
      ],
    };

    const response = {
      body: 'response body',
      statusCode: `${HTTP_STATUS_OK}`,
      reasonPhrase: 'response reasonPhrase',
      headers: [
        { name: 'response headers name - 1', value: 'response headers value - 1' },
        { name: 'response headers name - 2', value: 'response headers value - 2' },
      ],
    };

    const supportingMessages = [
      {
        name: 'Recorded',
        response,
      },
    ];

    describe.each`
      type                    | evidence              | data                              | component
      ${'request'}            | ${request}            | ${request}                        | ${findRequestItem}
      ${'response'}           | ${response}           | ${response}                       | ${findResponseItem}
      ${'supportingMessages'} | ${supportingMessages} | ${supportingMessages[0].response} | ${findRecordedResponseItem}
    `('with $type information', ({ type, evidence, data, component }) => {
      beforeEach(() => {
        createComponent({
          propsData: {
            ...TEST_VULNERABILITY,
            evidence: {
              [type]: evidence,
            },
          },
        });
      });

      it('renders request/response heading', () => {
        expect(findRequestResponseSection().props('heading')).toBe('Request/Response');
      });

      it(`renders the ${type} code block section`, () => {
        expect(component().exists()).toBe(true);
        expect(component().findComponent(CodeBlock).props('code')).toBe(getHttpString(data));
      });
    });

    it.each`
      type          | description     | data                    | component
      ${'request'}  | ${'method'}     | ${{ method: null }}     | ${findRequestItem}
      ${'request'}  | ${'url'}        | ${{ url: null }}        | ${findRequestItem}
      ${'request'}  | ${'headers'}    | ${{ headers: [] }}      | ${findRequestItem}
      ${'response'} | ${'statusCode'} | ${{ statusCode: null }} | ${findResponseItem}
      ${'response'} | ${'headers'}    | ${{ headers: [] }}      | ${findResponseItem}
    `(
      'does not render the "$type" section when there are is no "$description" data',
      ({ type, data, component }) => {
        createComponent({
          propsData: {
            ...TEST_VULNERABILITY,
            evidence: { [type]: { ...request, ...data } },
          },
        });

        expect(component().exists()).toBe(false);
      },
    );

    describe('without information', () => {
      it('does not get rendered', () => {
        createComponent();

        expect(findRequestItem().exists()).toBe(false);
        expect(findResponseItem().exists()).toBe(false);
        expect(findRecordedResponseItem().exists()).toBe(false);
      });
    });
  });

  describe('additional info section', () => {
    const findAdditionalInfoSection = () => wrapper.findByTestId('additional-info-section');
    const findAssertItem = () => wrapper.findByTestId('assert-item');

    it('is rendered with the evidence source name', () => {
      const sourceName = 'some assertion';

      createComponent({
        propsData: {
          ...TEST_VULNERABILITY,
          evidence: { source: { name: sourceName } },
        },
      });

      expect(findAdditionalInfoSection().props('heading')).toBe('Additional Info');
      expect(findAssertItem().text()).toContain(sourceName);
      expect(findAssertItem().props('label')).toBe('Assert:');
    });

    it('is not rendered', () => {
      createComponent();

      expect(findAdditionalInfoSection().exists()).toBe(false);
    });
  });

  describe('location section', () => {
    const findLocationSection = () => wrapper.findByTestId('location-section');

    describe('with no location data', () => {
      beforeEach(() =>
        createComponent({
          propsData: {
            ...TEST_VULNERABILITY,
            location: {},
          },
        }),
      );

      it('does not get rendered', () => {
        expect(findLocationSection().exists()).toBe(false);
      });
    });

    describe('with location data', () => {
      const findFileLocation = () => wrapper.findByTestId('location-file-list-item');
      const findFileLink = () => findFileLocation().findComponent(GlLink);

      const TEST_LOCATION = {
        file: 'index.js',
        image: 'registry.gitlab.com/gitlab-org/security-products/analyzers/gemnasium:2',
        operatingSystem: 'debian:9',
        crashType: 'Heap-buffer-overflow READ 1',
        crashAddress: '0x7f3e3c000000',
        stacktraceSnippet: 'INFO: Seed: 2177069747',
        vulnerableClass: 'org.apache.commons.collections.functors.InvokerTransformer',
        vulnerableMethod: 'transform',
      };

      beforeEach(() =>
        createComponent({
          propsData: {
            ...TEST_VULNERABILITY,
            location: TEST_LOCATION,
          },
        }),
      );

      it('has the correct heading', () => {
        expect(findLocationSection().props('heading')).toBe('Location');
      });

      it('renders the file name as text', () => {
        expect(findFileLocation().text()).toContain('index.js');
        expect(findFileLink().exists()).toBe(false);
      });

      it.each`
        name                   | expectedText
        ${'image'}             | ${TEST_LOCATION.image}
        ${'operating-system'}  | ${TEST_LOCATION.operatingSystem}
        ${'crash-type'}        | ${TEST_LOCATION.crashType}
        ${'crash-address'}     | ${TEST_LOCATION.crashAddress}
        ${'vulnerable-class'}  | ${TEST_LOCATION.vulnerableClass}
        ${'vulnerable-method'} | ${TEST_LOCATION.vulnerableMethod}
      `('renders the "$name" as text', ({ name, expectedText }) => {
        expect(wrapper.findByTestId(`location-${name}-list-item`).text()).toContain(expectedText);
      });

      it('renders the stack trace snippet as a code block with a max-height', () => {
        const stackTraceSnippet = wrapper.findByTestId('location-stack-trace-snippet-list-item');
        expect(stackTraceSnippet.findComponent(CodeBlock).props()).toMatchObject({
          maxHeight: expect.any(String),
          code: TEST_LOCATION.stacktraceSnippet,
        });
      });

      describe('with a blob path', () => {
        it('opens file in a new tab', () => {
          createComponent({
            propsData: {
              ...TEST_VULNERABILITY,
              location: {
                file: 'index.js',
                blobPath: 'index.js',
              },
            },
          });

          expect(findFileLink().attributes('target')).toBe('_blank');
        });

        it('does not append a line range when line numbers are not present', () => {
          createComponent({
            propsData: {
              ...TEST_VULNERABILITY,
              location: {
                file: 'index.js',
                blobPath: 'index.js',
              },
            },
          });

          expect(trimText(findFileLocation().text())).toBe('File: index.js');
        });

        it('does not append a line range when the blobPath already includes it', () => {
          const blobPath = 'index.js#L1-2';

          createComponent({
            propsData: {
              ...TEST_VULNERABILITY,
              location: {
                file: 'index.js',
                startLine: '1',
                endLine: '2',
                blobPath,
              },
            },
          });

          expect(findFileLink().attributes('href')).toBe(blobPath);
        });

        it.each`
          description                                                 | lineData                            | expectedLineRange
          ${'end line is after start line - using numbers'}           | ${{ startLine: 0, endLine: 1 }}     | ${'0-1'}
          ${'end line is after start line - using strings'}           | ${{ startLine: '0', endLine: '1' }} | ${'0-1'}
          ${'end line is equal to start line - using numbers'}        | ${{ startLine: 1, endLine: 1 }}     | ${'1'}
          ${'end line is equal to start line - using strings'}        | ${{ startLine: '1', endLine: '1' }} | ${'1'}
          ${'end line is greater than to start line - using strings'} | ${{ startLine: '1', endLine: '0' }} | ${'1'}
          ${'end line is greater than to start line - using numbers'} | ${{ startLine: 1, endLine: 0 }}     | ${'1'}
        `(
          `links to the vulnerable file's line range "$expectedLineRange" when $description`,
          ({ lineData, expectedLineRange }) => {
            const location = {
              blobPath: '/project/namespace/-/blob/e3343434/src/js/main.js',
              file: '/src/js/main.js',
              ...lineData,
            };
            createComponent({
              propsData: {
                ...TEST_VULNERABILITY,
                location,
              },
            });

            const { blobPath, file } = location;
            const fileLink = findFileLink();

            expect(fileLink.attributes('href')).toBe(`${blobPath}#L${expectedLineRange}`);
            expect(fileLink.text()).toBe(`${file}:${expectedLineRange}`);
          },
        );
      });
    });
  });

  describe('links section', () => {
    const findLinksSection = () => wrapper.findByTestId('links-section');
    const findAllLinks = () => findLinksSection().findAllComponents(GlLink);

    describe('with no links', () => {
      beforeEach(createComponent);

      it('does not get rendered', () => {
        expect(findLinksSection().exists()).toBe(false);
      });
    });

    describe('with links', () => {
      const TEST_LINK_WITH_NAME = {
        url: 'http://link-to-vulnerability-1',
        name: 'link to vulnerability',
      };
      const TEST_LINK_WITHOUT_NAME = { url: 'http://link-to-vulnerability-2' };
      const TEST_LINKS = [TEST_LINK_WITH_NAME, TEST_LINK_WITHOUT_NAME];

      beforeEach(() =>
        createComponent({
          propsData: {
            ...TEST_VULNERABILITY,
            links: TEST_LINKS,
          },
        }),
      );

      it('has the correct heading', () => {
        expect(findLinksSection().props('heading')).toBe('Links');
      });

      it('renders a list of links', () => {
        expect(findAllLinks()).toHaveLength(TEST_LINKS.length);
      });

      it.each`
        linkType                       | link                      | expectedLinkText
        ${'with a "name" property'}    | ${TEST_LINK_WITH_NAME}    | ${TEST_LINK_WITH_NAME.name}
        ${'without a "name" property'} | ${TEST_LINK_WITHOUT_NAME} | ${TEST_LINK_WITHOUT_NAME.url}
      `('renders a link $linkType correctly', ({ link, expectedLinkText }) => {
        expect(findAllLinks().at(TEST_LINKS.indexOf(link)).text()).toBe(expectedLinkText);
      });
    });
  });

  describe('identifiers section', () => {
    const findIdentifiersSection = () => wrapper.findByTestId('identifiers-section');
    const findIdentifierItems = () => findIdentifiersSection().findAll('li');

    describe('with no identifiers', () => {
      beforeEach(createComponent);

      it('does not get rendered', () => {
        expect(findIdentifiersSection().exists()).toBe(false);
      });
    });

    describe('with identifiers', () => {
      const TEST_IDENTFIER_WITH_URL = {
        url: 'http://identifier-1',
        name: 'identifier 1',
      };
      const TEST_IDENTIFIER_WITHOUT_URL = { name: 'identifier 2' };
      const TEST_IDENTIFIERS = [TEST_IDENTFIER_WITH_URL, TEST_IDENTIFIER_WITHOUT_URL];

      beforeEach(() =>
        createComponent({
          propsData: {
            ...TEST_VULNERABILITY,
            identifiers: TEST_IDENTIFIERS,
          },
        }),
      );

      it('has the correct heading', () => {
        expect(findIdentifiersSection().props('heading')).toBe('Identifiers');
      });

      it('renders a list of identifiers', () => {
        expect(findIdentifierItems()).toHaveLength(TEST_IDENTIFIERS.length);
      });

      it.each`
        identifierType                | identifier                     | shouldContainLink
        ${'with a "url" property'}    | ${TEST_IDENTFIER_WITH_URL}     | ${true}
        ${'without a "url" property'} | ${TEST_IDENTIFIER_WITHOUT_URL} | ${false}
      `('renders an identifier $identifierType correctly', ({ identifier, shouldContainLink }) => {
        const identifierItem = findIdentifierItems().at(TEST_IDENTIFIERS.indexOf(identifier));
        const link = identifierItem.findComponent(GlLink);

        expect(identifierItem.text()).toBe(identifier.name);
        expect(link.exists()).toBe(shouldContainLink);

        if (shouldContainLink) {
          expect(link.attributes('href')).toBe(identifier.url);
        }
      });
    });
  });

  describe('assets section', () => {
    const findAssetsSection = () => wrapper.findByTestId('assets-section');
    const findAssetsItems = () => findAssetsSection().findAll('li');

    describe('with no assets', () => {
      beforeEach(createComponent);

      it('does not get rendered', () => {
        expect(findAssetsSection().exists()).toBe(false);
      });
    });

    describe('with assets', () => {
      const TEST_ASSET_WITH_URL = {
        name: 'asset 1',
        url: 'http://gitlab.com/asset-1',
      };
      const TEST_ASSET_WITHOUT_URL = {
        name: 'asset 2',
      };
      const TEST_ASSETS = [TEST_ASSET_WITH_URL, TEST_ASSET_WITHOUT_URL];

      beforeEach(() =>
        createComponent({
          propsData: {
            ...TEST_VULNERABILITY,
            assets: TEST_ASSETS,
          },
        }),
      );

      it('has the correct heading', () => {
        expect(findAssetsSection().props('heading')).toBe('Reproduction Assets');
      });

      it('renders the asset items', () => {
        expect(findAssetsItems()).toHaveLength(TEST_ASSETS.length);
      });

      it('renders an asset that contains "url" as a link', () => {
        const assetItem = findAssetsItems().at(TEST_ASSETS.indexOf(TEST_ASSET_WITH_URL));
        const assetLink = assetItem.findComponent(GlLink);

        expect(assetLink.attributes('href')).toBe(TEST_ASSET_WITH_URL.url);
        expect(assetLink.text()).toBe(TEST_ASSET_WITH_URL.name);
      });

      it('renders an asset that only contains "name" as text', () => {
        const assetItem = findAssetsItems().at(TEST_ASSETS.indexOf(TEST_ASSET_WITHOUT_URL));

        expect(assetItem.findComponent(GlLink).exists()).toBe(false);
        expect(assetItem.text()).toBe(TEST_ASSET_WITHOUT_URL.name);
      });
    });
  });

  describe('generic report', () => {
    beforeEach(createComponent);

    it('should render and receive the correct props', () => {
      expect(wrapper.findComponent(GenericReportSection).props()).toMatchObject({
        reportItems: TEST_VULNERABILITY.details,
      });
    });
  });

  describe('vulnerability training', () => {
    const findVulnerabilityTraining = () => wrapper.findComponent(VulnerabilityTraining);

    describe('with a project path and a finding that has identifiers', () => {
      const TEST_IDENTIFIER = {
        name: 'CWE-400',
        url: 'https://cwe.mitre.org/data/definitions/400.html',
        externalId: '400',
        externalType: 'CWE',
      };

      beforeEach(() => {
        createComponent({
          propsData: {
            ...TEST_VULNERABILITY,
            identifiers: [TEST_IDENTIFIER],
            project: {
              fullPath: 'my-project',
            },
          },
        });
      });

      it('has the correct heading', () => {
        expect(wrapper.findByTestId('training').props('heading')).toBe('Training');
      });

      it('renders the vulnerability training and passes the correct data do it', () => {
        expect(findVulnerabilityTraining().props()).toMatchObject({
          projectFullPath: 'my-project',
          identifiers: [
            {
              name: TEST_IDENTIFIER.name,
              url: TEST_IDENTIFIER.url,
              externalType: TEST_IDENTIFIER.externalType,
              externalId: TEST_IDENTIFIER.externalId,
            },
          ],
          file: TEST_VULNERABILITY.location.file,
        });
      });

      it('only makes the vulnerability training visible when the component emits "show-vulnerability-training"', async () => {
        expect(findVulnerabilityTraining().isVisible()).toBe(false);

        await wrapper
          .findComponent(VulnerabilityTraining)
          .vm.$emit('show-vulnerability-training', true);

        expect(findVulnerabilityTraining().isVisible()).toBe(true);
      });
    });

    it('should not render when the finding does not have identifiers', () => {
      createComponent({
        propsData: {
          ...TEST_VULNERABILITY,
          identifiers: [],
          project: {
            fullPath: 'my-project',
          },
        },
      });

      expect(findVulnerabilityTraining().exists()).toBe(false);
    });

    it('should not render when there is no project path', () => {
      createComponent({
        propsData: {
          ...TEST_VULNERABILITY,
          identifiers: [{ name: 'identifier' }],
          project: {},
        },
      });

      expect(findVulnerabilityTraining().exists()).toBe(false);
    });
  });
});
