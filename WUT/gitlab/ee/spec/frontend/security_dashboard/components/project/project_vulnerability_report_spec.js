import Vue, { nextTick } from 'vue';
import VueApollo from 'vue-apollo';
import VueRouter from 'vue-router';
import { GlAlert } from '@gitlab/ui';
import SecurityTrainingPromoBanner from 'ee/security_dashboard/components/project/security_training_promo_banner.vue';
import ProjectVulnerabilityReport from 'ee/security_dashboard/components/project/project_vulnerability_report.vue';
import VulnerabilityReportTabs from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_report_tabs.vue';
import VulnerabilityReportTab from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_report_tab.vue';
import ProjectPipelineStatus from 'ee/security_dashboard/components/shared/project_pipeline_status.vue';
import VulnerabilityRetentionAlert from 'ee/security_dashboard/components/shared/vulnerability_retention_alert.vue';
import SecurityScannerAlert from 'ee/security_dashboard/components/project/security_scanner_alert.vue';
import securityScannersQuery from 'ee/security_dashboard/graphql/queries/project_security_scanners.query.graphql';
import { DASHBOARD_TYPE_PROJECT } from 'ee/security_dashboard/constants';
import { useLocalStorageSpy } from 'helpers/local_storage_helper';
import createMockApollo from 'helpers/mock_apollo_helper';
import waitForPromises from 'helpers/wait_for_promises';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import LocalStorageSync from '~/vue_shared/components/local_storage_sync.vue';
import { SCANNER_NAMES_MAP } from '~/security_configuration/constants';

Vue.use(VueApollo);
Vue.use(VueRouter);
const router = new VueRouter();

const examplePipeline = { id: 1, createdAt: 'now', path: 'path' };

describe('Project vulnerability report app component', () => {
  useLocalStorageSpy();

  let wrapper;

  const securityScannersHandler = ({ available = [], enabled = [], pipelineRun = [] } = {}) =>
    jest.fn().mockResolvedValue({
      data: {
        project: {
          id: 1,
          securityScanners: { available, enabled, pipelineRun },
        },
      },
    });

  const createWrapper = ({
    pipeline = examplePipeline,
    sbomPipeline = examplePipeline,
    hasVulnerabilities = true,
    securityScanners,
    hideThirdPartyOffers = false,
    vulnerabilityQuota,
  } = {}) => {
    wrapper = shallowMountExtended(ProjectVulnerabilityReport, {
      router,
      apolloProvider: createMockApollo([
        [securityScannersQuery, securityScannersHandler(securityScanners)],
      ]),
      provide: {
        fullPath: '#',
        pipeline,
        sbomPipeline,
        hasVulnerabilities,
        dashboardType: DASHBOARD_TYPE_PROJECT,
        hideThirdPartyOffers,
        vulnerabilityQuota,
      },
      stubs: {
        VulnerabilityReportTabs,
        VulnerabilityReportTab,
        LocalStorageSync,
      },
    });
  };

  const findVulnerabilityReportTabs = () => wrapper.findComponent(VulnerabilityReportTabs);
  const findProjectPipelineStatus = () => wrapper.findComponent(ProjectPipelineStatus);
  const findSecurityScannerAlert = (root = wrapper) => root.findComponent(SecurityScannerAlert);
  const findVulnerabilityRetentionAlert = () => wrapper.findComponent(VulnerabilityRetentionAlert);

  describe('report not configured component', () => {
    it('shows the report if there is no pipeline and no vulnerabilities', () => {
      createWrapper({ pipeline: {}, hasVulnerabilities: false });

      expect(findVulnerabilityReportTabs().exists()).toBe(true);
    });

    it.each`
      pipeline           | hasVulnerabilities
      ${examplePipeline} | ${false}
      ${{}}              | ${true}
      ${examplePipeline} | ${true}
    `(
      'shows the report if pipeline is $pipeline and hasVulnerabilities is $hasVulnerabilities',
      ({ pipeline, hasVulnerabilities }) => {
        createWrapper({ pipeline, hasVulnerabilities });

        expect(findVulnerabilityReportTabs().exists()).toBe(true);
      },
    );
  });

  describe('quota warning', () => {
    const findQuotaWarning = () => wrapper.findComponent(GlAlert);

    it.each`
      quotaStatus   | expectedMessage
      ${'full'}     | ${'This project has reached the maximum number of vulnerabilities it can contain. New vulnerabilities will not be created.'}
      ${'critical'} | ${'This project is reaching the maximum number of vulnerabilities it can contain.'}
      ${'exceeded'} | ${"This project has reached the maximum number of vulnerabilities it can contain and some of the vulnerabilities couldn't be ingested."}
    `(
      'displays a warning message when quota status is $quotaStatus',
      ({ quotaStatus, expectedMessage }) => {
        createWrapper({ vulnerabilityQuota: quotaStatus });
        expect(findQuotaWarning().exists()).toBe(true);
        expect(wrapper.findByText(expectedMessage).exists()).toBe(true);
      },
    );

    it('displays no warning message when the vulnerability quota status is not provided', () => {
      createWrapper({ vulnerabilityQuota: '' });
      expect(findQuotaWarning().exists()).toBe(false);
    });
  });

  describe('project pipeline status component', () => {
    it('shows the component if there is a pipeline', () => {
      createWrapper();

      expect(findProjectPipelineStatus().props('pipeline')).toBe(examplePipeline);
    });

    it('does not show the component if there is no pipeline', () => {
      createWrapper({ pipeline: {} });

      expect(findProjectPipelineStatus().exists()).toBe(false);
    });
  });

  describe('security scanner alerts component', () => {
    describe.each`
      available   | enabled     | pipelineRun | expectAlertShown
      ${['DAST']} | ${[]}       | ${[]}       | ${true}
      ${['DAST']} | ${['DAST']} | ${[]}       | ${true}
      ${['DAST']} | ${[]}       | ${['DAST']} | ${true}
      ${['DAST']} | ${['DAST']} | ${['DAST']} | ${false}
      ${[]}       | ${[]}       | ${[]}       | ${false}
    `('visibility', ({ available, enabled, pipelineRun, expectAlertShown }) => {
      it(`should${expectAlertShown ? '' : ' not'} show the alert`, async () => {
        createWrapper({ securityScanners: { available, enabled, pipelineRun } });
        await waitForPromises();

        expect(findSecurityScannerAlert().exists()).toBe(expectAlertShown);
      });

      it('should never show the alert once it has been dismissed', () => {
        window.localStorage.setItem(
          ProjectVulnerabilityReport.SCANNER_ALERT_DISMISSED_LOCAL_STORAGE_KEY,
          'true',
        );

        createWrapper({ securityScanners: { available, enabled, pipelineRun } });

        expect(findSecurityScannerAlert().exists()).toBe(false);
      });
    });

    describe('dismissal', () => {
      beforeEach(async () => {
        createWrapper({
          securityScanners: { available: ['DAST'], enabled: [], pipelineRun: [] },
        });
        await waitForPromises();
      });

      it('should hide the alert when it is dismissed', async () => {
        const scannerAlert = findSecurityScannerAlert();
        expect(scannerAlert.exists()).toBe(true);

        scannerAlert.vm.$emit('dismiss');
        await nextTick();

        expect(scannerAlert.exists()).toBe(false);
      });

      it('should remember the dismissal state', async () => {
        findSecurityScannerAlert().vm.$emit('dismiss');
        await nextTick();

        expect(window.localStorage.setItem).toHaveBeenCalledWith(
          ProjectVulnerabilityReport.SCANNER_ALERT_DISMISSED_LOCAL_STORAGE_KEY,
          'true',
        );
      });
    });

    describe.each(Object.keys(SCANNER_NAMES_MAP))(
      'When %s is available but not enabled',
      (scanner) => {
        const translatedScannerName = SCANNER_NAMES_MAP[scanner];

        beforeEach(async () => {
          createWrapper({
            securityScanners: { available: [scanner], enabled: [], pipelineRun: [] },
          });
          await waitForPromises();
        });

        it(`passes the translated scanner's name to the alert (${translatedScannerName})`, () => {
          expect(findSecurityScannerAlert().props('notEnabledScanners')[0]).toBe(
            translatedScannerName,
          );
        });
      },
    );
  });

  describe('security training promotion', () => {
    it('shows user callout', () => {
      createWrapper();

      expect(wrapper.findComponent(SecurityTrainingPromoBanner).exists()).toBe(true);
    });

    it('hides user callout when hideThirdPartyOffers is false', () => {
      createWrapper({
        hideThirdPartyOffers: true,
      });

      expect(wrapper.findComponent(SecurityTrainingPromoBanner).exists()).toBe(false);
    });
  });

  it('mounts the retention alert', () => {
    createWrapper();
    expect(findVulnerabilityRetentionAlert().exists()).toBe(true);
  });
});
