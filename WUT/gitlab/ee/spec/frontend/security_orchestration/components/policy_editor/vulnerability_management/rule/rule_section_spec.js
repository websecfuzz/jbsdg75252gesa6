import { GlSprintf } from '@gitlab/ui';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import { SEVERITY_LEVELS_KEYS, REPORT_TYPES_DEFAULT_KEYS } from 'ee/security_dashboard/constants';
import SectionLayout from 'ee/security_orchestration/components/policy_editor/section_layout.vue';
import RuleSection from 'ee/security_orchestration/components/policy_editor/vulnerability_management/rule/rule_section.vue';
import { mockVulnerabilityManagementObject } from 'ee_jest/security_orchestration/mocks/mock_vulnerability_management_policy_data';

describe('RuleSection', () => {
  let wrapper;

  const defaultRule = mockVulnerabilityManagementObject.rules[0];
  const modifiedRule = { ...defaultRule, scanners: ['api_fuzzing'], severity_levels: ['high'] };

  const factory = ({ rule = defaultRule, index = 0 } = {}) => {
    wrapper = shallowMountExtended(RuleSection, {
      propsData: {
        index,
        rule,
      },
      stubs: {
        GlSprintf,
      },
    });
  };

  const findRuleSeparator = () => wrapper.findByTestId('rule-separator');
  const findSectionLayout = () => wrapper.findComponent(SectionLayout);
  const findScannersSelect = () => wrapper.findByTestId('scanners-select');
  const findSeveritySelect = () => wrapper.findByTestId('severities-select');

  beforeEach(() => {
    factory();
  });

  describe('rule separator', () => {
    it('does not show rule separator if first rule', () => {
      expect(findRuleSeparator().exists()).toBe(false);
    });

    it('shows rule separator if not first rule', () => {
      factory({ index: 1 });
      expect(findRuleSeparator().text()).toEqual('or');
    });
  });

  describe('remove button', () => {
    it('does not show remove button if first rule', () => {
      expect(findSectionLayout().props('showRemoveButton')).toBe(false);
    });

    it('shows remove button if not first rule', () => {
      factory({ index: 1 });
      expect(findSectionLayout().props('showRemoveButton')).toBe(true);
    });

    it('propagates the "remove" event', () => {
      findSectionLayout().vm.$emit('remove');
      expect(wrapper.emitted('remove')).toHaveLength(1);
    });
  });

  it('renders message', () => {
    expect(findSectionLayout().text()).toEqual(
      'If  of the default branch finds  vulnerabilities are no longer detected.',
    );
  });

  describe('scanners select', () => {
    it('passes default scanners when rule contains no scanners', () => {
      const ruleWithAllScanners = { ...defaultRule, scanners: [] };
      factory({ rule: ruleWithAllScanners });
      expect(findScannersSelect().props('value')).toEqual(REPORT_TYPES_DEFAULT_KEYS);
    });

    it('passes scanners of rule when rule contains scanners', () => {
      factory({ rule: modifiedRule });
      expect(findScannersSelect().props('value')).toEqual(modifiedRule.scanners);
    });

    it('emits empty array when all scanners are selected', () => {
      factory({ rule: modifiedRule });
      findScannersSelect().vm.$emit('input', REPORT_TYPES_DEFAULT_KEYS);
      expect(wrapper.emitted('changed')).toMatchObject([[{ ...modifiedRule, scanners: [] }]]);
    });

    it('emits selected scanners if not all scanners are selected', () => {
      findScannersSelect().vm.$emit('input', ['api_fuzzing']);
      expect(wrapper.emitted('changed')).toMatchObject([
        [{ ...defaultRule, scanners: ['api_fuzzing'] }],
      ]);
    });
  });

  describe('severity levels select', () => {
    it('passes default severity levels when rule contains no severity levels', () => {
      const ruleWithAllSeverityLevels = { ...defaultRule, severity_levels: [] };
      factory({ rule: ruleWithAllSeverityLevels });
      expect(findSeveritySelect().props('value')).toEqual(SEVERITY_LEVELS_KEYS);
    });

    it('passes severity levels of rule when rule contains severity levels', () => {
      factory({ rule: modifiedRule });
      expect(findSeveritySelect().props('value')).toEqual(modifiedRule.severity_levels);
    });

    it('emits empty array when all severity levels are selected', () => {
      factory({ rule: modifiedRule });
      findSeveritySelect().vm.$emit('input', SEVERITY_LEVELS_KEYS);
      expect(wrapper.emitted('changed')).toEqual([[{ ...modifiedRule, severity_levels: [] }]]);
    });

    it('emits selected severity levels if not all severity levels are selected', () => {
      findSeveritySelect().vm.$emit('input', ['high']);
      expect(wrapper.emitted('changed')).toEqual([[{ ...defaultRule, severity_levels: ['high'] }]]);
    });
  });
});
