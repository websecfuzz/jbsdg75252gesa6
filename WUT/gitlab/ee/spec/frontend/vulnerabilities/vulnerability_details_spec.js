import { GlLink, GlLabel } from '@gitlab/ui';
import { getAllByRole, getByTestId } from '@testing-library/dom';
import { MountingPortal } from 'portal-vue';
import { mountExtended } from 'helpers/vue_test_utils_helper';
import { renderGFM } from '~/behaviors/markdown/render_gfm';
import SeverityBadge from 'ee/vue_shared/security_reports/components/severity_badge.vue';
import TokenValidityBadge from 'ee/vue_shared/security_reports/components/token_validity_badge.vue';
import VulnerabilityDetails from 'ee/vulnerabilities/components/vulnerability_details.vue';
import {
  SUPPORTING_MESSAGE_TYPES,
  VULNERABILITY_TRAINING_HEADING,
  CODE_FLOW_TAB_URL,
} from 'ee/vulnerabilities/constants';
import VulnerabilityTraining from 'ee/vulnerabilities/components/vulnerability_training.vue';
import FalsePositiveAlert from 'ee/vulnerabilities/components/false_positive_alert.vue';
import VulnerabilityFileContents from 'ee/vulnerabilities/components/vulnerability_file_contents.vue';
import DependencyPath from 'ee/vulnerabilities/components/dependency_path.vue';
import { stubComponent } from 'helpers/stub_component';

jest.mock('~/behaviors/markdown/render_gfm');

describe('Vulnerability Details', () => {
  let wrapper;

  const $router = {
    push: jest.fn(),
  };

  const vulnerability = {
    id: 123,
    severity: 'bad severity',
    confidence: 'high confidence',
    reportType: 'Some report type',
    description: 'vulnerability description',
    descriptionHtml: 'vulnerability description <code>sample</code>',
    details: {
      codeFlows: { name: 'code_flows' },
    },
    severityOverride: {
      newSeverity: 'low',
      originalSeverity: 'medium',
      createdAt: new Date().toISOString(),
      author: { name: 'Security Research User' },
    },
  };

  const TEST_PROJECT_FULL_PATH = 'namespace/project';

  const createWrapper = (
    vulnerabilityOverrides,
    {
      explainVulnerabilityWithAiAbility = false,
      mockVulnerabilityTrainingTemplate = false,
      validityChecks = false,
      vulnerabilityReportTypeScannerFilter = true,
      dependencyPaths = true,
    } = {},
  ) => {
    const propsData = {
      vulnerability: { ...vulnerability, ...vulnerabilityOverrides },
    };
    wrapper = mountExtended(VulnerabilityDetails, {
      propsData,
      provide: {
        projectFullPath: TEST_PROJECT_FULL_PATH,
        canViewFalsePositive: true,
        glAbilities: { explainVulnerabilityWithAi: explainVulnerabilityWithAiAbility },
        glFeatures: { vulnerabilityReportTypeScannerFilter, dependencyPaths, validityChecks },
      },
      stubs: {
        VulnerabilityFileContents: true,
        VulnerabilityTraining: mockVulnerabilityTrainingTemplate
          ? { template: '<div><slot name="header"></slot></div>' }
          : true,
        MountingPortal: stubComponent(MountingPortal),
      },
      mocks: { $router },
    });
  };

  const getById = (id) => wrapper.findByTestId(id);
  const getAllById = (id) => wrapper.findAllByTestId(id);
  const getText = (id) => getById(id).text();
  const getLink = (id) => getById(id).findComponent(GlLink).attributes('href');
  const findVulnerabilityTraining = () => wrapper.findComponent(VulnerabilityTraining);
  const findFalsePositiveAlert = () => wrapper.findComponent(FalsePositiveAlert);
  const findDependencyPath = () => wrapper.findComponent(DependencyPath);

  it('shows the properties that should always be shown', () => {
    createWrapper();
    expect(getById('description').html()).toContain(vulnerability.descriptionHtml);
    expect(wrapper.findComponent(SeverityBadge).props('severity')).toBe(vulnerability.severity);
    expect(wrapper.findComponent(SeverityBadge).props('severityOverride')).toBe(
      vulnerability.severityOverride,
    );
    expect(wrapper.findComponent(SeverityBadge).props('showSeverityOverrides')).toBe(true);
    expect(getText('reportType')).toBe(`Report type: ${vulnerability.reportType}`);

    expect(getById('cvss').exists()).toBe(false);
    expect(getById('kev').exists()).toBe(false);
    expect(getById('epss').exists()).toBe(false);
    expect(getById('project').exists()).toBe(false);
    expect(findFalsePositiveAlert().exists()).toBe(false);
    expect(getById('image').exists()).toBe(false);
    expect(getById('os').exists()).toBe(false);
    expect(getById('file').exists()).toBe(false);
    expect(getById('class').exists()).toBe(false);
    expect(getById('method').exists()).toBe(false);
    expect(getById('url').exists()).toBe(false);
    expect(getById('evidence').exists()).toBe(false);
    expect(getById('scanner').exists()).toBe(false);
    expect(getById('validityCheck').exists()).toBe(false);
    expect(getById('show-code-flow').exists()).toBe(true);
    expect(getAllById('link')).toHaveLength(0);
    expect(getAllById('identifier')).toHaveLength(0);
  });

  describe('when the feature flag "vulnerabilityReportTypeScannerFilter" is disabled', () => {
    it('shows the properties that should always be shown', () => {
      createWrapper({}, { vulnerabilityReportTypeScannerFilter: false });
      expect(getText('reportType')).toBe(`Tool: ${vulnerability.reportType}`);
    });
  });

  it('renders gfm', () => {
    createWrapper();

    expect(renderGFM).toHaveBeenCalledWith(getById('description').element);
  });

  it.each([true, false])(
    'shows/hides the false-positive alert when `falsePositive` is: %s',
    (falsePositive) => {
      createWrapper({ falsePositive });
      expect(findFalsePositiveAlert().exists()).toBe(falsePositive);
    },
  );

  it('renders description when descriptionHtml is not present', () => {
    createWrapper({
      descriptionHtml: null,
    });
    expect(getById('description').html()).not.toContain(vulnerability.descriptionHtml);
    expect(getText('description')).toBe(vulnerability.description);
  });

  it('shows a link to the project if it exists', () => {
    const project = {
      fullName: 'myProject',
      fullPath: '/path/to/project',
    };
    createWrapper({ project });
    const projectLink = getById('project').findComponent(GlLink);

    expect(projectLink.attributes('href')).toBe(project.fullPath);
    expect(projectLink.text()).toBe(project.fullName);
  });

  it.each`
    reportType                  | expectedOutput
    ${'SAST'}                   | ${'SAST'}
    ${'DAST'}                   | ${'DAST'}
    ${'DEPENDENCY_SCANNING'}    | ${'Dependency Scanning'}
    ${'CONTAINER_SCANNING'}     | ${'Container Scanning'}
    ${'SECRET_DETECTION'}       | ${'Secret Detection'}
    ${'COVERAGE_FUZZING'}       | ${'Coverage Fuzzing'}
    ${'API_FUZZING'}            | ${'API Fuzzing'}
    ${'CLUSTER_IMAGE_SCANNING'} | ${'Cluster Image Scanning'}
  `(
    'displays "$expectedOutput" when report type is "$reportType"',
    ({ reportType, expectedOutput }) => {
      createWrapper({ reportType });
      expect(getText('reportType')).toBe(`Report type: ${expectedOutput}`);
    },
  );

  it('shows the location image if it exists', () => {
    createWrapper({ location: { image: 'some image' } });
    expect(getText('image')).toBe(`Image: some image`);
  });

  it('shows the location image as a link if it exists', () => {
    createWrapper({
      location: { image: 'some image', containerRepositoryUrl: 'http://www.gitlab.com' },
    });
    expect(getText('image')).toBe(`Image: some image`);
    expect(getLink('image')).toBe('http://www.gitlab.com');
  });

  it('shows the operating system if it exists', () => {
    createWrapper({ location: { operatingSystem: 'linux' } });
    expect(getText('namespace')).toBe(`Namespace: linux`);
  });

  it('shows the vulnerability class if it exists', () => {
    createWrapper({ location: { file: 'file', class: 'class name' } });
    expect(getText('class')).toBe(`Class: class name`);
  });

  it('shows the crash state if it exists', () => {
    createWrapper({ location: { crashState: 'crash state' } });
    expect(getText('crash_state')).toBe(`Crash State: crash state`);
  });

  it('shows the vulnerability method if it exists', () => {
    createWrapper({ location: { vulnerableMethod: 'method name' } });
    expect(getText('method')).toBe(`Method: method name`);
  });

  describe('security scores', () => {
    it('shows security scores', () => {
      createWrapper({
        cveEnrichment: { epssScore: 0.2, isKnownExploit: true },
        cvss: [{ version: '3.1', overallScore: 9.07 }],
      });

      const cvssText = getById('cvss').text();

      expect(cvssText).toContain('3.1');
      expect(cvssText).toContain('9.07');
      expect(cvssText).toContain('What is CVSS?');

      const epssText = getById('epss').text();

      expect(epssText).toContain('20%');
      expect(epssText).toContain('What is EPSS?');

      expect(getById('kev').text()).toContain('Yes');
    });

    it.each`
      cvss   | expectedColor
      ${9.2} | ${'#8d1300'}
      ${7.4} | ${'#c91c00'}
      ${5.7} | ${'#c17d10'}
      ${2.0} | ${'#d99530'}
      ${1}   | ${'#d99530'}
      ${0}   | ${'#428fdc'}
    `('should display the correct color for cvss: $cvss', ({ cvss, expectedColor }) => {
      createWrapper({ cvss: [{ version: '3.1', overallScore: cvss }] });
      expect(getById('cvss').findComponent(GlLabel).props('backgroundColor')).toBe(expectedColor);
    });

    it.each`
      epss    | expectedColor
      ${0.77} | ${'#8d1300'}
      ${0.52} | ${'#c91c00'}
      ${0.28} | ${'#c17d10'}
      ${0.1}  | ${'#d99530'}
      ${0}    | ${'#428fdc'}
    `('should display the correct color for epss: $epss', ({ epss, expectedColor }) => {
      createWrapper({ cveEnrichment: { epssScore: epss } });
      expect(getById('epss').findComponent(GlLabel).props('backgroundColor')).toBe(expectedColor);
    });

    it.each`
      kev      | expectedColor
      ${true}  | ${'#8d1300'}
      ${false} | ${'#428fdc'}
    `('should display the correct color for kev: $kev', ({ kev, expectedColor }) => {
      createWrapper({ cveEnrichment: { epssScore: 0.7, isKnownExploit: kev } });
      expect(getById('kev').findComponent(GlLabel).props('backgroundColor')).toBe(expectedColor);
    });
  });

  it.each`
    description                       | vulnerabilityData
    ${"request's URL"}                | ${{ request: { url: 'http://host.test/foo/bar' } }}
    ${"location's hostname and path"} | ${{ location: { hostname: 'http://host.test', path: '/foo/bar' } }}
  `('shows the vulnerability URL when the $description is provided', ({ vulnerabilityData }) => {
    createWrapper({ ...vulnerabilityData });
    const expectedUrl = 'http://host.test/foo/bar';

    expect(getById('url').findComponent(GlLink).attributes('href')).toBe(expectedUrl);
    expect(getText('url')).toBe(`URL: ${expectedUrl}`);
  });

  // Remove once support for REST API's `location.method` is deprecated
  // https://gitlab.com/groups/gitlab-org/-/epics/3657 and https://gitlab.com/groups/gitlab-org/-/epics/8054
  it('shows the vulnerability method if it exists for `location.method`', () => {
    createWrapper({ location: { method: 'method name' } });
    expect(getText('method')).toBe(`Method: method name`);
  });

  it('shows the crash type if it exists', () => {
    createWrapper({ location: { crashType: 'crash type' } });
    expect(getText('crash_type')).toBe(`Crash Type: crash type`);
  });

  it('shows the evidence if it exists', () => {
    createWrapper({ evidence: 'some evidence' });
    expect(getText('evidence')).toBe(`Evidence: some evidence`);
  });

  it('shows the links if they exist', () => {
    const links = [
      { url: 'http://foo.bar/1' },
      { url: 'http://foo.bar/2', name: 'link 2' },
      { url: 'http://foo.bar/3' },
    ];
    createWrapper({ links });

    const linkEls = getAllById('link');
    expect(linkEls).toHaveLength(links.length);

    linkEls.wrappers.forEach((link, index) => {
      const { url, name } = links.at(index);

      expect(link.attributes()).toMatchObject({
        target: '_blank',
        href: url,
      });
      expect(link.text()).toBe(name || url);
    });
  });

  it('shows the vulnerability identifiers if they exist', () => {
    const identifiersData = [
      { name: '00', url: 'http://example.com/00' },
      { name: '11', url: 'http://example.com/11' },
      { name: '22', url: 'http://example.com/22' },
      { name: '33' },
      { name: '44' },
      { name: '55' },
    ];

    createWrapper({
      identifiers: identifiersData,
    });

    const identifiers = getAllById('identifier');

    expect(identifiers).toHaveLength(identifiersData.length);

    const checkIdentifier = ({ name, url }, index) => {
      const identifier = identifiers.at(index);

      expect(identifier.text()).toBe(name);

      if (url) {
        expect(identifier.vm).toBeDefined();
        expect(identifier.vm.$options.name).toBe('GlLink');
        expect(identifier.attributes()).toMatchObject({
          target: '_blank',
          href: url,
        });
      } else {
        expect(identifier.vm).toBeUndefined();
        expect(identifier.element.tagName).toBe('SPAN');
      }
    };

    identifiersData.forEach(checkIdentifier);
  });

  it('shows the vulnerability assets if they exist', () => {
    const assetsData = [
      { name: 'Postman Collection', url: 'http://example.com/postman' },
      { name: 'HTTP Messages', url: 'http://example.com/http-messages' },
      { name: 'Foo' },
      { name: 'Bar' },
    ];

    createWrapper({
      assets: assetsData,
    });

    const assets = getAllById('asset');

    expect(assets).toHaveLength(assetsData.length);

    const checkIdentifier = ({ name, url }, index) => {
      const asset = assets.at(index);

      expect(asset.text()).toBe(name);

      if (url) {
        expect(asset.vm).toBeDefined();
        expect(asset.vm.$options.name).toBe('GlLink');
        expect(asset.attributes()).toMatchObject({
          target: '_blank',
          href: url,
        });
      } else {
        expect(asset.vm).toBeUndefined();
        expect(asset.element.tagName).toBe('SPAN');
      }
    };

    assetsData.forEach(checkIdentifier);
  });

  describe('VulnerabilityTraining', () => {
    const identifiers = [{ externalType: 'cwe', externalId: 'cwe-123' }];
    const location = { file: 'test.txt' };

    it('renders component', () => {
      createWrapper({ identifiers, location });

      expect(findVulnerabilityTraining().props()).toMatchObject({
        identifiers,
        projectFullPath: TEST_PROJECT_FULL_PATH,
        file: location.file,
      });
    });

    it('renders title text', () => {
      createWrapper({ identifiers }, { mockVulnerabilityTrainingTemplate: true });

      expect(wrapper.text()).toContain(VULNERABILITY_TRAINING_HEADING.title);
    });

    it('passes a null file prop if the location is undefined', () => {
      createWrapper({ identifiers });
      expect(findVulnerabilityTraining().props('file')).toBeNull();
    });
  });

  describe('file link', () => {
    const file = () => getById('file').findComponent(GlLink);

    it('shows only the file name if there is no start line', () => {
      createWrapper({ location: { file: 'test.txt', blobPath: 'blob_path.txt' } });
      expect(file().attributes('target')).toBe('_blank');
      expect(file().attributes('href')).toBe('blob_path.txt');
      expect(file().text()).toBe('test.txt');
    });

    it('shows the correct line number when there is a start line', () => {
      createWrapper({ location: { file: 'test.txt', startLine: 24, blobPath: 'blob.txt' } });
      expect(file().attributes('target')).toBe('_blank');
      expect(file().attributes('href')).toBe('blob.txt#L24');
      expect(file().text()).toBe('test.txt:24');
    });

    it('does not append the line number when the blobPath already has a hash', () => {
      const blobPath = 'blob.txt#L1';
      createWrapper({ location: { file: 'test.txt', startLine: 24, blobPath } });

      expect(file().attributes('href')).toBe(blobPath);
    });

    it('shows the correct line numbers when there is a start and end line', () => {
      createWrapper({
        location: { file: 'test.txt', startLine: 24, endLine: 27, blobPath: 'blob.txt' },
      });
      expect(file().attributes('target')).toBe('_blank');
      expect(file().attributes('href')).toBe('blob.txt#L24-27');
      expect(file().text()).toBe('test.txt:24-27');
    });

    it('shows only the start line when the end line is the same', () => {
      createWrapper({
        location: { file: 'test.txt', startLine: 24, endLine: 24, blobPath: 'blob.txt' },
      });
      expect(file().attributes('target')).toBe('_blank');
      expect(file().attributes('href')).toBe('blob.txt#L24');
      expect(file().text()).toBe('test.txt:24');
    });
  });

  describe('file contents', () => {
    const findVulnerabilityFileContents = () => wrapper.findComponent(VulnerabilityFileContents);

    it.each`
      file          | startLine | isShown
      ${null}       | ${5}      | ${false}
      ${'file.txt'} | ${null}   | ${false}
      ${'file.txt'} | ${5}      | ${true}
    `(
      'shows the file contents for file: $file and startLine: $startLine? $isShown',
      ({ file, startLine, isShown }) => {
        createWrapper({ location: { file, startLine } });

        expect(findVulnerabilityFileContents().exists()).toBe(isShown);
      },
    );

    it('passes the location object to the component', () => {
      const location = { file: 'file', startLine: 1 };
      createWrapper({ location });

      expect(findVulnerabilityFileContents().props('location')).toBe(location);
    });
  });

  describe('scanner', () => {
    const link = () => getById('scannerSafeLink');
    const scannerText = () => getById('scanner').text();

    it('shows the scanner name only but no link', () => {
      createWrapper({ scanner: { name: 'some scanner' } });
      expect(scannerText()).toBe('Scanner: some scanner');
      expect(link().element instanceof HTMLSpanElement).toBe(true);
    });

    it('shows the scanner name and version but no link', () => {
      createWrapper({ scanner: { name: 'some scanner', version: '1.2.3' } });
      expect(scannerText()).toBe('Scanner: some scanner (version 1.2.3)');
      expect(link().element instanceof HTMLSpanElement).toBe(true);
    });

    it('shows the scanner name only with a link', () => {
      createWrapper({ scanner: { name: 'some tool', url: '//link' } });
      expect(scannerText()).toBe('Scanner: some tool');
      expect(link().attributes('href')).toBe('//link');
    });

    it('shows the scanner name and version with a link', () => {
      createWrapper({ scanner: { name: 'some tool', version: '1.2.3', url: '//link' } });
      expect(scannerText()).toBe('Scanner: some tool (version 1.2.3)');
      expect(link().attributes('href')).toBe('//link');
    });
  });

  describe('http data', () => {
    const TEST_HEADERS = [
      { name: 'Name1', value: 'Value1' },
      { name: 'Name2', value: 'Value2' },
    ];
    const EXPECT_REQUEST = {
      label: 'Sent request:',
      content: 'GET http://www.gitlab.com\nName1: Value1\nName2: Value2\n\n[{"user_id":1,}]',
      isCode: true,
    };

    const EXPECT_REQUEST_WITHOUT_BODY = {
      label: 'Sent request:',
      content:
        'GET http://www.gitlab.com\nName1: Value1\nName2: Value2\n\n<Message body is not provided>',
      isCode: true,
    };

    const EXPECT_REQUEST_WITH_EMPTY_STRING = {
      label: 'Sent request:',
      content: 'GET http://www.gitlab.com\nName1: Value1\nName2: Value2',
      isCode: true,
    };

    const EXPECT_RESPONSE = {
      label: 'Actual response:',
      content: '500 INTERNAL SERVER ERROR\nName1: Value1\nName2: Value2\n\n[{"user_id":1,}]',
      isCode: true,
    };

    const EXPECT_RESPONSE_WITHOUT_REASON_PHRASE = {
      label: 'Actual response:',
      content: '500 \nName1: Value1\nName2: Value2\n\n[{"user_id":1,}]',
      isCode: true,
    };

    const EXPECT_RESPONSE_WITHOUT_BODY = {
      label: 'Actual response:',
      content:
        '500 INTERNAL SERVER ERROR\nName1: Value1\nName2: Value2\n\n<Message body is not provided>',
      isCode: true,
    };

    const EXPECT_RESPONSE_WITH_EMPTY_STRING = {
      label: 'Actual response:',
      content: '500 INTERNAL SERVER ERROR\nName1: Value1\nName2: Value2',
      isCode: true,
    };

    const EXPECT_RECORDED_RESPONSE = {
      label: 'Unmodified response:',
      content: '200 OK\nName1: Value1\nName2: Value2\n\n[{"user_id":1,}]',
      isCode: true,
    };

    const EXPECT_RECORDED_RESPONSE_WITHOUT_REASON_PHRASE = {
      label: 'Unmodified response:',
      content: '200 \nName1: Value1\nName2: Value2\n\n[{"user_id":1,}]',
      isCode: true,
    };

    const EXPECT_RECORDED_RESPONSE_WITHOUT_BODY = {
      label: 'Unmodified response:',
      content: '200 OK\nName1: Value1\nName2: Value2\n\n<Message body is not provided>',
      isCode: true,
    };

    const EXPECT_RECORDED_RESPONSE_WITH_EMPTY_STRING = {
      label: 'Unmodified response:',
      content: '200 OK\nName1: Value1\nName2: Value2',
      isCode: true,
    };

    const getTextContent = (el) => el.textContent.trim();
    const getLabel = (el) => getTextContent(getByTestId(el, 'label'));
    const getContent = (el) => getTextContent(getByTestId(el, 'value'));
    const getSectionData = (testId) => {
      const selector = getById(testId);

      if (!selector.exists()) {
        return null;
      }

      return getAllByRole(selector.element, 'listitem').map((li) => ({
        label: getLabel(li),
        content: getContent(li),
        ...(li.querySelector('code') ? { isCode: true } : {}),
      }));
    };

    it.each`
      request                                                                                             | expectedData
      ${null}                                                                                             | ${null}
      ${{}}                                                                                               | ${null}
      ${{ headers: TEST_HEADERS }}                                                                        | ${null}
      ${{ method: 'GET' }}                                                                                | ${null}
      ${{ method: 'GET', url: 'http://www.gitlab.com' }}                                                  | ${null}
      ${{ method: 'GET', url: 'http://www.gitlab.com', body: '[{"user_id":1,}]' }}                        | ${null}
      ${{ headers: TEST_HEADERS, method: 'GET', url: 'http://www.gitlab.com', body: '[{"user_id":1,}]' }} | ${[EXPECT_REQUEST]}
      ${{ headers: TEST_HEADERS, method: 'GET', url: 'http://www.gitlab.com', body: null }}               | ${[EXPECT_REQUEST_WITHOUT_BODY]}
      ${{ headers: TEST_HEADERS, method: 'GET', url: 'http://www.gitlab.com', body: undefined }}          | ${[EXPECT_REQUEST_WITHOUT_BODY]}
      ${{ headers: TEST_HEADERS, method: 'GET', url: 'http://www.gitlab.com', body: '' }}                 | ${[EXPECT_REQUEST_WITH_EMPTY_STRING]}
    `('shows request data for $request', ({ request, expectedData }) => {
      createWrapper({ request });
      expect(getSectionData('request')).toEqual(expectedData);
    });

    it.each`
      response                                                                                                         | expectedData
      ${null}                                                                                                          | ${null}
      ${{}}                                                                                                            | ${null}
      ${{ headers: TEST_HEADERS }}                                                                                     | ${null}
      ${{ headers: TEST_HEADERS, body: '[{"user_id":1,}]' }}                                                           | ${null}
      ${{ headers: TEST_HEADERS, body: '[{"user_id":1,}]', statusCode: '500' }}                                        | ${[EXPECT_RESPONSE_WITHOUT_REASON_PHRASE]}
      ${{ headers: TEST_HEADERS, body: '[{"user_id":1,}]', statusCode: '500', reasonPhrase: 'INTERNAL SERVER ERROR' }} | ${[EXPECT_RESPONSE]}
      ${{ headers: TEST_HEADERS, body: null, statusCode: '500', reasonPhrase: 'INTERNAL SERVER ERROR' }}               | ${[EXPECT_RESPONSE_WITHOUT_BODY]}
      ${{ headers: TEST_HEADERS, body: undefined, statusCode: '500', reasonPhrase: 'INTERNAL SERVER ERROR' }}          | ${[EXPECT_RESPONSE_WITHOUT_BODY]}
      ${{ headers: TEST_HEADERS, body: '', statusCode: '500', reasonPhrase: 'INTERNAL SERVER ERROR' }}                 | ${[EXPECT_RESPONSE_WITH_EMPTY_STRING]}
    `('shows response data for $response', ({ response, expectedData }) => {
      createWrapper({ response });
      expect(getSectionData('response')).toEqual(expectedData);
    });

    it.each`
      supportingMessages                                                                                                                                         | expectedData
      ${null}                                                                                                                                                    | ${null}
      ${[]}                                                                                                                                                      | ${null}
      ${[{}]}                                                                                                                                                    | ${null}
      ${[{}, { response: {} }]}                                                                                                                                  | ${null}
      ${[{}, { response: { headers: TEST_HEADERS } }]}                                                                                                           | ${null}
      ${[{}, { response: { headers: TEST_HEADERS, body: '[{"user_id":1,}]' } }]}                                                                                 | ${null}
      ${[{}, { response: { headers: TEST_HEADERS, body: '[{"user_id":1,}]', status_code: '200' } }]}                                                             | ${null}
      ${[{}, { response: { headers: TEST_HEADERS, body: '[{"user_id":1,}]', status_code: '200', reason_phrase: 'OK' } }]}                                        | ${null}
      ${[{}, { name: SUPPORTING_MESSAGE_TYPES.RECORDED, response: { headers: TEST_HEADERS, body: '[{"user_id":1,}]', statusCode: '200' } }]}                     | ${[EXPECT_RECORDED_RESPONSE_WITHOUT_REASON_PHRASE]}
      ${[{}, { name: SUPPORTING_MESSAGE_TYPES.RECORDED, response: { headers: TEST_HEADERS, body: '[{"user_id":1,}]', statusCode: '200', reasonPhrase: 'OK' } }]} | ${[EXPECT_RECORDED_RESPONSE]}
      ${[{}, { name: SUPPORTING_MESSAGE_TYPES.RECORDED, response: { headers: TEST_HEADERS, body: null, statusCode: '200', reasonPhrase: 'OK' } }]}               | ${[EXPECT_RECORDED_RESPONSE_WITHOUT_BODY]}
      ${[{}, { name: SUPPORTING_MESSAGE_TYPES.RECORDED, response: { headers: TEST_HEADERS, body: undefined, statusCode: '200', reasonPhrase: 'OK' } }]}          | ${[EXPECT_RECORDED_RESPONSE_WITHOUT_BODY]}
      ${[{}, { name: SUPPORTING_MESSAGE_TYPES.RECORDED, response: { headers: TEST_HEADERS, body: '', statusCode: '200', reasonPhrase: 'OK' } }]}                 | ${[EXPECT_RECORDED_RESPONSE_WITH_EMPTY_STRING]}
    `('shows response data for $supporting_messages', ({ supportingMessages, expectedData }) => {
      createWrapper({ supportingMessages });
      expect(getSectionData('recorded-response')).toEqual(expectedData);
    });
  });

  describe('when `details` object is not empty', () => {
    beforeEach(() => {
      createWrapper({
        details: { codeFlows: { name: 'code_flows' } },
      });
    });

    it('renders with correct text and props', () => {
      const codeFlowButton = getById('show-code-flow');

      expect(codeFlowButton.exists()).toBe(true);
      expect(getText('show-code-flow')).toEqual(wrapper.vm.$options.i18n.codeFlowButton);
      expect(codeFlowButton.props('variant')).toBe('default');
      expect(codeFlowButton.props('category')).toBe('primary');
    });

    it('triggers router push on click', () => {
      getById('show-code-flow').trigger('click');

      expect($router.push).toHaveBeenCalledWith({
        path: '/',
        query: { tab: CODE_FLOW_TAB_URL },
      });
    });
  });

  describe('when `details` object is empty', () => {
    it('does not show the `code flow` button', () => {
      createWrapper({
        details: {},
      });
      expect(getById('show-code-flow').exists()).toBe(false);
    });
  });

  describe('dependency paths', () => {
    const location = {
      file: 'test.txt',
      blobPath: 'blob_path.txt',
      dependency: { version: '1.0', package: { name: 'uri' } },
    };

    it('passes the correct props', () => {
      const sbomOccurrences = [{ id: 1, inputFilePath: 'yarn.lock', hasDependencyPaths: true }];
      createWrapper({ location, sbomOccurrences });

      const { name } = location.dependency.package;
      const { version } = location.dependency;

      expect(findDependencyPath().props('component')).toMatchObject({
        name,
        version,
      });
      expect(findDependencyPath().props('sbomOccurrences')).toMatchObject(sbomOccurrences);
    });

    describe('when none of the occurrences have dependendency paths', () => {
      it('does not render component', () => {
        createWrapper({
          location,
          sbomOccurrences: [
            { id: 1, inputFilePath: 'yarn.lock', hasDependencyPaths: false },
            { id: 2, inputFilePath: 'yarn.lock', hasDependencyPaths: false },
          ],
        });
        expect(findDependencyPath().exists()).toBe(false);
      });
    });

    describe('when FF "dependency_path" is disabled', () => {
      it('does not render component', () => {
        createWrapper({ location }, { dependencyPaths: false });
        expect(findDependencyPath().exists()).toBe(false);
      });
    });
  });

  describe('reachability', () => {
    it('does not show reachable label', () => {
      createWrapper();
      expect(getById('reachability').exists()).toBe(false);
    });

    it.each`
      reachability   | text
      ${'unknown'}   | ${'Not available'}
      ${'not_found'} | ${'Not found'}
      ${'in_use'}    | ${'Yes'}
    `('renders component with reachability set to $reachability', ({ reachability, text }) => {
      createWrapper({ reachability });
      expect(getText('reachability')).toContain(text);
    });
  });

  describe('validity check', () => {
    it('does not show validity check when feature flag validityChecks is disabled', () => {
      const findingTokenStatus = { status: 'active' };
      createWrapper({ findingTokenStatus, reportType: 'secret_detection' });
      expect(getById('validityCheck').exists()).toBe(false);
    });

    it('does not show validity check when feature flag validityChecks is enabled but validityChecksEnabled is false', () => {
      const findingTokenStatus = { status: 'active' };
      createWrapper(
        { findingTokenStatus, validityChecksEnabled: false, reportType: 'secret_detection' },
        { validityChecks: true },
      );
      expect(getById('validityCheck').exists()).toBe(false);
    });

    describe('when validityChecks feature flag is enabled and validityChecksEnabled is true', () => {
      it('passes the correct status to TokenValidityBadge component', () => {
        const findingTokenStatus = { status: 'active' };
        createWrapper(
          { findingTokenStatus, validityChecksEnabled: true, reportType: 'secret_detection' },
          { validityChecks: true },
        );

        const tokenValidityBadge = wrapper.findComponent(TokenValidityBadge);
        expect(tokenValidityBadge.props('status')).toBe('active');
      });

      it('sets the experiment prop', () => {
        const findingTokenStatus = { status: 'active' };
        createWrapper(
          { findingTokenStatus, validityChecksEnabled: true, reportType: 'secret_detection' },
          { validityChecks: true },
        );

        expect(getById('validityCheck').props('showExperimentBadge')).toBe(true);
      });

      it('passes unknown status to TokenValidityBadge when findingTokenStatus is null', () => {
        createWrapper(
          { findingTokenStatus: null, validityChecksEnabled: true, reportType: 'secret_detection' },
          { validityChecks: true },
        );

        const tokenValidityBadge = wrapper.findComponent(TokenValidityBadge);
        expect(tokenValidityBadge.props('status')).toBe('unknown');
      });

      it('does not render TokenValidityBadge when reportType is not secret_detection', () => {
        const findingTokenStatus = { status: 'active' };
        createWrapper(
          { findingTokenStatus, validityChecksEnabled: true },
          { validityChecks: true },
        );

        const tokenValidityBadge = wrapper.findComponent(TokenValidityBadge);
        expect(tokenValidityBadge.exists()).toBe(false);
      });
    });
  });
});
