import Vue, { nextTick } from 'vue';
import VueApollo from 'vue-apollo';
import { GlTab, GlTabs, GlAlert, GlSprintf } from '@gitlab/ui';
import VueRouter from 'vue-router';
import fetchHeaderVulnerabilityQuery from 'ee/security_dashboard/graphql/header_vulnerability.graphql';
import VulnerabilityFooter from 'ee/vulnerabilities/components/footer.vue';
import VulnerabilityHeader from 'ee/vulnerabilities/components/header.vue';
import Vulnerability from 'ee/vulnerabilities/components/vulnerability.vue';
import VulnerabilityDetails from 'ee/vulnerabilities/components/vulnerability_details.vue';
import VulnerabilityCodeFlow from 'ee/vue_shared/components/code_flow/vulnerability_code_flow.vue';
import StickyVulnerabilityHeader from 'ee/vulnerabilities/components/sticky_vulnerability_header.vue';
import { stubComponent } from 'helpers/stub_component';
import createMockApollo from 'helpers/mock_apollo_helper';
import waitForPromises from 'helpers/wait_for_promises';
import { createAlert } from '~/alert';
import { VULNERABILITY_TAB_NAMES } from 'ee/vulnerabilities/constants';
import { SEVERITY_LEVEL_HIGH } from 'ee/security_dashboard/constants';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';

Vue.use(VueApollo);
jest.mock('~/alert');

describe('Vulnerability', () => {
  let fetchHeaderVulnerabilityQuerySpy;
  let wrapper;
  const router = new VueRouter();

  const getVulnerability = (props) => ({
    id: 1,
    created_at: new Date().toISOString(),
    report_type: 'sast',
    state: 'detected',
    create_mr_url: '/create_mr_url',
    new_issue_url: '/new_issue_url',
    pipeline: {
      id: 2,
      created_at: new Date().toISOString(),
      url: 'pipeline_url',
      sourceBranch: 'main',
    },
    description: 'description',
    identifiers: 'identifiers',
    links: 'links',
    location: 'location',
    name: 'name',
    project: {
      full_path: '/project_full_path',
      full_name: 'Test Project',
    },
    discussions_url: '/discussion_url',
    notes_url: '/notes_url',
    can_modify_related_issues: false,
    related_issues_help_path: '/help_path',
    merge_request_feedback: null,
    issue_feedback: null,
    remediation: null,
    archivalInformation: {},
    ...props,
  });

  const stickyTabs = [
    [undefined, 'Details', 'Active'],
    ['code_flow', 'Code flow', 'Inactive'],
  ];

  const createApolloProvider = (...queries) => {
    return createMockApollo([...queries]);
  };

  const createApolloProviderForVulnerabilityChange = (mockFn = jest.fn()) => {
    fetchHeaderVulnerabilityQuerySpy = mockFn.mockResolvedValue({
      data: {
        errors: [],
        vulnerability: {
          id: 'gid://gitlab/Vulnerability/54',
          resolvedAt: '2020-09-16T11:13:26Z',
          state: 'RESOLVED',
        },
      },
    });

    return createApolloProvider([fetchHeaderVulnerabilityQuery, fetchHeaderVulnerabilityQuerySpy]);
  };

  const createWrapper = ({ vulnData, apolloProvider } = {}) => {
    wrapper = shallowMountExtended(Vulnerability, {
      apolloProvider,
      router,
      propsData: {
        initialVulnerability: { ...getVulnerability(), ...vulnData },
      },
      provide: {
        projectFullPath: 'project/full/path',
        defaultBranch: 'main',
      },
      stubs: {
        VulnerabilityFooter: stubComponent(VulnerabilityFooter),
        StickyVulnerabilityHeader: true,
        GlSprintf,
        GlAlert,
      },
      mocks: {
        $route: {
          query: {},
        },
        $router: {
          push: jest.fn(),
        },
      },
    });
  };

  afterEach(() => {
    createAlert.mockReset();
  });

  const getById = (id) => wrapper.findByTestId(id);
  const findHeader = () => wrapper.findComponent(VulnerabilityHeader);
  const findVulnerabilityDetails = () => wrapper.findComponent(VulnerabilityDetails);
  const findVulnerabilityCodeFlow = () => wrapper.findComponent(VulnerabilityCodeFlow);
  const findFooter = () => wrapper.findComponent(VulnerabilityFooter);
  const findTabs = () => wrapper.findComponent(GlTabs);
  const findAllTab = () => wrapper.findAllComponents(GlTab);
  const findTabAtIndex = (index) => findAllTab().at(index);
  const findStickyHeader = () => wrapper.findComponent(StickyVulnerabilityHeader);

  describe('default behavior', () => {
    beforeEach(() => {
      createWrapper({ apolloProvider: createApolloProviderForVulnerabilityChange() });
    });

    it('consists of header, details, and footer', () => {
      expect(findHeader().exists()).toBe(true);
      expect(getById('title').exists()).toBe(false);
      expect(findVulnerabilityDetails().exists()).toBe(true);
      expect(findFooter().exists()).toBe(true);
      expect(findTabs().exists()).toBe(false);
      expect(findStickyHeader().exists()).toBe(false);
    });

    it('shows the title if it exists', () => {
      createWrapper({ vulnData: { title: 'some title' } });
      expect(getById('title').exists()).toBe(true);
      expect(getById('title').text()).toBe('some title');
    });

    it('passes the correct properties to the children', () => {
      const vulnerability = getVulnerability();
      expect(findHeader().props('vulnerability')).toEqual(vulnerability);
      expect(findVulnerabilityDetails().props('vulnerability')).toEqual(vulnerability);
      expect(findFooter().props('vulnerability')).toEqual(vulnerability);
    });
  });

  describe('vulnerability change events', () => {
    let refreshVulnerability;

    beforeEach(() => {
      refreshVulnerability = jest.fn();
      createWrapper({
        apolloProvider: createApolloProviderForVulnerabilityChange(refreshVulnerability),
      });
    });

    it('re-fetches the query when the footer emitted a state-change', async () => {
      expect(refreshVulnerability).toHaveBeenCalledTimes(0);

      findFooter().vm.$emit('vulnerability-state-change');
      await waitForPromises();

      expect(refreshVulnerability).toHaveBeenCalledTimes(1);
    });

    it('passes the updated vulnerability to the footer when the header emitted a state-change', async () => {
      const updatedVulnerability = getVulnerability({ state: 'dismissed' });
      findHeader().vm.$emit('vulnerability-state-change', updatedVulnerability);
      await waitForPromises();

      expect(findFooter().props('vulnerability')).toEqual(updatedVulnerability);
    });

    it('sets the new severity when the header emitted a severity-change', async () => {
      const uuid = '9fc97ae5-8d1b-4600-9f5d-9b48d7b948a6';
      const severity = SEVERITY_LEVEL_HIGH;
      const updatedVulnerability = getVulnerability({ uuid, severity });

      findHeader().vm.$emit('vulnerability-severity-change', updatedVulnerability);
      await waitForPromises();

      expect(findFooter().props('vulnerability')).toEqual(updatedVulnerability);
    });
  });

  describe('refresh vulnerability', () => {
    describe('on failure', () => {
      beforeEach(() => {
        const apolloProvider = createApolloProvider([
          fetchHeaderVulnerabilityQuery,
          jest.fn().mockRejectedValue({
            data: {
              errors: [{ message: 'something went wrong while fetching the vulnerability' }],
              vulnerability: null,
            },
          }),
        ]);

        createWrapper({ apolloProvider });
      });

      it('calls createAlert', async () => {
        findFooter().vm.$emit('vulnerability-state-change');
        await waitForPromises();
        expect(createAlert).toHaveBeenCalledTimes(1);
      });
    });
  });

  describe('when `details` object is not empty', () => {
    beforeEach(() => {
      createWrapper({
        vulnData: {
          details: {
            codeFlows: { name: 'code_flows' },
          },
        },
      });
    });

    it('render the sticky header when `showCodeFlowTabs` is true', () => {
      expect(findStickyHeader().exists()).toBe(true);
    });

    it('passes correct props to StickyVulnerabilityHeader', () => {
      const vulnerability = getVulnerability();
      expect(findStickyHeader().props('vulnerability')).toMatchObject(vulnerability);
      expect(findStickyHeader().props('tabs')).toEqual(stickyTabs);
    });

    describe.each`
      title                                | finderFn                     | index
      ${VULNERABILITY_TAB_NAMES.DETAILS}   | ${findVulnerabilityDetails}  | ${0}
      ${VULNERABILITY_TAB_NAMES.CODE_FLOW} | ${findVulnerabilityCodeFlow} | ${1}
    `('Tabs', ({ title, finderFn, index }) => {
      it(`renders tab with a title ${title} at index ${index}`, () => {
        expect(findTabAtIndex(index).attributes('title')).toBe(title);
      });

      it(`renders ${title} component`, () => {
        expect(finderFn().exists()).toBe(true);
      });

      it(`renders footer in ${title} component`, async () => {
        if (index !== 0) {
          await router.push({ query: { tab: title } });
          await nextTick();
          expect(router.currentRoute.query.tab).toBe(title);
          expect(getById('vulnerability-footer').exists()).toBe(false);
        } else {
          expect(findFooter().exists()).toBe(true);
        }
      });
    });
  });

  describe('when `details` object is empty', () => {
    beforeEach(() => {
      createWrapper({
        vulnData: { details: {} },
      });
    });

    it('does not render the sticky header when `showCodeFlowTabs` is false', () => {
      expect(findStickyHeader().exists()).toBe(false);
    });

    it('checks code flow button functionality', () => {
      expect(findTabs().exists()).toBe(false);
    });
  });

  describe('vulnerability archival', () => {
    const findAlert = () => wrapper.findComponent(GlAlert);

    it('renders an alert when the vulnerability is about to expire', () => {
      createWrapper({
        vulnData: {
          archivalInformation: {
            aboutToBeArchived: true,
            expectedToBeArchivedOn: '2026-03-02T00:00:00Z',
          },
        },
      });

      expect(findAlert().props('title')).toBe('Archive pending');
      expect(findAlert().text()).toContain(
        'Vulnerability will be archived on 2026-03-02. Why will this vulnerability be archived?',
      );
    });

    it('does not render the alert when the vulnerability is not about to expire', () => {
      createWrapper({
        vulnData: {
          archivalInformation: {
            aboutToBeArchived: false,
            expectedToBeArchivedOn: '2026-03-02T00:00:00Z',
          },
        },
      });

      expect(findAlert().exists()).toBe(false);
    });
  });
});
