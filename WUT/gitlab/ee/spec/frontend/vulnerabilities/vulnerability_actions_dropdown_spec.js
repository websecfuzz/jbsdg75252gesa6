import {
  GlAlert,
  GlDisclosureDropdown,
  GlButton,
  GlDisclosureDropdownItem,
  GlLink,
} from '@gitlab/ui';
import VulnerabilityActionsDropdown from 'ee/vulnerabilities/components/vulnerability_actions_dropdown.vue';
import { mountExtended } from 'helpers/vue_test_utils_helper';

describe('ee/vulnerabilities/components/vulnerability_actions_dropdown.vue', () => {
  let wrapper;

  const createWrapper = (propsData = {}) => {
    wrapper = mountExtended(VulnerabilityActionsDropdown, {
      propsData: {
        showDownloadPatch: false,
        showCreateMergeRequest: false,
        showExplainWithAi: false,
        showResolveWithAi: false,
        aiResolutionEnabled: true,
        showPublicProjectWarning: false,
        ...propsData,
      },
    });
  };

  const findButton = () => wrapper.findComponent(GlButton);
  const findDropdown = () => wrapper.findComponent(GlDisclosureDropdown);
  const findDropdownItem = () => wrapper.findComponent(GlDisclosureDropdownItem);
  const findActionItem = (actionName) => wrapper.findByTestId(`${actionName}-action-item`);
  const findActionItemTitle = (actionName) => wrapper.findByTestId(`${actionName}-action-title`);
  const findActionItemDescription = (actionName) =>
    wrapper.findByTestId(`${actionName}-action-description`);
  const triggerAction = (actionName) => findDropdownItem().vm.$emit('action', { name: actionName });

  const DOWLOAD_PATCH_ACTION = {
    propToEnable: 'showDownloadPatch',
    name: 'download-patch',
    text: 'Download Patch',
    description: 'Download the patch provided by the scanner to apply it manually.',
  };
  const CREATE_MERGE_REQUEST_ACTION = {
    propToEnable: 'showCreateMergeRequest',
    name: 'create-merge-request',
    text: 'Resolve with scanner suggestion',
    description: "Create a merge request to apply the scanner's software patch.",
  };
  const EXPLAIN_WITH_AI_ACTION = {
    propToEnable: 'showExplainWithAi',
    name: 'explain-vulnerability',
    text: 'Explain with AI',
    description:
      'Use GitLab Duo to provide insights about the vulnerability and suggested solutions.',
    icon: 'tanuki-ai',
  };
  const RESOLVE_WITH_AI_ACTION = {
    propToEnable: 'showResolveWithAi',
    name: 'resolve-vulnerability',
    text: 'Resolve with AI',
    description: 'Use GitLab Duo to generate a merge request with a suggested solution.',
    disabledStateDescription:
      'GitLab Duo is unable to suggest a fix for this type of vulnerability.',
    icon: 'tanuki-ai',
  };

  const ACTIONS = [
    DOWLOAD_PATCH_ACTION,
    CREATE_MERGE_REQUEST_ACTION,
    EXPLAIN_WITH_AI_ACTION,
    RESOLVE_WITH_AI_ACTION,
  ];

  it('does not render anything if no actions are enabled', () => {
    createWrapper();

    expect(wrapper.find('*').exists()).toBe(false);
  });

  describe.each(ACTIONS)(
    'when there is only one available action: "$name"',
    ({ propToEnable, text, icon, name, description }) => {
      beforeEach(() => {
        createWrapper({
          [propToEnable]: true,
        });
      });

      it('renders a button and no dropdown', () => {
        expect(findButton().exists()).toBe(true);
        expect(findDropdown().exists()).toBe(false);
      });

      it('renders the correct button text', () => {
        expect(wrapper.findComponent(GlButton).text()).toBe(text);
      });

      it('renders the correct button title', () => {
        expect(wrapper.findComponent(GlButton).attributes('title')).toBe(description);
      });

      it('renders an icon if there is one configured', () => {
        expect(findButton().props('icon')).toBe(icon || '');
      });

      it('emits the correct action event when the button is clicked', () => {
        expect(wrapper.emitted(name)).toBe(undefined);

        findButton().vm.$emit('click');

        expect(wrapper.emitted(name)).toHaveLength(1);
      });
    },
  );

  describe('when there are multiple actions available', () => {
    beforeEach(() => {
      createWrapper({
        showDownloadPatch: true,
        showCreateMergeRequest: true,
        showExplainWithAi: true,
        showResolveWithAi: true,
        aiResolutionAvailable: true,
      });
    });

    it('renders a dropdown component', () => {
      expect(findDropdown().exists()).toBe(true);
    });

    it('renders a list item for each action', () => {
      expect(wrapper.findAllComponents(GlDisclosureDropdownItem)).toHaveLength(ACTIONS.length);
    });

    it.each(ACTIONS)('renders the correct action item: "$name"', ({ name, text, description }) => {
      expect(findActionItem(name).exists()).toBe(true);
      expect(findActionItemTitle(name).text()).toBe(text);
      expect(findActionItemDescription(name).text()).toBe(description);
    });

    it.each(ACTIONS)('emits the correct event when the "$name" action is triggered', ({ name }) => {
      expect(wrapper.emitted(name)).toBeUndefined();

      triggerAction(name);

      expect(wrapper.emitted(name)).toHaveLength(1);
    });
  });

  describe.each`
    nonAiActionsEnabled | expectedText                    | expectedIcon
    ${true}             | ${'Resolutions'}                | ${false}
    ${false}            | ${'Explain or Resolve with AI'} | ${'tanuki-ai'}
  `(
    'when non-AI actions are enabled: "$nonAiActionsEnabled"',
    ({ nonAiActionsEnabled, expectedText, expectedIcon }) => {
      beforeEach(() => {
        createWrapper({
          showDownloadPatch: nonAiActionsEnabled,
          showCreateMergeRequest: nonAiActionsEnabled,
          showExplainWithAi: true,
          showResolveWithAi: true,
        });
      });

      it('renders the correct text for the dropdown component', () => {
        expect(findDropdown().props('toggleText')).toBe(expectedText);
      });

      it(`shows an icon: "${expectedIcon}"`, () => {
        expect(findDropdown().props('icon')).toBe(expectedIcon || '');
      });
    },
  );

  describe.each`
    aiResolutionEnabled | expectActionToBeDisabled | expectLinkToDocs
    ${true}             | ${false}                 | ${false}
    ${false}            | ${true}                  | ${true}
  `(
    'when the ai-resolution-enabled is "$aiResolutionEnabled"',
    ({ aiResolutionEnabled, expectActionToBeDisabled, expectLinkToDocs }) => {
      beforeEach(() => {
        createWrapper({
          showExplainWithAi: true,
          showResolveWithAi: true,
          aiResolutionEnabled,
        });
      });

      const findResolveDropdownItem = () =>
        wrapper.findByTestId('resolve-vulnerability-action-dropdown-item');

      it(`disables the action: ${expectActionToBeDisabled}`, () => {
        const expectedDisabledAttribute = expectActionToBeDisabled ? { disabled: true } : undefined;

        expect(findResolveDropdownItem().props('item').extraAttrs).toEqual(
          expectedDisabledAttribute,
        );
      });

      it('renders a text that explains why the resolve-ai action is currently not available', () => {
        const { description, disabledStateDescription } = RESOLVE_WITH_AI_ACTION;
        const expectedDescription = expectActionToBeDisabled
          ? disabledStateDescription
          : description;

        expect(findActionItemDescription('resolve-vulnerability').text()).toBe(expectedDescription);
      });

      it(`renders a link to the docs to explain why the action is disabled: "${expectLinkToDocs}"`, () => {
        const link = wrapper.findByTestId('resolve-vulnerability-action-docs-link');

        expect(link.exists()).toBe(expectLinkToDocs);

        if (expectLinkToDocs) {
          expect(link.attributes('href')).toBe(
            '/help/user/application_security/vulnerabilities/_index.md#supported-vulnerabilities-for-vulnerability-resolution',
          );
        }
      });
    },
  );

  describe('public-project warning', () => {
    const findWarningPopUp = () => wrapper.findComponent(GlAlert);

    const createWrapperWithAiFeaturesEnabled = ({ showPublicProjectWarning }) => {
      createWrapper({
        showExplainWithAi: true,
        aiResolutionEnabled: true,
        showResolveWithAi: true,
        showPublicProjectWarning,
      });
    };

    it.each([true, false])(
      'renders/does not render a warning when "showPublicProjectWarning" is: "%s"',
      (showPublicProjectWarning) => {
        createWrapperWithAiFeaturesEnabled({ showPublicProjectWarning });

        expect(findWarningPopUp().exists()).toBe(showPublicProjectWarning);
      },
    );

    describe('warning pop-up', () => {
      beforeEach(() => {
        createWrapperWithAiFeaturesEnabled({ showPublicProjectWarning: true });
      });

      it('renders an alert of the type "warning" that is not dismissible', () => {
        expect(findWarningPopUp().props()).toMatchObject({
          variant: 'warning',
          dismissible: false,
        });
      });

      it('contains the correct message', () => {
        expect(findWarningPopUp().text()).toMatchInterpolatedText(
          'Creating an MR from a public project will publicly expose the vulnerability and offered resolution. To create the MR privately, see Resolving a vulnerability privately.',
        );
      });

      it('contains a link to the documentation', () => {
        expect(findWarningPopUp().findComponent(GlLink).attributes('href')).toBe(
          '/help/user/application_security/vulnerabilities/_index#vulnerability-resolution',
        );
      });
    });
  });
});
