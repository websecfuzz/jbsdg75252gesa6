import { GlCard, GlCollapse, GlButton, GlAlert } from '@gitlab/ui';
import MockAdapter from 'axios-mock-adapter';
import Vue, { nextTick } from 'vue';
import VueApollo from 'vue-apollo';
import SectionLayout from '~/vue_shared/security_configuration/components/section_layout.vue';
import downloader from '~/lib/utils/downloader';
import axios from '~/lib/utils/axios_utils';
import { HTTP_STATUS_ACCEPTED, HTTP_STATUS_OK } from '~/lib/utils/http_status';
import { createAlert } from '~/alert';
import vulnerabilityArchivesQuery from 'ee/security_configuration/graphql/vulnerability_archives.query.graphql';
import { TEST_HOST } from 'helpers/test_constants';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import waitForPromises from 'helpers/wait_for_promises';
import createMockApollo from 'helpers/mock_apollo_helper';
import VulnerabilityArchives from 'ee/security_configuration/components/vulnerability_archives.vue';
import VulnerabilityArchivesTable from 'ee/security_configuration/components/vulnerability_archives_table.vue';
import mockData from './vulnerability_archives_mock_data';

Vue.use(VueApollo);
jest.mock('~/alert');
jest.mock('~/lib/utils/downloader');

describe('Vulnerability Archive component', () => {
  const projectFullPath = 'flightjs/security-reports';
  const vulnerabilityArchiveExportPath = `${TEST_HOST}/api/v4/export/archive`;

  let wrapper;
  let mockAxios;

  const defaultHandler = () => jest.fn().mockResolvedValue(mockData);
  const findSectionLayout = () => wrapper.findComponent(SectionLayout);
  const findCards = () => wrapper.findAllComponents(GlCard);
  const findAllGlCollapses = () => wrapper.findAllComponents(GlCollapse);
  const findYearButton = (year) =>
    wrapper.findAllComponents(GlButton).wrappers.find((w) => w.text() === year.toString());

  const mockCsvExportRequest = (status = 'finished') => {
    mockAxios
      .onPost(vulnerabilityArchiveExportPath)
      .reply(HTTP_STATUS_ACCEPTED, { _links: { self: 'status/url' } });

    mockAxios
      .onGet('status/url')
      .reply(HTTP_STATUS_OK, { _links: { download: 'download/path' }, status });
  };

  const createComponent = ({ propsData, handler = defaultHandler() } = {}) => {
    wrapper = shallowMountExtended(VulnerabilityArchives, {
      provide: {
        projectFullPath,
        vulnerabilityArchiveExportPath,
      },
      propsData,
      apolloProvider: createMockApollo([[vulnerabilityArchivesQuery, handler]]),
      stubs: {
        VulnerabilityArchivesTable,
        GlCard,
      },
    });
  };

  beforeEach(() => {
    mockAxios = new MockAdapter(axios);
    createComponent();
  });

  it('contains a section to describe the feature', () => {
    expect(findSectionLayout().props('heading')).toBe('Vulnerability archives');
    expect(
      wrapper
        .findByText(
          'Vulnerabilities are retained in the database for one year after the last update. After one year of inactivity, vulnerabilities are archived on the first of each month. Archives are removed after five years.',
        )
        .exists(),
    ).toBe(true);
    expect(
      wrapper
        .findByText('Learn more about our vulnerability data retention policies')
        .attributes('href'),
    ).toBe('/help/user/application_security/vulnerability_archival/_index.md');
  });

  it('fetches the archive data and displays a list view for each year', async () => {
    await waitForPromises();
    const cards = findCards();

    expect(cards).toHaveLength(4);

    const expectedYears = [2025, 2024, 2023, 2022];
    const expectedCounts = [142, 643, 607, 530];

    cards.wrappers.forEach((card, index) => {
      const text = card.text();
      expect(text).toContain('Download all');
      expect(text).toContain(expectedYears[index].toString());
      expect(text).toContain(expectedCounts[index].toString());
    });
  });

  it('displays the archive table when the year button is clicked', async () => {
    await waitForPromises();

    const collapses = findAllGlCollapses();

    expect(collapses).toHaveLength(4);

    collapses.wrappers.forEach((collapse) => {
      expect(collapse.props('visible')).toBe(false);
    });

    findYearButton(2025).vm.$emit('click');

    await nextTick();

    expect(collapses.at(0).props('visible')).toBe(true);
    expect(collapses.at(1).props('visible')).toBe(false);
    expect(collapses.at(2).props('visible')).toBe(false);
    expect(collapses.at(3).props('visible')).toBe(false);
  });

  it('should have the vulnerability archive table mounted for each row', async () => {
    await waitForPromises();

    const collapses = findAllGlCollapses();

    expect(collapses).toHaveLength(4);

    collapses.wrappers.forEach((w) => {
      expect(w.findComponent(VulnerabilityArchivesTable).exists()).toBe(true);
    });
  });

  describe('empty state', () => {
    beforeEach(() => {
      createComponent({
        handler: jest.fn().mockResolvedValue({
          data: {
            project: {
              id: 'gid://gitlab/Project/20',
              vulnerabilityArchives: [],
            },
          },
        }),
      });
    });

    it('should display an empty state message when there is nothing archived', async () => {
      await waitForPromises();

      const banner = wrapper.findComponent(GlAlert);
      expect(banner.props('variant')).toBe('tip');
      expect(banner.text()).toBe('This project does not contain any archived vulnerabilities yet.');
    });
  });

  describe('download archive functionality', () => {
    const findDownloadAllButton = (year) => wrapper.findByTestId(`${year}-download-all`);
    const expectExportRequestAndDownload = (startDate, endDate) => {
      expect(mockAxios.history.post).toHaveLength(1); // POST is the create report endpoint
      expect(JSON.parse(mockAxios.history.post[0].data)).toEqual({
        start_date: startDate,
        end_date: endDate,
      });
      expect(mockAxios.history.get).toHaveLength(1); // GET is the poll endpoint
      expect(downloader).toHaveBeenCalledTimes(1);
      expect(downloader).toHaveBeenCalledWith({
        url: 'download/path',
      });
    };

    it('handles downloading the full year', async () => {
      await waitForPromises();

      mockCsvExportRequest();

      const button = findDownloadAllButton(2025);
      expect(button.exists()).toBe(true);
      expect(button.props('loading')).toBe(false);
      await button.vm.$emit('click');
      expect(button.props('loading')).toBe(true);
      await axios.waitForAll();

      expectExportRequestAndDownload('01/01/2025', '31/12/2025');
    });

    it('handles downloading the archive for the given month', async () => {
      await waitForPromises();

      mockCsvExportRequest();

      const table = wrapper.findComponent(VulnerabilityArchivesTable);

      // This information is used for displaying the loading icon
      expect(table.props('preparingExportForPeriod')).toBe('');
      expect(table.props('year')).toBe(2025);

      await table.vm.$emit('download', 10);

      expect(table.props('preparingExportForPeriod')).toBe('2025-10');

      await axios.waitForAll();

      expectExportRequestAndDownload('01/11/2025', '30/11/2025');
    });

    it('shows the alert error when the export job status is failed', async () => {
      await waitForPromises();

      mockCsvExportRequest('', 'failed');

      findDownloadAllButton(2025).vm.$emit('click');
      await axios.waitForAll();

      expect(downloader).not.toHaveBeenCalled();
      expect(createAlert).toHaveBeenCalledWith({
        message: 'There was an error while generating the report.',
      });
    });
  });
});
