# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::VulnerabilityElasticSearchFinder, :elastic_delete_by_query, :sidekiq_inline, feature_category: :vulnerability_management do
  let_it_be_with_reload(:project) { create(:project) }

  let_it_be(:low_severity_vuln_read) do
    create(
      :vulnerability,
      :with_finding, :with_issue_links, :with_merge_request_links,
      severity: :low,
      report_type: :sast,
      state: :detected,
      project: project
    ).vulnerability_read.tap { |read| read.update!(has_vulnerability_resolution: true) }
  end

  let_it_be(:high_severity_vuln_read) do
    create(:vulnerability, :with_finding, resolved_on_default_branch: true, severity: :high,
      report_type: :dependency_scanning, state: :confirmed, project: project).vulnerability_read
  end

  let_it_be(:medium_severity_vuln_read) do
    create(:vulnerability, :with_finding, severity: :medium, report_type: :dast, state: :dismissed,
      project: project).vulnerability_read
  end

  let_it_be(:dismissed_vulnerability) { create(:vulnerability, :dismissed, severity: :low, project: project) }
  let_it_be(:dismissed_vulnerability_read) do
    create(
      :vulnerability_read,
      :used_in_tests,
      state: dismissed_vulnerability.state,
      severity: dismissed_vulnerability.severity,
      vulnerability: dismissed_vulnerability,
      project: project
    )
  end

  let_it_be(:vulnerability_dismissed_without_reason) do
    create(:vulnerability, :dismissed, severity: :low, project: project)
  end

  let_it_be(:vulnerability_dismissed_without_reason_read) do
    create(
      :vulnerability_read,
      dismissal_reason: nil,
      state: vulnerability_dismissed_without_reason.state,
      severity: vulnerability_dismissed_without_reason.severity,
      vulnerability: vulnerability_dismissed_without_reason,
      project: project
    )
  end

  let(:filters) { {} }
  let(:vulnerable) { project }

  subject(:execute) { described_class.new(vulnerable, filters).execute.to_a }

  before do
    stub_ee_application_setting(elasticsearch_search: true, elasticsearch_indexing: true)
  end

  describe '#execute' do
    context 'when not given a second argument' do
      subject(:finder_results) { described_class.new(vulnerable).execute.to_a }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read
        )
        ensure_elasticsearch_index!
      end

      it 'does not filter the vulnerability list' do
        expect(finder_results).to match_array([high_severity_vuln_read, medium_severity_vuln_read,
          vulnerability_dismissed_without_reason_read,
          dismissed_vulnerability_read, low_severity_vuln_read].map(&:vulnerability))
      end
    end

    context 'when using the include_archived_projects param' do
      using RSpec::Parameterized::TableSyntax

      let(:archive_associated_vulns) { archived_project.vulnerabilities.map(&:vulnerability_read) }
      let(:not_archived_vulns) { project.vulnerabilities.map(&:vulnerability_read) }
      let(:all_vulns) { archive_associated_vulns + not_archived_vulns }
      let_it_be(:group) { create(:group) }

      let_it_be(:project) do
        create(:project, namespace: group).tap do |p|
          create(:vulnerability, :with_read, project: p)
        end
      end

      let_it_be(:archived_project) do
        create(:project, :archived, namespace: group).tap do |p|
          create(:vulnerability, :with_read, project: p)
        end
      end

      before do
        Elastic::ProcessBookkeepingService.track!(*all_vulns)
        ensure_elasticsearch_index!
      end

      where(:vulnerable_object, :include_archived_projects, :result) do
        ref(:archived_project) | true   | ref(:archive_associated_vulns)
        ref(:archived_project) | false  | ref(:archive_associated_vulns)
        ref(:group) | true | ref(:all_vulns)
        ref(:group) | false | ref(:not_archived_vulns)
      end

      with_them do
        let(:vulnerable) { vulnerable_object }
        let(:filters) { super().merge(include_archived_projects: include_archived_projects) }

        it 'filters out vulnerabilities associated with archived projects as defined' do
          expect(execute).to match_array(result.map(&:vulnerability))
        end
      end
    end

    context 'when filtered by report type' do
      let(:filters) { { report_type: %w[sast dast] } }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read
        )
        ensure_elasticsearch_index!
      end

      it 'only returns vulnerabilities matching the given report types' do
        is_expected.to match_array([low_severity_vuln_read, medium_severity_vuln_read,
          vulnerability_dismissed_without_reason_read, dismissed_vulnerability_read].map(&:vulnerability))
      end
    end

    context 'when filtered by severity' do
      let(:filters) { { severity: %w[medium high] } }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read
        )
        ensure_elasticsearch_index!
      end

      it 'only returns vulnerabilities matching the given severities' do
        is_expected.to match_array([medium_severity_vuln_read, high_severity_vuln_read].map(&:vulnerability))
      end
    end

    context 'when filtered by state' do
      let(:filters) { { state: %w[detected confirmed] } }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read
        )
        ensure_elasticsearch_index!
      end

      it 'only returns vulnerabilities matching the given states' do
        is_expected.to match_array([low_severity_vuln_read, high_severity_vuln_read].map(&:vulnerability))
      end

      context 'when filtered only by dismissal reason' do
        let(:filters) { { dismissal_reason: ["used_in_tests"] } }

        it 'returns only vulnerabilities dismissed with used in tests reason' do
          is_expected.to match_array([dismissed_vulnerability_read].map(&:vulnerability))
        end
      end

      context 'when filtered only by state: dismissed' do
        let(:filters) { { state: %w[dismissed] } }

        it 'returns all dismissed vulnerabilities' do
          is_expected.to match_array([medium_severity_vuln_read, vulnerability_dismissed_without_reason_read,
            dismissed_vulnerability_read].map(&:vulnerability))
        end
      end

      context 'when filtered by dismissal reason and other states' do
        let(:filters) { { state: %w[confirmed dismissed], dismissal_reason: ["used_in_tests"] } }

        it 'returns dismissed vulnerabilities and those matching other states' do
          is_expected.to match_array([high_severity_vuln_read, medium_severity_vuln_read,
            vulnerability_dismissed_without_reason_read, dismissed_vulnerability_read].map(&:vulnerability))
        end
      end
    end

    context 'when filtered by scanner_id' do
      let(:filters) do
        { scanner_id: [low_severity_vuln_read.vulnerability.finding_scanner_id,
          medium_severity_vuln_read.vulnerability.finding_scanner_id] }
      end

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read
        )
        ensure_elasticsearch_index!
      end

      it 'only returns vulnerabilities matching the given scanner IDs' do
        is_expected.to match_array([low_severity_vuln_read, medium_severity_vuln_read].map(&:vulnerability))
      end
    end

    context 'when vulnerable is a Group' do
      let(:vulnerable) { group }

      let_it_be(:group) { create(:group) }
      let_it_be(:project) { create(:project, namespace: group) }
      let_it_be(:another_project) { create(:project, namespace: group) }
      let_it_be(:another_sast_vulnerability) do
        create(:vulnerability, :with_read, report_type: :sast, project: another_project)
      end

      before do
        Elastic::ProcessBookkeepingService.track!(
          another_sast_vulnerability.vulnerability_read
        )
        ensure_elasticsearch_index!
      end

      context 'when filtered by project' do
        let(:filters) { { project_id: [another_project.id, archived_project.id] } }

        let_it_be(:archived_project) { create(:project, :archived, namespace: group) }
        let_it_be(:archived_vulnerability) { create(:vulnerability, :with_read, project: archived_project) }

        before do
          Elastic::ProcessBookkeepingService.track!(
            archived_vulnerability.vulnerability_read
          )
          ensure_elasticsearch_index!
        end

        it 'only returns vulnerabilities matching the given projects' do
          is_expected.to match_array([another_sast_vulnerability])
        end

        context 'when including archived projects' do
          let(:filters) { super().merge(include_archived_projects: true) }

          it 'returns vulnerabilities matching the given projects' do
            is_expected.to match_array([another_sast_vulnerability,
              archived_vulnerability])
          end
        end
      end

      context 'when filtered by report type' do
        let(:filters) { { report_type: %w[sast] } }

        let_it_be(:non_sast_vuln) do
          create(:vulnerability, :with_read, :detected, report_type: :dast, project: another_project)
        end

        before do
          Elastic::ProcessBookkeepingService.track!(
            non_sast_vuln.vulnerability_read
          )
          ensure_elasticsearch_index!
        end

        it 'only returns vulnerabilities matching the given report type' do
          is_expected.to match_array(another_sast_vulnerability)
        end
      end

      context 'when filtered by state' do
        let(:filters) { { state: %w[detected] } }

        let_it_be(:non_detected_vuln) do
          create(:vulnerability, :with_read, :confirmed, project: another_project)
        end

        before do
          Elastic::ProcessBookkeepingService.track!(
            non_detected_vuln.vulnerability_read
          )
          ensure_elasticsearch_index!
        end

        it 'only returns vulnerabilities matching the given state' do
          is_expected.to match_array(another_sast_vulnerability)
        end
      end

      describe 'before and after severity filters' do
        let_it_be(:another_low_vulnerability) do
          create(:vulnerability, :with_read, :low, project: another_project)
        end

        let_it_be(:another_critical_vulnerability) do
          create(:vulnerability, :with_read, :critical, project: another_project)
        end

        subject(:executed) { described_class.new(vulnerable, filters).execute.first(100) }

        before do
          Elastic::ProcessBookkeepingService.track!(
            another_low_vulnerability.vulnerability_read,
            another_critical_vulnerability.vulnerability_read
          )
          ensure_elasticsearch_index!
        end

        context 'when filtered by `before_severity`' do
          context 'when the sort order is ascending' do
            let(:filters) { { before_severity: :high, sort: 'severity_asc' } }

            it "gets records sorted in ascending order by severity" do
              is_expected.to eq([
                another_low_vulnerability,
                another_sast_vulnerability
              ])
            end
          end

          context 'when the sort order is descending' do
            let(:filters) { { before_severity: :high, sort: 'severity_desc' } }

            it "gets records sorted in descending order by severity" do
              is_expected.to eq([
                another_critical_vulnerability,
                another_sast_vulnerability
              ])
            end
          end
        end

        context 'when filtered by `after_severity`' do
          context 'when the sort order is ascending' do
            let(:filters) { { after_severity: :high, sort: 'severity_asc' } }

            it "gets records sorted in ascending order by severity" do
              is_expected.to eq([
                another_sast_vulnerability,
                another_critical_vulnerability
              ])
            end
          end

          context 'when the sort order is descending' do
            let(:filters) { { after_severity: :high, sort: 'severity_desc' } }

            it "gets records sorted in descending order by severity" do
              is_expected.to eq([
                another_sast_vulnerability,
                another_low_vulnerability
              ])
            end
          end
        end
      end
    end

    context 'when sorted' do
      subject(:executed) { described_class.new(vulnerable, filters).execute.first(100) }

      let(:filters) { { sort: method } }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read
        )
        ensure_elasticsearch_index!
      end

      context 'when sort method is not given' do
        let(:method) { nil }

        it "returns results sorted by severity desc" do
          is_expected.to eq [high_severity_vuln_read, medium_severity_vuln_read,
            vulnerability_dismissed_without_reason_read,
            dismissed_vulnerability_read, low_severity_vuln_read].map(&:vulnerability)
        end
      end

      context 'when ascending by severity' do
        let(:method) { :severity_asc }

        it "returns results sorted by severity asc" do
          is_expected.to eq [vulnerability_dismissed_without_reason_read,
            dismissed_vulnerability_read, low_severity_vuln_read,
            medium_severity_vuln_read, high_severity_vuln_read].map(&:vulnerability)
        end
      end

      context 'when descending by severity' do
        let(:method) { :severity_desc }

        it "returns results sorted by severity desc" do
          is_expected.to eq [high_severity_vuln_read, medium_severity_vuln_read,
            vulnerability_dismissed_without_reason_read,
            dismissed_vulnerability_read, low_severity_vuln_read].map(&:vulnerability)
        end
      end

      context 'when ascending by detected_at' do
        let(:method) { :detected_asc }

        it "returns results sorted by vulnerability_id asc" do
          is_expected.to eq [low_severity_vuln_read, high_severity_vuln_read, medium_severity_vuln_read,
            dismissed_vulnerability_read, vulnerability_dismissed_without_reason_read].map(&:vulnerability)
        end
      end

      context 'when descending by detected_at' do
        let(:method) { :detected_desc }

        it "returns results sorted by vulnerability_id desc" do
          is_expected.to eq [vulnerability_dismissed_without_reason_read, dismissed_vulnerability_read,
            medium_severity_vuln_read, high_severity_vuln_read, low_severity_vuln_read].map(&:vulnerability)
        end
      end
    end

    context 'when filtered by has_issues argument' do
      let(:filters) { { has_issues: has_issues } }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read
        )
        ensure_elasticsearch_index!
      end

      context 'when has_issues is set to true' do
        let(:has_issues) { true }

        it 'only returns vulnerabilities that have issues' do
          is_expected.to match_array([low_severity_vuln_read].map(&:vulnerability))
        end
      end

      context 'when has_issues is set to false' do
        let(:has_issues) { false }

        it 'only returns vulnerabilities that does not have issues' do
          is_expected.to match_array([high_severity_vuln_read, medium_severity_vuln_read,
            vulnerability_dismissed_without_reason_read, dismissed_vulnerability_read].map(&:vulnerability))
        end
      end
    end

    context 'when filtered by has_merge_request argument' do
      let(:filters) { { has_merge_request: has_merge_request } }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read
        )
        ensure_elasticsearch_index!
      end

      context 'when has_merge_request is set to true' do
        let(:has_merge_request) { true }

        it 'only returns vulnerabilities that have merge_request' do
          is_expected.to match_array([low_severity_vuln_read].map(&:vulnerability))
        end
      end

      context 'when has_merge_request is set to false' do
        let(:has_merge_request) { false }

        it 'only returns vulnerabilities that does not have merge_request' do
          is_expected.to match_array([high_severity_vuln_read, medium_severity_vuln_read,
            vulnerability_dismissed_without_reason_read, dismissed_vulnerability_read].map(&:vulnerability))
        end
      end
    end

    context 'when filtered by has_resolution argument' do
      let(:filters) { { has_resolution: has_resolution } }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read
        )
        ensure_elasticsearch_index!
      end

      context 'when has_resolution is set to true' do
        let(:has_resolution) { true }

        it 'only returns vulnerabilities that have resolution' do
          is_expected.to match_array([high_severity_vuln_read].map(&:vulnerability))
        end
      end

      context 'when has_resolution is set to false' do
        let(:has_resolution) { false }

        it 'only returns vulnerabilities that do not have resolution' do
          is_expected.to match_array([low_severity_vuln_read, medium_severity_vuln_read,
            vulnerability_dismissed_without_reason_read, dismissed_vulnerability_read].map(&:vulnerability))
        end
      end
    end

    context 'when filtered by has_ai_resolution argument' do
      let(:filters) { { has_ai_resolution: has_ai_resolution } }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read
        )
        ensure_elasticsearch_index!
      end

      context 'when filter is set to true' do
        let(:has_ai_resolution) { true }

        it 'only returns vulnerabilities that are eligible to be resolved by an LLM' do
          is_expected.to match_array([low_severity_vuln_read].map(&:vulnerability))
        end
      end

      context 'when filter is set to false' do
        let(:has_ai_resolution) { false }
        let(:expected_vulnerability_reads) do
          [
            high_severity_vuln_read,
            medium_severity_vuln_read,
            vulnerability_dismissed_without_reason_read,
            dismissed_vulnerability_read
          ]
        end

        it 'only returns vulnerabilities that are ineligible to be resolved by an LLM' do
          is_expected.to match_array(expected_vulnerability_reads.map(&:vulnerability))
        end
      end
    end

    context 'when filtered by more than one property' do
      let_it_be(:read4) do
        create(:vulnerability, :with_finding, severity: :medium, report_type: :sast, state: :detected,
          project: project).vulnerability_read
      end

      let(:filters) { { report_type: %w[sast], severity: %w[medium] } }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read,
          read4
        )
        ensure_elasticsearch_index!
      end

      it 'only returns vulnerabilities matching all of the given filters' do
        is_expected.to match_array([read4].map(&:vulnerability))
      end
    end

    context 'when filtered by scanner external ID' do
      let(:filters) do
        { scanner: [low_severity_vuln_read.vulnerability.finding_scanner_external_id,
          high_severity_vuln_read.vulnerability.finding_scanner_external_id] }
      end

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read
        )
        ensure_elasticsearch_index!
      end

      it 'only returns vulnerabilities matching the given scanner IDs' do
        is_expected.to match_array([low_severity_vuln_read, high_severity_vuln_read].map(&:vulnerability))
      end
    end

    context 'when filtered by image' do
      let(:vulnerable) { project }
      let_it_be(:cluster_vulnerability) { create(:vulnerability, :cluster_image_scanning, project: project) }
      let_it_be(:finding) do
        create(:vulnerabilities_finding, :with_cluster_image_scanning_scanning_metadata, project: project,
          vulnerability: cluster_vulnerability)
      end

      let(:filters) { { image: [finding.location['image']] } }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read,
          cluster_vulnerability.vulnerability_read
        )
        ensure_elasticsearch_index!
      end

      it 'only returns vulnerabilities matching the given image' do
        is_expected.to match_array([cluster_vulnerability])
      end

      context 'when different report_type is passed' do
        let(:filters) { { report_type: %w[dast], image: [finding.location['image']] } }

        it 'returns an empty relation' do
          is_expected.to be_empty
        end
      end
    end

    context 'when filtered by cluster_agent_id' do
      let_it_be(:cluster_agent) { create(:cluster_agent, project: project) }
      let_it_be(:cluster_vulnerability) { create(:vulnerability, :cluster_image_scanning, project: project) }
      let_it_be(:finding) do
        create(:vulnerabilities_finding, :with_cluster_image_scanning_scanning_metadata,
          agent_id: cluster_agent.id.to_s, project: project, vulnerability: cluster_vulnerability)
      end

      let(:filters) { { cluster_agent_id: [finding.location['kubernetes_resource']['agent_id'].to_i] } }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read,
          cluster_vulnerability.vulnerability_read
        )
        ensure_elasticsearch_index!
      end

      it 'only returns vulnerabilities matching the given agent_id' do
        is_expected.to match_array([cluster_vulnerability])
      end

      context 'when different report_type is passed' do
        let(:filters) do
          { report_type: %w[dast], cluster_agent_id: [finding.location['kubernetes_resource']['agent_id'].to_i] }
        end

        it 'returns empty list' do
          is_expected.to be_empty
        end
      end
    end

    context 'when filtered by has_remediations argument' do
      let(:filters) { { has_remediations: has_remediations } }
      let_it_be(:vulnerability_read_with_remediations) do
        create(:vulnerability_read, :with_remediations, project: project)
      end

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read,
          vulnerability_read_with_remediations
        )
        ensure_elasticsearch_index!
      end

      context 'when has_remediations is set to true' do
        let(:has_remediations) { true }

        it 'only returns vulnerabilities with remediations' do
          is_expected.to match_array([vulnerability_read_with_remediations].map(&:vulnerability))
        end
      end

      context 'when has_remediations is set to false' do
        let(:has_remediations) { false }

        it 'only returns vulnerabilities without remediations' do
          is_expected.to match_array([low_severity_vuln_read,
            medium_severity_vuln_read,
            high_severity_vuln_read,
            vulnerability_dismissed_without_reason_read,
            dismissed_vulnerability_read].map(&:vulnerability))
        end
      end
    end

    context 'when filtered by owasp_top_10' do
      let(:filters) { { owasp_top_10: owasp_top_10 } }

      let_it_be(:vuln_read_without_owasp) { create(:vulnerability_read, severity: :medium, project: project) }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read,
          vuln_read_without_owasp
        )
        ensure_elasticsearch_index!
      end

      context 'when vulnerabilities with owasp_top_10 exist' do
        let(:owasp_top_10) { ['A4:2017-XML External Entities (XXE)'] }

        let_it_be(:owasp_top_10_vulnerability) do
          create(:vulnerability_read, :with_owasp_top_10,
            owasp_top_10: 'A4:2017-XML External Entities (XXE)', severity: :low, project: project,
            identifier_names: ['A4:2017 - XML External Entities (XXE)'])
        end

        before do
          Elastic::ProcessBookkeepingService.track!(
            owasp_top_10_vulnerability
          )
          ensure_elasticsearch_index!
        end

        it 'returns only owasp_top_10 vulnerabilities' do
          is_expected.to match_array([owasp_top_10_vulnerability].map(&:vulnerability))
        end
      end

      context 'when the given owasp_top_10 value does not exist' do
        let(:owasp_top_10) { ['A1:2017-Injection'] }

        it 'returns empty relation' do
          is_expected.to be_empty
        end
      end

      context 'when owasp_top_10 is nil' do
        let(:owasp_top_10) { nil }

        it 'returns all vulnerabilities' do
          is_expected.to match_array([low_severity_vuln_read,
            medium_severity_vuln_read,
            high_severity_vuln_read,
            vulnerability_dismissed_without_reason_read,
            dismissed_vulnerability_read,
            vuln_read_without_owasp].map(&:vulnerability))
        end
      end

      context 'when owasp_top_10 filter is none' do
        let(:owasp_top_10) { ['none'] }

        let_it_be(:owasp_top_10_vulnerability) do
          create(:vulnerability_read, :with_owasp_top_10,
            owasp_top_10: 'A4:2017-XML External Entities (XXE)', severity: :low, project: project,
            identifier_names: ['A4:2017 - XML External Entities (XXE)'])
        end

        before do
          Elastic::ProcessBookkeepingService.track!(
            owasp_top_10_vulnerability
          )
          ensure_elasticsearch_index!
        end

        it 'returns only vulnerabilities with empty owasp_top_10' do
          is_expected.to match_array([
            low_severity_vuln_read,
            high_severity_vuln_read,
            medium_severity_vuln_read,
            dismissed_vulnerability_read,
            vulnerability_dismissed_without_reason_read,
            vuln_read_without_owasp
          ].map(&:vulnerability))
        end
      end

      context 'when vulnerable is a group' do
        let(:vulnerable) { group }
        let(:owasp_top_10) { ['A1:2017-Injection'] }

        let_it_be(:group) { create(:group) }
        let_it_be(:project) { create(:project, namespace: group) }
        let_it_be(:vuln_read_without_owasp) { create(:vulnerability_read, severity: :medium, project: project) }

        before do
          Elastic::ProcessBookkeepingService.track!(
            vuln_read_without_owasp
          )
          ensure_elasticsearch_index!
        end

        context 'when vulnerabilities with owasp_top_10 exist' do
          let_it_be(:vuln_read_with_owasp_top_10) do
            create(:vulnerability_read, :with_owasp_top_10,
              severity: :high, project: project, identifier_names: ['A1:2017 - Injection'])
          end

          before do
            Elastic::ProcessBookkeepingService.track!(
              vuln_read_with_owasp_top_10
            )
            ensure_elasticsearch_index!
          end

          it 'returns only owasp_top_10 vulnerabilities' do
            is_expected.to match_array([vuln_read_with_owasp_top_10].map(&:vulnerability))
          end
        end
      end
    end

    context 'when filtered by owasp_top_10_2021' do
      let(:filters) { { owasp_top_10_2021: owasp_top_10_2021 } }

      let_it_be(:vuln_read_without_owasp) { create(:vulnerability_read, severity: :medium, project: project) }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read,
          vuln_read_without_owasp
        )
        ensure_elasticsearch_index!
      end

      context 'when vulnerabilities with owasp_top_10 exist' do
        let(:owasp_top_10_2021) { ['A1:2021-Broken Access Control'] }

        let_it_be(:owasp_top_10_vulnerability) do
          create(:vulnerability_read, :with_owasp_top_10,
            owasp_top_10: 'A1:2021-Broken Access Control', severity: :low, project: project,
            identifier_names: ['A1:2021 - Broken Access Control'])
        end

        before do
          Elastic::ProcessBookkeepingService.track!(
            owasp_top_10_vulnerability
          )
          ensure_elasticsearch_index!
        end

        it 'returns only owasp_top_10_2021 vulnerabilities' do
          is_expected.to match_array([owasp_top_10_vulnerability].map(&:vulnerability))
        end
      end

      context 'when the given owasp_top_10 value does not exist' do
        let(:owasp_top_10_2021) { ['A3:2021-Injection'] }

        it 'returns empty relation' do
          is_expected.to be_empty
        end
      end

      context 'when owasp_top_10_2021 filter is none' do
        let(:owasp_top_10_2021) { ['none'] }

        let_it_be(:owasp_top_10_vulnerability) do
          create(:vulnerability_read, :with_owasp_top_10,
            owasp_top_10: 'A03:2021-Injection', severity: :low, project: project,
            identifier_names: ['A03:2021 - Injection'])
        end

        before do
          Elastic::ProcessBookkeepingService.track!(
            owasp_top_10_vulnerability
          )
          ensure_elasticsearch_index!
        end

        it 'returns only vulnerabilities with empty owasp_top_10' do
          is_expected.to match_array([
            low_severity_vuln_read,
            high_severity_vuln_read,
            medium_severity_vuln_read,
            dismissed_vulnerability_read,
            vulnerability_dismissed_without_reason_read,
            vuln_read_without_owasp
          ].map(&:vulnerability))
        end
      end
    end

    context 'when filtered by identifier_name' do
      let_it_be(:vul_read_without_identifier_name) { create(:vulnerability_read, project: project) }
      let_it_be(:identifier_name) { 'CVE-2024-1234' }
      let_it_be(:vul_read_with_identifier_name) do
        create(:vulnerability_read, :with_identifer_name, identifier_names: [identifier_name], project: project)
      end

      let(:filters) { { identifier_name: identifier_name } }

      before do
        Elastic::ProcessBookkeepingService.track!(
          low_severity_vuln_read,
          high_severity_vuln_read,
          medium_severity_vuln_read,
          dismissed_vulnerability_read,
          vulnerability_dismissed_without_reason_read,
          vul_read_without_identifier_name,
          vul_read_with_identifier_name
        )
        ensure_elasticsearch_index!
      end

      shared_examples 'returns without filtering' do
        it 'returns all vulnerabilities' do
          is_expected.to match_array([low_severity_vuln_read,
            medium_severity_vuln_read,
            high_severity_vuln_read,
            vulnerability_dismissed_without_reason_read,
            dismissed_vulnerability_read,
            vul_read_without_identifier_name,
            vul_read_with_identifier_name].map(&:vulnerability))
        end

        it 'returns early without filtering' do
          expect(::Vulnerabilities::Read).not_to receive(:with_identifier_name)
          execute
        end
      end

      it 'returns only vulnerabilities with the specified identifier name' do
        is_expected.to match_array([vul_read_with_identifier_name].map(&:vulnerability))
      end

      context 'when filter by identifier_name is not provided' do
        let(:filters) { {} }

        it_behaves_like 'returns without filtering'
      end

      context 'when vulnerable is a group' do
        let(:vulnerable) { group }
        let(:filters) { { identifier_name: identifier_name } }

        let_it_be(:group) { create(:group) }
        let_it_be(:project) { create(:project, namespace: group) }
        let_it_be(:vul_read_without_identifier_name) { create(:vulnerability_read, project: project) }
        let_it_be(:vul_read_with_identifier_name) do
          create(:vulnerability_read, :with_identifer_name, identifier_names: [identifier_name], project: project)
        end

        before do
          Elastic::ProcessBookkeepingService.track!(
            vul_read_without_identifier_name,
            vul_read_with_identifier_name
          )
          ensure_elasticsearch_index!
        end

        it 'returns only vulnerabilities with the specified identifier name' do
          is_expected.to match_array([vul_read_with_identifier_name.vulnerability])
        end
      end
    end

    it_behaves_like 'a vulnerability elastic finder'
  end
end
