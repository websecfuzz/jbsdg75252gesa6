# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::Elastic::Delete::VulnerabilityService, feature_category: :vulnerability_management do
  include ElasticsearchHelpers

  let_it_be(:vulnerability_index) { Search::Elastic::Types::Vulnerability.index_name }
  let_it_be(:test_project_id) { 123 }
  let_it_be(:test_traversal_id) { 1 }

  before do
    stub_ee_application_setting(elasticsearch_search: true, elasticsearch_indexing: true)
  end

  def items_in_vulnerability_index
    items_in_index(vulnerability_index, 'vulnerability_id')
  end

  describe '.execute', :elastic do
    context 'with Elasticsearch integration' do
      let!(:old_group) { create(:group) }
      let!(:project) { create(:project, group: old_group) }
      let_it_be(:new_group) { create(:group) }

      before do
        # Not involved in the deletion process. Required to create ES docs for integration testing.
        allow(::Search::Elastic::VulnerabilityIndexingHelper).to receive(
          :vulnerability_indexing_allowed?).and_return(true)
      end

      context 'when project has vulnerabilities with different traversal_ids' do
        before do
          create_list(:vulnerability, 3, :with_read, project: project, group: old_group)
          ensure_elasticsearch_index!

          project.update_attribute(:namespace_id, new_group.id)
          create_list(:vulnerability, 2, :with_read, project: project, group: new_group)
          ensure_elasticsearch_index!
        end

        it 'deletes only vulnerabilities with old traversal_id' do
          expect(items_in_vulnerability_index.count).to eq(5)

          described_class.execute(project_id: project.id, traversal_id: new_group.id)
          es_helper.refresh_index(index_name: vulnerability_index)

          expect(items_in_vulnerability_index.count).to eq(2)
          expect(items_in_vulnerability_index).to match_array(
            Vulnerabilities::Read.where(project_id: project.id, traversal_ids: [new_group.id])
                                 .pluck(:vulnerability_id)
          )
        end
      end

      context 'when multiple projects documents exist' do
        let_it_be(:another_group) { create(:group) }
        let_it_be(:another_project) { create(:project, group: another_group) }

        before do
          # Create vulnerabilities for first project with old group
          create_list(:vulnerability, 3, :with_read, project: project, group: old_group)
          ensure_elasticsearch_index!

          # Update project to new group and create more vulnerabilities
          project.update_attribute(:namespace_id, new_group.id)
          create_list(:vulnerability, 2, :with_read, project: project, group: new_group)
          ensure_elasticsearch_index!

          # Create vulnerabilities for another project
          create_list(:vulnerability, 1, :with_read, project: another_project, group: another_group)
          ensure_elasticsearch_index!
        end

        it 'only deletes vulnerabilities from the specified project' do
          described_class.execute(project_id: project.id, traversal_id: new_group.id)
          es_helper.refresh_index(index_name: vulnerability_index)

          # Verify first project's documents with old traversal_id are deleted
          project_old_items = es_helper.client.search(
            index: vulnerability_index,
            body: {
              query: {
                bool: {
                  filter: [
                    { term: { project_id: project.id } },
                    { prefix: { traversal_ids: old_group.id } }
                  ]
                }
              }
            }
          )['hits']['total']['value']
          expect(project_old_items).to eq(0)

          # Verify first project's documents with new traversal_id remain
          project_new_items = es_helper.client.search(
            index: vulnerability_index,
            body: {
              query: {
                bool: {
                  filter: [
                    { term: { project_id: project.id } },
                    { prefix: { traversal_ids: new_group.id } }
                  ]
                }
              }
            }
          )['hits']['total']['value']
          expect(project_new_items).to eq(2)

          # Verify another project's documents are unaffected
          another_project_items = es_helper.client.search(
            index: vulnerability_index,
            body: {
              query: {
                bool: {
                  filter: [
                    { term: { project_id: another_project.id } },
                    { prefix: { traversal_ids: another_group.id } }
                  ]
                }
              }
            }
          )['hits']['total']['value']
          expect(another_project_items).to eq(1)
        end
      end
    end
  end

  describe '#execute' do
    let(:service) { described_class.new(options) }

    context 'when project_id and traversal_id are present' do
      let(:options) { { project_id: test_project_id, traversal_id: test_traversal_id } }

      it 'calls remove_documents' do
        expect(service).to receive(:remove_documents)
        service.execute
      end
    end

    context 'when project_id is missing' do
      let(:options) { { traversal_id: test_traversal_id } }

      it 'raises an exception' do
        expect { service.execute }.to raise_exception(ArgumentError)
      end
    end

    context 'when traversal_id is missing' do
      let(:options) { { project_id: test_project_id } }

      it 'returns without calling remove_documents' do
        expect { service.execute }.to raise_exception(ArgumentError)
      end
    end
  end

  describe '#build_query' do
    let(:service) { described_class.new(project_id: test_project_id, traversal_id: test_traversal_id) }

    it 'returns the correct query structure' do
      expected_query = {
        query: {
          bool: {
            filter: [
              { term: { project_id: test_project_id } },
              { bool: { must_not: { prefix: { traversal_ids: { value: test_traversal_id } } } } }
            ]
          }
        }
      }

      expect(service.send(:build_query)).to eq(expected_query)
    end
  end
end
