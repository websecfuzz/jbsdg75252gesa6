# frozen_string_literal: true

require 'spec_helper'

RSpec.describe MergeRequests::CreateFromVulnerabilityDataService, '#execute', feature_category: :vulnerability_management do
  let_it_be(:group) { create(:group) }
  let_it_be(:user) { create(:user, developer_of: group) }

  let_it_be(:expected_source_branch) { 'remediate/authentication-bypass-via-incorrect-dom-traversal-and-canonical' }
  let_it_be(:source_code) do
    <<~SOURCE
      #include <stdio.h>

      int main(int argc, char *argv[])
      {
        char buf[8];
        memcpy(&buf, "123456789");
        printf("hello, world!");
      }
    SOURCE
  end

  let_it_be(:summary_data) do
    <<~SUMMARY
      1. The reported vulnerability is a buffer overflow in the main() function, where a 9-byte string is copied into an 8-byte buffer.

      2. The fix addresses this issue by:

      - Increasing the buffer size to 10 bytes to accommodate the 9-byte string plus a null terminator.
      - Changing memcpy(&buf, "123456789") to memcpy(buf, "123456789", 9).

      3. These changes ensure that:

      - The buffer is large enough to hold the string.
      - The correct number of bytes (9) is copied.
      - The &amp; operator is removed from buf, as it's unnecessary and incorrect when used with memcpy().

      This fix prevents buffer overflow by ensuring that the destination buffer is large enough to hold the source data. It maintains the original functionality while adhering to secure coding practices.

      Additional recommendations:

      - Consider using strncpy() or snprintf() for string operations, as they provide more safety features.
      - Always check the return value of memory operations for error handling.
      - If the string length is known at compile-time, consider using sizeof() for buffer allocation to prevent manual size miscalculations.

      char buf[sizeof("123456789")];
      strncpy(buf, "123456789", sizeof(buf));
      buf[sizeof(buf) - 1] = '\\0'  // Ensure null-termination

      This approach would further improve the code's safety and maintainability.
    SUMMARY
  end

  let_it_be(:analysis_data) do
    <<~ANALYSIS
      The vulnerability report lacks specific details about the type of vulnerability, making it challenging to directly correlate with the provided code. However, upon examining the source code, a clear buffer overflow vulnerability is present.
      The vulnerable code section is:

      char buf[8];
      memcpy(&buf, "123456789");

      This code creates a buffer buf of size 8 bytes, but then attempts to copy 9 bytes (the string "123456789") into it using memcpy(). This results in a buffer overflow, which can lead to memory corruption, crashes, or even arbitrary code execution in some cases.
      The vulnerability falls under the category of CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer.
      This is a genuine security concern as buffer overflows can be exploited by attackers to manipulate program behavior or execute malicious code.
    ANALYSIS
  end

  let(:service) { described_class.new(project, vulnerability, user, params) }
  let(:vulnerability) { create(:vulnerability, findings: [finding], severity: 'unknown') }
  let(:params) { {} }
  let(:result) { service.execute }
  let(:project) { create(:project, :custom_repo, namespace: group, files: project_files) }
  let(:project_files) { { 'src/main.c' => source_code } }

  shared_examples 'a created merge_request' do
    it 'creates the merge_request with the given params' do
      expect(result[:status]).to eq(:success)
      merge_request = result[:merge_request]
      expect(merge_request).to be_persisted
      expect(merge_request.project).to eq(project)
      expect(merge_request.author).to eq(user)
      expect(merge_request.title).to eq(expected_title)
      expect(CGI.unescapeHTML(merge_request.description)).to eq(expected_description)
      expect(merge_request.target_branch).to eq(project.default_branch)
      expect(merge_request.source_branch).to start_with(expected_source_branch)
    end
  end

  shared_examples 'an error when in known error states' do
    context 'when merge_requests are disabled on project' do
      let(:project) { create(:project, namespace: group, merge_requests_access_level: ProjectFeature::DISABLED) }

      it 'returns expected error' do
        expect(result[:status]).to eq(:error)
        expect(result[:message]).to eq("User is not permitted to create merge request")
      end
    end

    context 'when creating the commit raises an exception' do
      before do
        allow(project.repository).to receive(:delete_branch).and_call_original
        allow_next_instance_of(Commits::CommitPatchService) do |service|
          allow(service).to receive(:execute).and_raise(StandardError.new('boom!'))
        end
      end

      it 'deletes the generated remediation branch' do
        result
        expect(project.repository).to have_received(:delete_branch).with(/^remediate.*$/).once
      end

      it 'returns a ServiceResponse error' do
        expect(result[:status]).to eq(:error)
        expect(result[:message]).to eq('Unable to apply patch')
      end
    end

    context 'when creating the commit fails' do
      before do
        allow(project.repository).to receive(:delete_branch).and_call_original
        allow_next_instance_of(Commits::CommitPatchService) do |service|
          allow(service).to receive(:execute).and_return(ServiceResponse.error(message: 'boom!'))
        end
      end

      it 'deletes the generated remediation branch' do
        result
        expect(project.repository).to have_received(:delete_branch).with(/^remediate.*$/).once
      end

      it 'returns a ServiceResponse error' do
        expect(result[:status]).to eq(:error)
        expect(result[:message]).to eq('Unable to apply patch')
      end
    end

    context 'when user does not have permission to create merge_request' do
      before do
        allow_any_instance_of(described_class).to receive(:can?).with(user, :create_merge_request_in, project).and_return(false)
        allow_any_instance_of(described_class).to receive(:can?).with(user, :create_merge_request_from, project).and_return(false)
      end

      it 'returns expected error' do
        expect(result[:status]).to eq(:error)
        expect(result[:message]).to eq("User is not permitted to create merge request")
      end
    end

    context 'when creating the MR raises an exception' do
      let(:exception_message) { 'boom!' }

      before do
        allow(project.repository).to receive(:delete_branch).and_call_original
        allow_next_instance_of(MergeRequests::CreateService) do |service|
          allow(service).to receive(:execute).and_raise(StandardError.new(exception_message))
        end
      end

      it 'deletes the generated remediation branch' do
        result
        expect(project.repository).to have_received(:delete_branch).with(/^remediate.*$/).once
      end

      it 'bubbles up the error message in a service response' do
        expect(result[:status]).to eq(:error)
        expect(result[:message]).to eq(exception_message)
      end
    end

    context 'when the generated MR is invalid' do
      before do
        allow_next_instance_of(MergeRequest) do |mr|
          mr.errors.add('boom!')
          allow(mr).to receive(:valid?).and_return(false)
        end
      end

      it 'returns a ServiceResponse error with the exception\'s message' do
        expect(result[:status]).to eq(:error)
        expect(result[:message].first.attribute).to eq(:boom!)
      end
    end
  end

  context 'when implementing a LLM remediation' do
    let(:finding) do
      create(:vulnerabilities_finding, :sast,
        project: project,
        name: 'Long numbers in C code',
        description: 'Long numbers in C code are bad, use shorter number',
        location: {
          'file' => 'src/main.c',
          'start_line' => 6,
          'end_line' => 6
        }
      ).tap { |f| f.metadata[:title] = 'Long numbers in C code' }
    end

    let(:llm_patch) { '<old_code>  memcpy(&buf, "123456789");</old_code><new_code>  memcpy(&buf, "1");</new_code>' }
    let(:params) { { llm_patch: llm_patch, description_options: { analysis_data: analysis_data, summary_data: summary_data } } }

    let(:expected_title) { 'Resolve vulnerability: Long numbers in C code' }
    let(:expected_source_branch) { 'remediate/long-numbers-in-c-code-' }
    let(:expected_description) do
      <<~DESC.chomp
          MR created from vulnerability: [#{vulnerability.title}](#{vulnerability_url(vulnerability)})

          ## AI GENERATED FIX
          The suggested code changes were generated by GitLab Duo Vulnerability Resolution, an AI feature. **Use this feature with caution.** Before you run a pipeline or apply the code changes, carefully review and test them, to ensure that they solve the vulnerability.

          The large language model that generated the suggested code changes was provided with the entire file that contains the vulnerable lines of code. It is not aware of any functionality outside of this context.

          Please see [our documentation](https://docs.gitlab.com/ee/user/application_security/vulnerabilities/#vulnerability-resolution) for more information about this feature.

          ### Description:

          Long numbers in C code are bad, use shorter number

          * Severity: unknown
          * Location: [src/main.c:6](src/main.c:6)

          ### Analysis:
          The vulnerability report lacks specific details about the type of vulnerability, making it challenging to directly correlate with the provided code. However, upon examining the source code, a clear buffer overflow vulnerability is present.
          The vulnerable code section is:

          char buf[8];
          memcpy(&buf, "123456789");

          This code creates a buffer buf of size 8 bytes, but then attempts to copy 9 bytes (the string "123456789") into it using memcpy(). This results in a buffer overflow, which can lead to memory corruption, crashes, or even arbitrary code execution in some cases.
          The vulnerability falls under the category of CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer.
          This is a genuine security concern as buffer overflows can be exploited by attackers to manipulate program behavior or execute malicious code.

          ### Summary:
          1. The reported vulnerability is a buffer overflow in the main() function, where a 9-byte string is copied into an 8-byte buffer.

          2. The fix addresses this issue by:

          - Increasing the buffer size to 10 bytes to accommodate the 9-byte string plus a null terminator.
          - Changing memcpy(&buf, "123456789") to memcpy(buf, "123456789", 9).

          3. These changes ensure that:

          - The buffer is large enough to hold the string.
          - The correct number of bytes (9) is copied.
          - The & operator is removed from buf, as it's unnecessary and incorrect when used with memcpy().

          This fix prevents buffer overflow by ensuring that the destination buffer is large enough to hold the source data. It maintains the original functionality while adhering to secure coding practices.

          Additional recommendations:

          - Consider using strncpy() or snprintf() for string operations, as they provide more safety features.
          - Always check the return value of memory operations for error handling.
          - If the string length is known at compile-time, consider using sizeof() for buffer allocation to prevent manual size miscalculations.

          char buf[sizeof("123456789")];
          strncpy(buf, "123456789", sizeof(buf));
          buf[sizeof(buf) - 1] = '\\0'  // Ensure null-termination

          This approach would further improve the code's safety and maintainability.

          ### Solution:

          GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result.


          ### Links:

          * [Cipher does not check for integrity first?](https://crypto.stackexchange.com/questions/31428/pbewithmd5anddes-cipher-does-not-check-for-integrity-first)
      DESC
    end

    it_behaves_like 'a created merge_request'
    it_behaves_like 'an error when in known error states' do
      context 'when the remediation service returns a failure response' do
        let(:service_response_error) { ServiceResponse.error(message: 'boom!') }

        before do
          allow(::Vulnerabilities::ApplyLlmRemediationService).to receive_message_chain(
            :new, :execute
          ).and_return(service_response_error)
        end

        it 'returns the default error message' do
          expect(result[:message]).to eq('Unable to apply patch')
        end
      end

      context 'when no llm_patch is given' do
        let(:llm_patch) { nil }

        it 'return expected error' do
          expect(result[:status]).to eq(:error)
          expect(result[:message]).to eq("No remediations available for merge request")
        end
      end

      context 'when old code tag is missing' do
        let(:llm_patch) do
          'llm hallucination'
        end

        it 'returns an error' do
          expect(result[:status]).to eq(:error)
          expect(result[:message]).to eq("Response unreadable")
          expect(result[:unreadable_response]).to eq(true)
        end
      end

      context 'with malformed response' do
        let(:llm_patch) do
          '<old_code>  memcpy(&buf, "123456789");</old_code><new_code>  memcpy(&buf, "1");</old_code>'
        end

        it 'returns an error' do
          expect(result[:status]).to eq(:error)
          expect(result[:message]).to eq("Response unreadable")
          expect(result[:unreadable_response]).to eq(true)
        end
      end

      context 'when patch cannot get applied' do
        it 'returns an error' do
          expect(Commits::CommitPatchService).to receive_message_chain(:new, :execute).and_return({ status: :error })
          expect(project.repository).to receive(:delete_branch).with(a_string_matching(/#{expected_source_branch}.*/))

          expect(result[:status]).to eq(:error)
          expect(result[:message]).to eq("Unable to apply patch")
        end
      end
    end

    it 'successfully creates a functional diff and patch from the LLM patch' do
      diff = <<~HEREDOC
            diff --git a/src/main.c b/src/main.c
            --- a/src/main.c
            +++ b/src/main.c
            @@ -4,5 +4,6 @@
             {
               char buf[8];
            -  memcpy(&buf, "123456789");
            +  memcpy(&buf, "1");
               printf("hello, world!");
             }
      HEREDOC

      expect(ApplicationController).to receive(:render).with(
        template: 'vulnerabilities/remediation',
        formats: :patch,
        locals: hash_including(
          diff: "#{diff}+\n"
        )
      ).and_call_original
      expect(ApplicationController).to receive(:render).with(
        template: 'vulnerabilities/merge_request_description',
        formats: :md,
        locals: instance_of(Hash)
      ).and_call_original

      expect(result[:status]).to eq(:success)
    end

    context 'when a vulnerable MR is included in the description options' do
      let_it_be(:vulnerable_mr) { create(:merge_request, :simple) }

      let(:params) { super().tap { |p| p[:description_options][:vulnerable_mr] = vulnerable_mr } }

      it 'points back to the vulnerable MR in the description\'s first line' do
        actual_description = CGI.unescapeHTML(result[:merge_request].description)
        expected_pattern = %r{^Vulnerability finding detected in merge request: http.*?/merge_requests/#{vulnerable_mr.iid}\+s$}

        expect(actual_description.lines.first.strip).to match(expected_pattern)
      end
    end

    context 'with more than one change' do
      let(:llm_patch) do
        '<old_code>  memcpy(&buf, "123456789");</old_code><new_code>  memcpy(&buf, "1");</new_code><old_code>  printf("hello, world!");</old_code><new_code>  printf("hello, world of tests!");</new_code>'
      end

      it 'successfully creates a functional diff and patch from the LLM patch' do
        diff = <<~HEREDOC
              diff --git a/src/main.c b/src/main.c
              --- a/src/main.c
              +++ b/src/main.c
              @@ -4,5 +4,6 @@
               {
                 char buf[8];
              -  memcpy(&buf, "123456789");
              -  printf("hello, world!");
              +  memcpy(&buf, "1");
              +  printf("hello, world of tests!");
               }
        HEREDOC

        expect(ApplicationController).to receive(:render).with(
          template: 'vulnerabilities/remediation',
          formats: :patch,
          locals: hash_including(
            diff: "#{diff}+\n"
          )
        ).and_call_original
        expect(ApplicationController).to receive(:render).with(
          template: 'vulnerabilities/merge_request_description',
          formats: :md,
          locals: instance_of(Hash)
        ).and_call_original

        expect(result[:status]).to eq(:success)
      end
    end

    context 'when extra newlines are returned from the LLM' do
      let(:llm_patch) { "<old_code>\n  memcpy(&buf, \"123456789\");\n\n</old_code><new_code>\n  memcpy(&buf, \"1\");\n</new_code>" }

      it 'successfully creates a functional diff and patch from the LLM patch' do
        diff = <<~HEREDOC
              diff --git a/src/main.c b/src/main.c
              --- a/src/main.c
              +++ b/src/main.c
              @@ -4,5 +4,6 @@
               {
                 char buf[8];
              -  memcpy(&buf, "123456789");
              +  memcpy(&buf, "1");
                 printf("hello, world!");
               }
        HEREDOC

        expect(ApplicationController).to receive(:render).with(
          template: 'vulnerabilities/remediation',
          formats: :patch,
          locals: hash_including(
            diff: "#{diff}+\n"
          )
        ).and_call_original
        expect(ApplicationController).to receive(:render).with(
          template: 'vulnerabilities/merge_request_description',
          formats: :md,
          locals: instance_of(Hash)
        ).and_call_original

        expect(result[:status]).to eq(:success)
      end
    end
  end

  context 'when implementing a human remediation' do
    let(:finding) do
      create(
        :vulnerabilities_finding,
        :dependency_scanning,
        :with_remediation,
        finding_params
      ).tap { |f| f.remediations = [create(:vulnerabilities_remediation, summary: "Upgrade saml2-js", file: patch_file)] }
    end

    let_it_be(:remediations_folder) { Rails.root.join('ee/spec/fixtures/security_reports/remediations') }
    let_it_be(:patch_content) { File.read(File.join(remediations_folder, "remediation.patch")) }
    let_it_be(:diff) { Base64.encode64(patch_content) }
    let(:project_files) do
      {
        'yarn.lock' => File.read(File.join(remediations_folder, 'yarn.lock')),
        'src/main.c' => source_code
      }
    end

    let(:patch_file) { Tempfile.new.tap { |f| f.write(Base64.encode64(patch_content)).then { f.rewind } } }
    let(:finding_params) do
      {
        project: project,
        name: "Authentication bypass via incorrect DOM traversal and canonicalization in saml2-js",
        cve: "yarn.lock:saml2-js:gemnasium:9952e574-7b5b-46fa-a270-aeb694198a98",
        solution: "Upgrade to fixed version.",
        location: { file: 'yarn.lock', dependency: { package: { name: 'saml2-js' }, version: '1.5.0' } },
        uuid: SecureRandom.uuid,
        description: "Some XML DOM traversal and canonicalization APIs may be inconsistent in handling of comments within XML nodes. Incorrect use of these APIs by some SAML libraries results in incorrect parsing of the inner text of XML nodes such that any inner text after the comment is lost prior to cryptographically signing the SAML message. Text after the comment therefore has no impact on the signature on the SAML message.\n\nA remote attacker can modify SAML content for a SAML service provider without invalidating the cryptographic signature, which may allow attackers to bypass primary authentication for the affected SAML service provider."
      }
    end

    it_behaves_like 'an error when in known error states' do
      context 'when remediations are missing' do
        let(:finding) { create(:vulnerabilities_finding, :dependency_scanning, finding_params) }

        it 'return expected error' do
          expect(result[:status]).to eq(:error)
          expect(result[:message]).to eq("No remediations available for merge request")
        end
      end
    end

    context 'when links and idenfitifers are present' do
      before do
        finding.identifiers = [
          create(:vulnerabilities_identifier,
            external_type: "gemnasium",
            name: "Gemnasium-9952e574-7b5b-46fa-a270-aeb694198a98",
            external_id: "9952e574-7b5b-46fa-a270-aeb694198a98",
            url: "https://deps.sec.gitlab.com/packages/npm/saml2-js/versions/1.5.0/advisories"
          ),
          create(:vulnerabilities_identifier,
            external_type: "cve",
            name: "CVE-2017-11429",
            external_id: "CVE-2017-11429",
            url: "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11429"
          )
        ]

        create(:finding_link, finding: finding, url: "https://github.com/Clever/saml2/commit/3546cb61fd541f219abda364c5b919633609ef3d#diff-af730f9f738de1c9ad87596df3f6de84R279", name: nil)
        create(:finding_link, finding: finding, url: "https://github.com/Clever/saml2/issues/127", name: nil)
        create(:finding_link, finding: finding, url: "https://www.kb.cert.org/vuls/id/475445", name: nil)
      end

      context 'when a description is present' do
        let(:expected_title) { 'Resolve vulnerability: Authentication bypass via incorrect DOM traversal and canonicalization in saml2-js' }
        let(:expected_description) do
          <<~DESC.chomp
            ### Description:

            Some XML DOM traversal and canonicalization APIs may be inconsistent in handling of comments within XML nodes. Incorrect use of these APIs by some SAML libraries results in incorrect parsing of the inner text of XML nodes such that any inner text after the comment is lost prior to cryptographically signing the SAML message. Text after the comment therefore has no impact on the signature on the SAML message.\n\nA remote attacker can modify SAML content for a SAML service provider without invalidating the cryptographic signature, which may allow attackers to bypass primary authentication for the affected SAML service provider.

            * Severity: unknown
            * Location: [yarn.lock](yarn.lock)

            ### Solution:

            Upgrade to fixed version.

            ### Identifiers:

            * [Gemnasium-9952e574-7b5b-46fa-a270-aeb694198a98](https://deps.sec.gitlab.com/packages/npm/saml2-js/versions/1.5.0/advisories)
            * [CVE-2017-11429](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11429)

            ### Links:

            * https://github.com/Clever/saml2/commit/3546cb61fd541f219abda364c5b919633609ef3d#diff-af730f9f738de1c9ad87596df3f6de84R279
            * https://github.com/Clever/saml2/issues/127
            * https://www.kb.cert.org/vuls/id/475445
          DESC
        end

        it_behaves_like 'a created merge_request'

        it 'creates a commit without skipping a pipeline' do
          expect(Commits::CommitPatchService).to receive(:new).with(
            project,
            user,
            a_hash_including(patches: [a_string_matching(/Subject: Fix Vulnerability - #{vulnerability.title}\n/)])
          ).and_call_original

          expect(result[:status]).to eq(:success)
        end
      end
    end

    context 'when a description, links and idenfitifers are NOT present' do
      before do
        # This test is a bit finicky as findings source their
        # information from both their table columns or default to
        # pulling it from the raw_metadata which is deprecated.
        metadata = finding.metadata
        metadata.delete('description')
        metadata['links'] = ""
        finding.raw_metadata = metadata.to_json
      end

      let(:finding_params) { super().merge(description: '') }
      let(:expected_title) { 'Resolve vulnerability: Authentication bypass via incorrect DOM traversal and canonicalization in saml2-js' }
      let(:expected_description) do
        <<~DESC.chomp
            ### Description:

            Authentication bypass via incorrect DOM traversal and canonicalization in saml2-js

            * Severity: unknown
            * Location: [yarn.lock](yarn.lock)

            ### Solution:

            Upgrade to fixed version.
        DESC
      end

      it_behaves_like 'a created merge_request'
    end
  end
end
