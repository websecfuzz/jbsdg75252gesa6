# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::Ingestion::Tasks::IngestVulnerabilityStatistics, feature_category: :vulnerability_management do
  describe '#execute' do
    let_it_be(:pipeline) { create(:ci_pipeline) }
    let_it_be_with_refind(:project) { pipeline.project }
    let_it_be(:security_finding_1) { create(:security_finding, severity: :critical) }
    let_it_be(:security_finding_2) { create(:security_finding, severity: :medium) }
    let_it_be(:security_finding_3) { create(:security_finding, severity: :low) }
    let_it_be(:security_finding_4) { create(:security_finding, severity: :info) }
    let_it_be(:finding_map_1) { create(:finding_map, :new_record, security_finding: security_finding_1, pipeline: pipeline) }
    let_it_be(:finding_map_2) { create(:finding_map, :new_record, security_finding: security_finding_2, pipeline: pipeline) }
    let_it_be(:finding_map_3) { create(:finding_map, :with_finding, security_finding: security_finding_3, pipeline: pipeline) }
    let_it_be(:finding_map_4) { create(:finding_map, :new_record, security_finding: security_finding_4, pipeline: pipeline) }

    let_it_be(:other_project) { create(:project, archived: true) }
    let_it_be(:other_pipeline) { create(:ci_pipeline, project: other_project) }
    let_it_be(:other_security_finding_1) { create(:security_finding, severity: :critical) }
    let_it_be(:other_security_finding_2) { create(:security_finding, severity: :medium) }
    let_it_be(:other_security_finding_3) { create(:security_finding, severity: :low) }
    let_it_be(:other_finding_map_1) { create(:finding_map, :new_record, security_finding: other_security_finding_1, pipeline: other_pipeline) }
    let_it_be(:other_finding_map_2) { create(:finding_map, :new_record, security_finding: other_security_finding_2, pipeline: other_pipeline) }
    let_it_be(:other_finding_map_3) { create(:finding_map, :with_finding, security_finding: other_security_finding_3, pipeline: other_pipeline) }

    subject(:ingest_statistics) { described_class.new(pipeline, finding_maps).execute }

    context 'when there is no statistics record for the project' do
      context 'when there are neither new nor transitioned to detected vulnerabilities' do
        let(:finding_maps) { [finding_map_3, other_finding_map_3] }

        it 'does not create a new Vulnerabilities::Statistic record' do
          expect { ingest_statistics }
            .to not_change { project.reload_vulnerability_statistic }.from(nil)
            .and not_change { other_project.reload_vulnerability_statistic }.from(nil)
        end
      end

      context 'when there are new vulnerabilities' do
        let(:finding_maps) do
          [finding_map_1, finding_map_2, finding_map_3, finding_map_4,
            other_finding_map_1, other_finding_map_2, other_finding_map_3]
        end

        it 'creates a new Vulnerabilities::Statistic record' do
          expect { ingest_statistics }
            .to change { project.reload_vulnerability_statistic }.from(nil)
            .and change { other_project.reload_vulnerability_statistic }.from(nil)
        end

        it 'sets the correct attributes for the recently created record' do
          ingest_statistics

          expect(project.vulnerability_statistic).to have_attributes(
            total: 3, critical: 1, high: 0, unknown: 0, medium: 1, low: 0, info: 1, letter_grade: 'f',
            archived: project.archived, traversal_ids: project.namespace.traversal_ids)

          expect(other_project.vulnerability_statistic).to have_attributes(
            total: 2, critical: 1, high: 0, unknown: 0, medium: 1, low: 0, info: 0, letter_grade: 'f',
            archived: other_project.archived, traversal_ids: other_project.namespace.traversal_ids)
        end
      end

      context 'when there are vulnerabilities transitioned to detected' do
        let(:finding_maps) { [finding_map_1] }

        before do
          finding_map_1.transitioned_to_detected = true
        end

        it 'creates a new Vulnerabilities::Statistic record' do
          expect { ingest_statistics }.to change { project.reload_vulnerability_statistic }.from(nil)
        end

        it 'sets the correct attributes for the recently created record' do
          ingest_statistics

          expect(project.vulnerability_statistic).to have_attributes(total: 1, critical: 1, high: 0, unknown: 0, medium: 0, low: 0, info: 0, letter_grade: 'f')
        end
      end
    end

    context 'when there are already a statistics record for the project' do
      let_it_be(:vulnerability_statistic) { create(:vulnerability_statistic, :grade_c, project: project) }
      let_it_be(:other_vulnerability_statistic) { create(:vulnerability_statistic, :grade_c, project: other_project) }

      context 'when there are neither new nor transitioned to detected vulnerabilities' do
        let(:finding_maps) { [finding_map_3, other_finding_map_3] }

        it 'does not create a new record and does not change the existing record' do
          expect { ingest_statistics }.to not_change { vulnerability_statistic.reload.letter_grade }
                                      .and not_change { vulnerability_statistic.reload.low }
                                      .and not_change { vulnerability_statistic.reload.total }
                                      .and not_change { other_vulnerability_statistic.reload.letter_grade }
                                      .and not_change { other_vulnerability_statistic.reload.low }
                                      .and not_change { other_vulnerability_statistic.reload.total }
                                      .and not_change { Vulnerabilities::Statistic.count }
        end
      end

      context 'when there are new vulnerabilities' do
        let(:finding_maps) do
          [finding_map_1, finding_map_2, finding_map_3,
            other_finding_map_1, other_finding_map_2, other_finding_map_3]
        end

        it 'does not create a new record and updates the existing one' do
          expect { ingest_statistics }.to change { vulnerability_statistic.reload.letter_grade }.from('c').to('f')
                                      .and change { vulnerability_statistic.reload.critical }.from(0).to(1)
                                      .and change { vulnerability_statistic.reload.medium }.from(1).to(2)
                                      .and change { vulnerability_statistic.reload.total }.from(1).to(3)
                                      .and change { other_vulnerability_statistic.reload.letter_grade }.from('c').to('f')
                                      .and change { other_vulnerability_statistic.reload.critical }.from(0).to(1)
                                      .and change { other_vulnerability_statistic.reload.medium }.from(1).to(2)
                                      .and change { other_vulnerability_statistic.reload.total }.from(1).to(3)
                                      .and not_change { Vulnerabilities::Statistic.count }
        end
      end

      context 'when there are vulnerabilities transitioned to detected' do
        let(:finding_maps) { [finding_map_1] }

        before do
          finding_map_1.transitioned_to_detected = true
        end

        it 'does not create a new record and updates the existing one' do
          expect { ingest_statistics }.to change { vulnerability_statistic.reload.letter_grade }.from('c').to('f')
                                      .and change { vulnerability_statistic.reload.critical }.from(0).to(1)
                                      .and change { vulnerability_statistic.reload.total }.from(1).to(2)
                                      .and not_change { vulnerability_statistic.reload.medium }.from(1)
                                      .and not_change { Vulnerabilities::Statistic.count }
        end
      end
    end
  end
end
