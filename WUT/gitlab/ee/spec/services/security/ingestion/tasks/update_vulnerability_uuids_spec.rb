# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::Ingestion::Tasks::UpdateVulnerabilityUuids, feature_category: :vulnerability_management do
  let(:user) { create(:user) }

  let_it_be(:pipeline) { create(:ci_pipeline) }

  let_it_be(:location1) { create(:ci_reports_security_locations_sast, start_line: 29, end_line: 29) }
  let_it_be(:location2) { create(:ci_reports_security_locations_sast, start_line: 42, end_line: 42) }
  let_it_be(:semgrep_scanner) { build(:ci_reports_security_scanner, external_id: 'semgrep', name: 'Semgrep') }
  let_it_be(:glas_scanner) do
    build(:ci_reports_security_scanner, external_id: 'gitlab-advanced-sast', name: 'GitLab Advanced SAST')
  end

  let_it_be(:semgrep_id) do
    create(:ci_reports_security_identifier, external_id: 'semgrep', external_type: 'semgrep_id')
  end

  let_it_be(:gosec_id) do
    create(:ci_reports_security_identifier, external_id: 'gosec', external_type: 'type')
  end

  let_it_be(:glas_id) do
    create(:ci_reports_security_identifier, external_id: 'gitlab-advanced-sast_id',
      external_type: 'gitlab-advanced-sast_id')
  end

  let_it_be(:identifiers) { [semgrep_id, gosec_id] }
  let(:report_finding1) do
    create(
      :ci_reports_security_finding,
      identifiers: identifiers,
      uuid: vulnerability_finding_1.uuid,
      location: location1,
      scanner: semgrep_scanner
    )
  end

  let(:report_finding2) do
    create(
      :ci_reports_security_finding,
      identifiers: identifiers,
      uuid: vulnerability_finding_2.uuid,
      location: location2,
      scanner: semgrep_scanner
    )
  end

  let(:finding_map1) { create(:finding_map, report_finding: report_finding1) }
  let(:finding_map2) { create(:finding_map, report_finding: report_finding2) }
  let(:service_object) { described_class.new(pipeline, [finding_map1, finding_map2]) }

  let_it_be(:gosec_vuln_id) do
    create(:vulnerabilities_identifier, external_type: 'type', fingerprint: gosec_id.fingerprint)
  end

  let_it_be(:semgrep_vuln_id) do
    create(:vulnerabilities_identifier, external_type: 'semgrep_id', fingerprint: semgrep_id.fingerprint)
  end

  let_it_be(:glas_vuln_id) do
    create(:vulnerabilities_identifier, external_type: 'gitlab_advanced_sast_id', fingerprint: glas_id.fingerprint)
  end

  subject(:update_vulnerability_uuids) { service_object.execute }

  context 'gosec vulnerabilities exist' do
    let(:vulnerability) { create_vulnerability }
    let(:vulnerability2) { create_vulnerability }
    let(:vulnerability_finding_1) do
      create(
        :vulnerabilities_finding,
        vulnerability: vulnerability,
        project: pipeline.project,
        primary_identifier: gosec_vuln_id,
        identifiers: [gosec_vuln_id],
        location_fingerprint: location1.fingerprint
      )
    end

    let(:vulnerability_finding_2) do
      create(
        :vulnerabilities_finding,
        vulnerability: vulnerability2,
        project: pipeline.project,
        primary_identifier: gosec_vuln_id,
        identifiers: [gosec_vuln_id],
        location_fingerprint: location2.fingerprint
      )
    end

    let!(:feedback1) do
      create(:vulnerability_feedback, finding_uuid: vulnerability_finding_1.uuid, project: pipeline.project)
    end

    let!(:feedback2) do
      create(:vulnerability_feedback, finding_uuid: vulnerability_finding_2.uuid, project: pipeline.project)
    end

    it 'updates UUID of existing vulnerabilities' do
      uuids = [vulnerability_finding_1.uuid, vulnerability_finding_2.uuid]

      expect(Vulnerabilities::Finding.by_uuid(uuids).count).to eq(2)
      expect(Vulnerabilities::Feedback.by_finding_uuid(uuids).count).to eq(2)
      expect(Vulnerabilities::Read.by_uuid(uuids).count).to eq(2)

      update_vulnerability_uuids
      expect(Vulnerabilities::Finding.by_uuid(uuids).count).to eq(0)
      expect(Vulnerabilities::Feedback.by_finding_uuid(uuids).count).to eq(0)
      expect(Vulnerabilities::Read.by_uuid(uuids).count).to eq(0)
    end

    context 'semgrep vulnerabilities already exist' do
      let(:semgrep_vulnerability_finding_1) do
        create(
          :vulnerabilities_finding,
          project: pipeline.project,
          primary_identifier: semgrep_vuln_id,
          identifiers: [semgrep_vuln_id, gosec_vuln_id]
        )
      end

      let(:semgrep_vulnerability_finding_2) do
        create(
          :vulnerabilities_finding,
          project: pipeline.project,
          primary_identifier: semgrep_vuln_id,
          identifiers: [semgrep_vuln_id],
          location_fingerprint: location2.fingerprint
        )
      end

      let(:report_finding1a) do
        create(
          :ci_reports_security_finding,
          identifiers: identifiers,
          uuid: semgrep_vulnerability_finding_1.uuid,
          location: location1,
          scanner: semgrep_scanner
        )
      end

      let(:report_finding2a) do
        create(
          :ci_reports_security_finding,
          identifiers: identifiers,
          uuid: semgrep_vulnerability_finding_2.uuid,
          location: location2,
          scanner: semgrep_scanner
        )
      end

      let(:finding_map1a) { create(:finding_map, report_finding: report_finding1a) }
      let(:finding_map2a) { create(:finding_map, report_finding: report_finding2a) }

      let(:service_objecta) do
        finding_map1a.security_finding.uuid = report_finding1a.uuid
        finding_map2a.security_finding.uuid = report_finding2a.uuid
        described_class.new(pipeline, [finding_map1a, finding_map2a])
      end

      it 'does not raise an exception' do
        gosec_uuids = [vulnerability_finding_1.uuid, vulnerability_finding_2.uuid]
        semgrep_uuids = [semgrep_vulnerability_finding_1.uuid, semgrep_vulnerability_finding_2.uuid]
        uuids = gosec_uuids + semgrep_uuids

        expect(Vulnerabilities::Finding.where(uuid: uuids).count).to eq(4)

        expect(Gitlab::ErrorTracking).not_to receive(:track_exception)

        service_objecta.execute
      end
    end
  end

  context 'semgrep vulnerabilities exist' do
    let(:vulnerability_finding_1) do
      create(
        :vulnerabilities_finding,
        project: pipeline.project,
        primary_identifier: semgrep_vuln_id,
        identifiers: [semgrep_vuln_id, gosec_vuln_id]
      )
    end

    let(:vulnerability_finding_2) do
      create(
        :vulnerabilities_finding,
        project: pipeline.project,
        primary_identifier: semgrep_vuln_id,
        identifiers: [semgrep_vuln_id],
        location_fingerprint: location2.fingerprint
      )
    end

    it 'updates UUID of existing vulnerability' do
      original_uuid1 = vulnerability_finding_1.uuid
      original_uuid2 = vulnerability_finding_2.uuid
      uuids = [original_uuid1, original_uuid2]

      expect(Vulnerabilities::Finding.where(uuid: uuids).count).to eq(2)

      update_vulnerability_uuids
      expect(Vulnerabilities::Finding.where(uuid: uuids).count).to eq(1)
    end
  end

  context 'when updating vulnerability uuids fails' do
    let(:vulnerability_finding_1) do
      create(:vulnerabilities_finding, project: pipeline.project)
    end

    let(:vulnerability_finding_2) do
      create(:vulnerabilities_finding, project: pipeline.project)
    end

    let(:exception) { RuntimeError.new }

    before do
      allow(Gitlab::ErrorTracking).to receive(:track_exception)
      allow(described_class).to receive(:update_uuids?).and_return(true)
      allow_next_instance_of(Security::Ingestion::Tasks::UpdateVulnerabilityUuids) do |update|
        allow(update).to receive(:update_uuids).and_raise(exception)
      end
    end

    it 'tracks the exception' do
      update_vulnerability_uuids

      expect(Gitlab::ErrorTracking).to have_received(:track_exception).with(exception, project_id: pipeline.project_id)
    end
  end

  context 'when updating the uuids' do
    let_it_be(:secret_detection_scanner) do
      build(:ci_reports_security_scanner, external_id: 'gitleaks', name: 'Gitleaks')
    end

    let_it_be(:spotbugs_scanner) do
      build(:ci_reports_security_scanner, external_id: 'spotbugs', name: 'Spotbugs')
    end

    let(:report_finding1) do
      create(
        :ci_reports_security_finding,
        scanner: semgrep_scanner
      )
    end

    let(:report_finding2) do
      create(
        :ci_reports_security_finding,
        scanner: secret_detection_scanner
      )
    end

    let(:report_finding3) do
      create(
        :ci_reports_security_finding,
        scanner: spotbugs_scanner
      )
    end

    let(:finding_map1) { create(:finding_map, report_finding: report_finding1) }
    let(:finding_map2) { create(:finding_map, report_finding: report_finding2) }
    let(:finding_map3) { create(:finding_map, report_finding: report_finding3) }

    let(:service_object1) { described_class.new(pipeline, [finding_map1]) }
    let(:service_object2) { described_class.new(pipeline, [finding_map2]) }
    let(:service_object3) { described_class.new(pipeline, [finding_map3]) }

    it 'allowed for semgrep findings' do
      expect(service_object1).to receive(:update_uuids)
      service_object1.execute
    end

    it 'allowed for secret detection findings' do
      expect(service_object2).to receive(:update_uuids)
      service_object2.execute
    end

    it 'not allowed other findings' do
      expect(service_object3).not_to receive(:update_uuids)
      service_object3.execute
    end
  end

  context 'glas vulnerabilities exist' do
    let(:vulnerability_finding_1) do
      create(
        :vulnerabilities_finding,
        project: pipeline.project,
        primary_identifier: semgrep_vuln_id,
        identifiers: [semgrep_vuln_id]
      )
    end

    let(:report_finding2) do
      create(
        :ci_reports_security_finding,
        identifiers: [glas_id, semgrep_id],
        uuid: vulnerability_finding_2.uuid,
        location: location2,
        scanner: glas_scanner
      )
    end

    let(:vulnerability_finding_2) do
      create(
        :vulnerabilities_finding,
        project: pipeline.project,
        primary_identifier: semgrep_vuln_id,
        identifiers: [semgrep_vuln_id],
        location_fingerprint: location2.fingerprint
      )
    end

    it 'updates UUID of existing vulnerability' do
      expect { update_vulnerability_uuids }
        .to change { vulnerability_finding_2.reload.uuid }.to(finding_map2.uuid)
        .and not_change { vulnerability_finding_1.reload.uuid }
    end
  end

  private

  def create_vulnerability(severity: 7, report_type: 0)
    create(
      :vulnerability,
      project: pipeline.project,
      author: user,
      severity: severity,
      report_type: report_type
    )
  end
end
