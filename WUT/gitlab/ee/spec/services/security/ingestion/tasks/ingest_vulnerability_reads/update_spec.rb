# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::Ingestion::Tasks::IngestVulnerabilityReads::Update, feature_category: :vulnerability_management do
  let_it_be(:user) { create(:user) }
  let_it_be_with_refind(:project) { create(:project) }
  let_it_be_with_refind(:pipeline) { create(:ci_pipeline, project: project) }
  let_it_be(:location) { create(:ci_reports_security_locations_sast, start_line: 29, end_line: 29) }
  let_it_be(:scanner) { build(:ci_reports_security_scanner, external_id: 'scanner', name: 'Scanner') }
  let_it_be_with_refind(:vulnerability) { create_vulnerability }
  let(:vulnerability_read) { vulnerability.vulnerability_read }

  let(:external_type) { 'cve' }
  let(:external_id) { 'CVE-2023-XXXX' }
  let(:identifier_name) { external_id }

  let(:ci_reports_security_identifier) do
    create(:ci_reports_security_identifier, external_id: external_id,
      external_type: external_type, name: identifier_name)
  end

  let(:identifier) do
    create(:vulnerabilities_identifier, external_id: external_id, external_type: external_type,
      name: identifier_name, fingerprint: ci_reports_security_identifier.fingerprint)
  end

  let(:ci_reports_security_finding) do
    create(:ci_reports_security_finding, identifiers: [ci_reports_security_identifier],
      location: location, scanner: scanner)
  end

  let_it_be(:original_scanner) { create(:vulnerabilities_scanner, external_id: 'scanner1', name: 'Scanner1') }
  let_it_be(:new_scanner) { create(:vulnerabilities_scanner, external_id: 'scanner2', name: 'Scanner2') }
  let!(:vulnerability_finding) do
    create(
      :vulnerabilities_finding,
      vulnerability: vulnerability,
      project: pipeline.project,
      primary_identifier: identifier,
      identifiers: [identifier],
      location_fingerprint: location.fingerprint,
      scanner: original_scanner
    )
  end

  let(:security_finding) { create(:security_finding, scanner: original_scanner) }
  let!(:finding_map) do
    create(:finding_map,
      pipeline: pipeline,
      security_finding: security_finding,
      report_finding: ci_reports_security_finding)
  end

  let(:update_service) { described_class.new(pipeline, [finding_map]) }

  before do
    finding_map.vulnerability_id = vulnerability.id

    vulnerability_read.update!(traversal_ids: project.namespace.traversal_ids,
      archived: project.archived, identifier_names: [identifier_name])
  end

  subject(:execute) do
    update_service.execute

    vulnerability_read.reload
  end

  shared_examples 'does not fire an UPDATE query' do
    it 'does not fire an UPDATE query' do
      control = ActiveRecord::QueryRecorder.new { execute }

      expect(control.occurrences_starting_with(/UPDATE/i)).to be_empty
    end
  end

  describe 'scanner' do
    context 'when the scanner changes' do
      before do
        vulnerability_finding.update!(scanner: new_scanner)
        security_finding.update!(scanner: new_scanner)
      end

      it 'updates the scanner to match the vulnerability_finding' do
        expect { execute }.to change { vulnerability_read.reload.scanner }.from(original_scanner).to(new_scanner)
      end
    end

    context 'when the scanner does not change' do
      it_behaves_like 'does not fire an UPDATE query'
    end
  end

  describe 'archived and traversal_ids' do
    describe 'setting `traversal_ids`' do
      context 'when the traversal_ids attribute changes' do
        before do
          vulnerability_read.update!(traversal_ids: [])
        end

        it 'sets it for each vulnerability read to the value of the owning namespace' do
          execute

          expect(vulnerability_read.traversal_ids).to eq(
            project.namespace.traversal_ids
          )
        end
      end

      context 'when the traversal_ids attribute does not change' do
        it_behaves_like 'does not fire an UPDATE query'
      end
    end

    describe 'setting `archived`' do
      context 'when the archived attribute changes' do
        before do
          vulnerability_read.update!(archived: !project.archived)
        end

        it 'sets it for each vulnerability read to the value of the owning project' do
          execute

          expect(vulnerability_read.archived).to eq(project.archived)
        end
      end

      context 'when the archived attribute does not change' do
        it_behaves_like 'does not fire an UPDATE query'
      end
    end
  end

  describe 'owasp_top_10' do
    let(:external_type) { 'owasp' }
    let(:external_id) { 'A1:2017-Injection' }

    shared_examples 'updates vulnerability reads' do |external_id_name|
      it 'updates owasp_top_10 on vulnerability reads' do
        execute

        final_external_id = external_id
        final_external_id += "-#{external_id_name}" if external_id_name

        expect(vulnerability_read.owasp_top_10).to eq(final_external_id)
      end
    end

    shared_examples 'does not update vulnerability reads' do
      it 'does not set owasp_top_10 on vulnerability reads' do
        execute

        expect(vulnerability_read.owasp_top_10).to eq('undefined')
      end

      it_behaves_like 'does not fire an UPDATE query'
    end

    context 'with valid owasp identifier' do
      context 'for 2017 external_id without name' do
        let(:external_id) { 'A1:2017' }

        it_behaves_like 'updates vulnerability reads', 'Injection'
      end

      context 'for 2021 external_id without name' do
        let(:external_id) { 'A3:2021' }

        it_behaves_like 'updates vulnerability reads', 'Injection'
      end

      context 'for 2017 external_id with name' do
        it_behaves_like 'updates vulnerability reads'
      end

      context 'for 2021 external_id with name' do
        let(:external_id) { 'A3:2021-Injection' }

        it_behaves_like 'updates vulnerability reads'
      end

      context 'when primary identifier is not owasp identifier' do
        let(:external_type) { 'cve' }
        let(:external_id) { 'CVE-2023-XXXX' }
        let(:owasp_external_id) { 'A1:2017-Injection' }

        let(:ci_reports_security_owasp_identifier) do
          create(:ci_reports_security_identifier, external_id: owasp_external_id, external_type: 'owasp')
        end

        let(:ci_reports_security_finding) do
          create(:ci_reports_security_finding, identifiers:
            [ci_reports_security_identifier, ci_reports_security_owasp_identifier],
            location: location, scanner: scanner)
        end

        let(:owasp_identifier) do
          create(:vulnerabilities_identifier, external_id: owasp_external_id, external_type: 'owasp',
            fingerprint: ci_reports_security_owasp_identifier.fingerprint)
        end

        let!(:vulnerability_finding) do
          create(:vulnerabilities_finding, vulnerability: vulnerability, project: pipeline.project,
            primary_identifier: identifier,
            identifiers: [identifier, owasp_identifier],
            location_fingerprint: location.fingerprint)
        end

        it 'updates owasp_top_10 on vulnerability reads' do
          execute

          expect(vulnerability_read.owasp_top_10).to eq(owasp_external_id)
        end
      end
    end

    context 'with invalid owasp identifier' do
      context 'for invalid priority label' do
        let(:external_id) { 'A1' }

        it_behaves_like 'does not update vulnerability reads'
      end

      context 'for invalid year' do
        let(:external_id) { 'A1:2010' }

        it_behaves_like 'does not update vulnerability reads'
      end

      context 'for invalid external_id with correct label year and incorrect name' do
        let(:external_id) { 'A1:2021-Injection' }

        it_behaves_like 'does not update vulnerability reads'
      end
    end

    context 'with non owasp identifier' do
      let(:external_type) { 'cve' }
      let(:external_id) { 'CVE-2023-XXXX' }

      it_behaves_like 'does not update vulnerability reads'

      context 'when the vulnerability_read record already has `owasp_top_10` assigned' do
        before do
          vulnerability_read.update!(owasp_top_10: 'A1:2017-Injection')
        end

        it 'resets the `owasp_top_10` attribute' do
          expect { execute }.to change { vulnerability_read.reload.owasp_top_10 }.to('undefined')
        end
      end
    end
  end

  describe 'has_vulnerability_resolution' do
    context 'when the report type is not supported' do
      let(:external_type) { 'cwe' }
      let(:external_id) { '23' }
      let(:ci_reports_security_finding) do
        create(
          :ci_reports_security_finding,
          report_type: :dast,
          identifiers: [ci_reports_security_identifier],
          location: location,
          scanner: scanner)
      end

      it_behaves_like 'does not fire an UPDATE query'

      it 'sets has_vulnerability_resolution to false' do
        execute

        expect(vulnerability_read.has_vulnerability_resolution).to be false
      end
    end

    context 'when the CWE is not supported' do
      let(:external_type) { 'cwe' }
      let(:external_id) { 'unsupported' }

      it_behaves_like 'does not fire an UPDATE query'

      it 'sets has_vulnerability_resolution to false' do
        execute

        expect(vulnerability_read.has_vulnerability_resolution).to be false
      end
    end

    context 'when the report is sast and a supported CWE' do
      let(:external_type) { 'cwe' }
      let(:external_id) { '23' }
      let(:identifier_name) { 'CWE-23' }

      it 'sets has_vulnerability_resolution to true' do
        execute

        expect(vulnerability_read.has_vulnerability_resolution).to be true
      end
    end
  end

  describe 'identifier_names' do
    let(:external_type) { 'cwe' }
    let(:external_id) { '1035' }
    let(:identifier_name) { 'CWE-1035' }

    context 'when the vulnerabilility_read record attribute is not set' do
      before do
        vulnerability_read.update!(identifier_names: [])
      end

      it 'sets the attribute' do
        expect { execute }
          .to change { vulnerability_read.reload.identifier_names }
          .to([identifier_name])
      end
    end

    context 'when the vulnerabilility_read record attribute already exists' do
      let(:external_id_b) { '937' }
      let(:external_type_b) { 'cwe' }
      let(:identifier_name_b) { 'CWE-937' }

      let(:ci_reports_security_identifier_b) do
        create(:ci_reports_security_identifier, external_id: external_id_b,
          external_type: external_type_b, name: identifier_name_b)
      end

      let(:ci_reports_security_finding) do
        create(:ci_reports_security_finding,
          identifiers: [ci_reports_security_identifier_b],
          location: location, scanner: scanner)
      end

      it 'changes the attribute with recent identifier ids' do
        expect { execute }
          .to change { vulnerability_read.reload.identifier_names }
          .from([identifier_name])
          .to([identifier_name_b])
      end

      context 'when there are multiple identifiers with ordering difference on the report' do
        let(:ci_reports_security_finding) do
          create(:ci_reports_security_finding,
            identifiers: [ci_reports_security_identifier_b, ci_reports_security_identifier],
            location: location, scanner: scanner)
        end

        before do
          vulnerability_read.update!(identifier_names: [identifier_name, identifier_name_b])
        end

        it 'does not change the attribute' do
          expect { execute }
            .not_to change { vulnerability_read.reload.identifier_names }
        end
      end
    end

    context 'when there is no change in the attribute' do
      it_behaves_like 'does not fire an UPDATE query'
    end
  end

  private

  def create_vulnerability(severity: 7, report_type: 0)
    create(:vulnerability,
      project: pipeline.project,
      author: user,
      severity: severity,
      report_type: report_type)
  end
end
