# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::Ingestion::CreateVulnerabilityRepresentationInformation, feature_category: :vulnerability_management do
  let_it_be(:project) { create(:project) }
  let_it_be(:pipeline) { create(:ee_ci_pipeline, project: project) }
  let_it_be(:scanner) do
    create(:vulnerabilities_scanner, project: project, name: 'SAST scanner', external_id: 'semgrep')
  end

  let_it_be(:vulnerability_1) do
    create(:vulnerability, :sast,
      project: project,
      present_on_default_branch: true,
      resolved_on_default_branch: false,
      findings: [create(:vulnerabilities_finding, project: project, scanner: scanner)]
    )
  end

  let_it_be(:vulnerability_2) do
    create(:vulnerability, :sast,
      project: project,
      present_on_default_branch: true,
      resolved_on_default_branch: false,
      findings: [create(:vulnerabilities_finding, project: project, scanner: scanner)]
    )
  end

  let(:resolved_vulnerability_ids) { [vulnerability_1.id, vulnerability_2.id] }
  let(:service) { described_class.new(pipeline, resolved_vulnerability_ids) }

  describe '#execute' do
    subject(:execute_service) { service.execute }

    it 'creates Vulnerabilities::RepresentationInformation for the resolved vulnerabilities' do
      expect { execute_service }.to change { Vulnerabilities::RepresentationInformation.count }.by(2)

      resolved_vulnerability_ids.each do |id|
        record = Vulnerabilities::RepresentationInformation.find_by(vulnerability_id: id)
        expect(record).to have_attributes(
          vulnerability_id: id,
          project_id: project.id,
          resolved_in_commit_sha: pipeline.sha
        )
      end
    end

    context 'when there are no resolved vulnerabilities' do
      let(:resolved_vulnerability_ids) { [] }

      it 'does not create any records' do
        expect { service.execute }.not_to change { Vulnerabilities::RepresentationInformation.count }
      end
    end
  end
end
