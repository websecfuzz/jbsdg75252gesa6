# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::VulnerabilityScanning::CreateVulnerabilityService, feature_category: :software_composition_analysis do
  let_it_be(:user) { create(:user) }
  let_it_be_with_refind(:project) { create(:project) }
  let_it_be_with_refind(:pipeline) { create(:ci_pipeline, user: user, project: project) }
  let_it_be_with_refind(:latest_pipeline) { create(:ci_pipeline, user: user, project: project) }

  let(:purl_type) { Enums::Sbom::DEPENDENCY_SCANNING_PURL_TYPES.first }
  let(:report_type) { 'dependency_scanning' }
  let(:locations) { create(:ci_reports_security_locations_dependency_scanning) }

  let(:security_finding) do
    create(:ci_reports_security_finding, location: locations, report_type: report_type)
  end

  let(:security_finding_2) do
    create(:ci_reports_security_finding, location: locations, report_type: report_type)
  end

  let(:finding_map) do
    create(:vs_finding_map, pipeline: pipeline, report_finding: security_finding, purl_type: purl_type)
  end

  let(:finding_map_2) do
    create(:vs_finding_map, pipeline: latest_pipeline, report_finding: security_finding_2, purl_type: purl_type)
  end

  let(:finding_maps) { [finding_map, finding_map_2] }

  subject(:service_response) do
    described_class.execute(finding_maps)
  end

  before do
    allow(Gitlab::ErrorTracking).to receive(:track_exception).and_call_original
  end

  describe '#execute' do
    context 'when the component type is supported' do
      shared_examples 'vulnerability creation' do
        let(:created_vulnerability) { Vulnerability.find(service_response.payload[:vulnerability_ids].first) }

        it 'creates a new vulnerabilities' do
          expect(service_response.payload[:error]).to be_nil
          expect(service_response.success?).to be(true)
          expect(service_response.payload[:vulnerability_ids].length).to be(2)

          expect(created_vulnerability).to have_attributes(
            author_id: user.id,
            project_id: pipeline.project_id,
            state: 'detected',
            report_type: report_type,
            present_on_default_branch: true,
            title: 'Cipher with no integrity',
            severity: 'high',
            finding_description: 'The cipher does not provide data integrity update 1',
            solution: 'GCM mode introduces an HMAC into the resulting encrypted data, ' \
              'providing integrity of the result.'
          )
        end

        describe 'updating the `vulnerability_reads`' do
          let(:vulnerability_read) { created_vulnerability.vulnerability_read }

          it 'sets the `traversal_ids` for the `vulnerability_reads` records' do
            expect(vulnerability_read.traversal_ids).to eq(project.namespace.traversal_ids)
          end

          context 'when the project is unarchived' do
            it 'marks the associated `vulnerability_reads` record as unarchived' do
              expect(vulnerability_read.archived).to be_falsey
            end
          end

          context 'when the project is archived' do
            before do
              project.update!(archived: true)
            end

            it 'marks the associated `vulnerability_reads` record as archived' do
              expect(vulnerability_read.archived).to be_truthy
            end
          end
        end
      end

      it_behaves_like 'vulnerability creation'

      it 'publishes a new event with sbom and vulnerability information' do
        expect { service_response }.to publish_event(Sbom::VulnerabilitiesCreatedEvent).with({
          "findings" => match_array([
            {
              "uuid" => security_finding.uuid,
              "vulnerability_id" => kind_of(Integer),
              "project_id" => project.id,
              "package_name" => locations.package_name,
              "package_version" => locations.package_version,
              "purl_type" => purl_type
            },
            {
              "uuid" => security_finding_2.uuid,
              "vulnerability_id" => kind_of(Integer),
              "project_id" => project.id,
              "package_name" => locations.package_name,
              "package_version" => locations.package_version,
              "purl_type" => purl_type
            }
          ])
        })
      end

      context 'with a number of findings higher than `FINDINGS_LIMIT`' do
        let(:security_finding_second) do
          create(:ci_reports_security_finding, location: locations, report_type: report_type)
        end

        let(:finding_map_second) do
          create(:vs_finding_map, pipeline: pipeline, report_finding: security_finding_second, purl_type: purl_type)
        end

        let(:finding_maps) { [finding_map, finding_map_second] }

        before do
          stub_const("#{described_class}::FINDINGS_LIMIT", 1)
        end

        it 'publishes a new event with findings based on `FINDINGS_LIMIT`' do
          expect_next_instance_of(described_class) do |service|
            expect(service).to receive(:vulnerabilities_created_event)
              .with([hash_including(uuid: security_finding.uuid)]).and_call_original
            expect(service).to receive(:vulnerabilities_created_event)
              .with([hash_including(uuid: security_finding_second.uuid)]).and_call_original
          end

          service_response
        end
      end

      context 'when report type and source is container scanning' do
        let(:report_type) { 'container_scanning' }
        let(:locations) { create(:ci_reports_security_locations_container_scanning) }

        it_behaves_like 'vulnerability creation'

        it 'does not publish a new event with sbom and vulnerability information' do
          expect { service_response }.not_to publish_event(Sbom::VulnerabilitiesCreatedEvent)
        end
      end

      context 'when report type and source is container scanning for registry' do
        let(:report_type) { 'container_scanning_for_registry' }
        let(:locations) { create(:ci_reports_security_locations_container_scanning) }

        it_behaves_like 'vulnerability creation'

        it 'does not publish a new event with sbom and vulnerability information' do
          expect { service_response }.not_to publish_event(Sbom::VulnerabilitiesCreatedEvent)
        end
      end

      context 'when the vulnerability can not be created because of a lack of quota' do
        let(:mock_vulnerability_quota) { instance_double(Vulnerabilities::Quota, validate!: true) }
        let(:other_mock_vulnerability_quota) { instance_double(Vulnerabilities::Quota, validate!: false) }
        let(:other_project) { create(:project) }
        let(:other_pipeline) { create(:ci_pipeline, user: user, project: other_project) }
        let(:other_security_finding) { create(:ci_reports_security_finding, report_type: report_type) }
        let(:other_finding_map) do
          create(:vs_finding_map, pipeline: other_pipeline, report_finding: other_security_finding)
        end

        let(:finding_maps) { [finding_map, other_finding_map] }

        before do
          allow(project).to receive(:vulnerability_quota).and_return(mock_vulnerability_quota)
          allow(other_project).to receive(:vulnerability_quota).and_return(other_mock_vulnerability_quota)
        end

        it 'creates vulnerabilities only for the projects with quota' do
          expect { service_response }.to change { Vulnerability.count }.by(1)
        end
      end

      it_behaves_like 'rescheduling archival status and traversal_ids update jobs' do
        let(:scheduling_method) { :bulk_perform_async_with_contexts }
        let(:job_args) do
          [
            [latest_pipeline.project, pipeline.project],
            {
              arguments_proc: an_instance_of(Proc),
              context_proc: an_instance_of(Proc)
            }
          ]
        end

        let(:ingest_vulnerabilities) { service_response }
        let(:update_archived_after_start) do
          allow(Security::Ingestion::IngestCvsSliceService).to receive(:execute).and_wrap_original do |method, *args|
            latest_pipeline.project.clone.reload.update_column(:archived, true)

            method.call(*args)
          end
        end

        let(:update_traversal_ids_after_start) do
          allow(Security::Ingestion::IngestCvsSliceService).to receive(:execute).and_wrap_original do |method, *args|
            latest_pipeline.project.namespace.clone.reload.update_column(:traversal_ids, [-1])

            method.call(*args)
          end
        end

        let(:update_namespace_after_start) do
          allow(Security::Ingestion::IngestCvsSliceService).to receive(:execute).and_wrap_original do |method, *args|
            latest_pipeline.project.clone.reload.update_column(:namespace_id, new_namespace.id)

            method.call(*args)
          end
        end
      end

      it_behaves_like 'schedules synchronization of vulnerability statistic' do
        let(:ingest_reports) { service_response }
      end

      it_behaves_like 'schedules synchronization of findings to approval rules' do
        let(:ingest_reports) { service_response }
      end
    end

    context 'when the findings are not uniq by uuid' do
      let(:finding_maps) { [finding_map, finding_map] }

      it 'does not return an error' do
        expect(service_response.payload[:error]).to be_nil
        expect(service_response.success?).to be(true)
      end
    end

    context 'when no finding maps could be created' do
      let(:finding_maps) { [] }

      it 'returns a success status with warning' do
        expect(service_response.payload[:error]).to be_nil
        expect(service_response.success?).to be(true)
        expect(service_response.message).to be('All finding maps filtered out and no vulnerabilities created')
        expect(service_response.payload[:vulnerability_ids]).to eq([])
        expect(service_response.payload[:project_ids_with_upsert]).to eq([])
      end
    end

    context 'when an error is thrown' do
      context 'and it is not recoverable' do
        it 'captures the error and halts execution' do
          allow_next_instance_of(::Security::Ingestion::IngestCvsSliceService) do |instance|
            allow(instance).to receive(:execute).and_raise(StandardError)
          end

          expect(Gitlab::ErrorTracking).to receive(:track_exception)
            .with(an_instance_of(StandardError),
              message: "Continuous vulnerability scanning failed to create vulnerabilities",
              project_ids_with_upsert: [])

          expect(service_response.success?).to be(false)
          expect(service_response.message).to eq('Vulnerabilities were not created')
          expect(service_response.payload[:vulnerability_ids]).to be_nil
          expect(service_response.payload[:error]).not_to be_nil
          expect(service_response.payload[:error]).to be_a_kind_of(StandardError)
          expect(service_response.payload[:error]).to be_kind_of(StandardError)
        end
      end
    end
  end
end
