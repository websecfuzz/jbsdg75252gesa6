# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::VulnerabilityScanning::BuildFindingMapService, feature_category: :software_composition_analysis do
  let_it_be(:user) { create(:user) }
  let_it_be_with_refind(:project) { create(:project) }
  let_it_be_with_refind(:pipeline) { create(:ci_pipeline, user: user, project: project) }

  let(:scanner) { ::Gitlab::VulnerabilityScanning::SecurityScanner.fabricate }
  let(:sbom_source) { build(:ci_reports_sbom_source) }
  let(:affected_component) do
    build(:vs_possibly_affected_component, purl_type: 'npm', pipeline: pipeline, project: pipeline.project,
      source: sbom_source)
  end

  let(:advisory) { build(:vs_advisory) }

  subject(:service_response) do
    described_class.execute(
      advisory: advisory,
      affected_component: affected_component,
      source: affected_component.source,
      pipeline: pipeline,
      project: pipeline.project,
      purl_type: affected_component.purl_type,
      scanner: scanner)
  end

  before do
    allow(Gitlab::ErrorTracking).to receive(:track_exception).and_call_original
  end

  describe '#execute' do
    context 'when the component type is supported' do
      shared_examples 'building finding map' do
        it 'builds a finding map' do
          expect(service_response.to_hash).to match(a_hash_including(
            project_id: pipeline.project.id,
            report_type: report_type,
            severity: advisory.cvss_v3.severity.downcase,
            description: advisory.description,
            solution: advisory.solution)
                                                   )
        end
      end

      context 'when report type and source is dependency scanning' do
        let(:report_type) { 'dependency_scanning' }

        it_behaves_like 'building finding map'
      end

      context 'when report type and source is container scanning' do
        let(:affected_component) do
          build(:vs_possibly_affected_component, :container_scanning, pipeline: pipeline, project: pipeline.project)
        end

        let(:report_type) { 'container_scanning' }

        it_behaves_like 'building finding map'
      end

      context 'when report type and source is container scanning for registry' do
        let(:affected_component) do
          build(:vs_possibly_affected_component,
            :container_scanning_for_registry, pipeline: pipeline, project: pipeline.project)
        end

        let(:report_type) { 'container_scanning_for_registry' }

        it_behaves_like 'building finding map'
      end
    end

    context 'when the component type is not supported' do
      let(:affected_component) do
        build(:vs_possibly_affected_component, purl_type: 'foo', pipeline: pipeline, project: pipeline.project)
      end

      it 'fails to build finding map' do
        expect(Gitlab::ErrorTracking).to receive(:track_exception)
                .with(an_instance_of(StandardError),
                  message: "Continuous vulnerability scanning failed to build finding",
                  project_id: pipeline.project.id,
                  advisory_xid: advisory.xid,
                  source_xid: advisory.source_xid)

        expect(service_response).to be_nil
      end
    end

    context 'when an error is thrown' do
      context 'and it is not recoverable' do
        it 'captures the error and halts execution' do
          allow_next_instance_of(::Gitlab::VulnerabilityScanning::FindingBuilder) do |instance|
            allow(instance).to receive(:finding).and_raise(StandardError)
          end

          expect(Gitlab::ErrorTracking).to receive(:track_exception)
            .with(an_instance_of(StandardError),
              message: "Continuous vulnerability scanning failed to build finding",
              project_id: pipeline.project.id,
              advisory_xid: advisory.xid,
              source_xid: advisory.source_xid)

          expect(service_response).to be_nil
        end
      end

      context 'and it is a recoverable finding builder error' do
        let(:affected_component) do
          build(:vs_possibly_affected_component, purl_type: 'npm', pipeline: pipeline, project: pipeline.project,
            source: nil)
        end

        it 'captures and tracks the error' do
          expect(Gitlab::ErrorTracking).to receive(:track_exception)
                  .with(an_instance_of(::Gitlab::VulnerabilityScanning::FindingBuilder::ArgumentError),
                    message: 'Skipping building finding for an affected component',
                    project_id: pipeline.project.id,
                    advisory_xid: advisory.xid,
                    source_xid: advisory.source_xid)

          expect(service_response).to be_nil
        end
      end
    end
  end
end
