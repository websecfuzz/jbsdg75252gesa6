# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Sbom::Ingestion::VulnerabilityData, feature_category: :dependency_management do
  subject(:instance) { described_class.new(occurrence_maps, project) }

  let_it_be(:vulnerability) { create(:vulnerability) }
  let_it_be(:project) { vulnerability.project }
  let_it_be(:pipeline) { create(:ci_pipeline, project: project) }
  let_it_be(:dependency_scanning_finding) do
    create(
      :vulnerabilities_finding,
      :with_dependency_scanning_metadata,
      vulnerability: vulnerability,
      pipeline: pipeline
    )
  end

  let_it_be(:container_scanning_finding) do
    create(
      :vulnerabilities_finding,
      :with_container_scanning_metadata,
      vulnerability: vulnerability,
      pipeline: pipeline,
      image: 'docker.io/library/alpine:3.12',
      operating_system: 'Alpine',
      version: '3.12'
    )
  end

  let_it_be(:dependency_occurrence_map) { occurrence_map(dependency_scanning_finding, container_source: false) }
  let_it_be(:container_occurrence_map) { occurrence_map(container_scanning_finding, container_source: true) }
  let_it_be(:no_finding_occurrence_map) { create(:sbom_occurrence_map, :for_occurrence_ingestion) }

  let(:occurrence_maps) { [dependency_occurrence_map, container_occurrence_map, no_finding_occurrence_map] }

  it 'only triggers a single database query for a given instance' do
    inital_db_query_count = ActiveRecord::QueryRecorder.new do
      instance.for(dependency_occurrence_map).count
    end.count

    subsequent_db_query_count = ActiveRecord::QueryRecorder.new do
      occurrence_maps.each { |om| instance.for(om).count }
    end.count

    expect(inital_db_query_count).to eq(1)
    expect(subsequent_db_query_count).to eq(0)
  end

  describe '#for' do
    subject(:vulnerability_info) { described_class.new(occurrence_maps, project).for(occurrence_map) }

    shared_examples 'when NO vulnerability data is expected' do
      it 'returns default values' do
        expect(vulnerability_info.count).to eq(0)
        expect(vulnerability_info.highest_severity).to be_nil
        expect(vulnerability_info.vulnerability_ids).to eq([])
      end
    end

    shared_examples 'when vulnerability data is expected' do
      let(:expected_severity) { Enums::Vulnerability.severity_levels[finding.severity] }

      it 'returns the vulnerability information' do
        expect(vulnerability_info.count).to eq(1)
        expect(vulnerability_info.highest_severity).to eq(expected_severity)
        expect(vulnerability_info.vulnerability_ids).to eq([finding.vulnerability_id])
      end
    end

    context 'when vulnerability information exists for the occurrence map' do
      context 'with a dependency scanning finding' do
        it_behaves_like 'when vulnerability data is expected' do
          let(:occurrence_map) { dependency_occurrence_map }
          let(:finding) { dependency_scanning_finding }
        end
      end

      context 'with a container scanning finding' do
        it_behaves_like 'when vulnerability data is expected' do
          let(:occurrence_map) { container_occurrence_map }
          let(:finding) { container_scanning_finding }
        end
      end
    end

    context 'when no vulnerability information exists for the occurrence map' do
      it_behaves_like 'when NO vulnerability data is expected' do
        let(:occurrence_map) { no_finding_occurrence_map }
      end
    end

    context 'when invalid input is provided' do
      context 'when nil is provided' do
        it_behaves_like 'when NO vulnerability data is expected' do
          let(:occurrence_map) { nil }
        end
      end

      context 'when no occurrence map is provided' do
        subject(:vulnerability_info) { described_class.new(occurrence_maps, project).for }

        it { expect { vulnerability_info }.to raise_error(ArgumentError) }
      end

      context 'when an occurrence map not included in initializer collection is provided' do
        it_behaves_like 'when NO vulnerability data is expected' do
          let(:occurrence_maps) { [dependency_occurrence_map] }
          let(:occurrence_map) { container_occurrence_map }
        end
      end
    end
  end

  def occurrence_map(finding, container_source: false)
    dependency = finding.location['dependency']
    package_name = dependency['package']['name']
    version = dependency['version']
    path = finding.file

    if container_source
      component, source = container_component_source(package_name, version)
    else
      component, source = dependency_component_source(package_name, version, path)
    end

    create(
      :sbom_occurrence_map,
      :for_occurrence_ingestion,
      report_component: component,
      report_source: source,
      vulnerabilities: nil
    )
  end

  def container_component_source(package_name, version)
    [
      create(
        :ci_reports_sbom_component,
        :with_trivy_properties,
        name: package_name,
        version: version),
      create(
        :ci_reports_sbom_source, :container_scanning,
        image_name: 'docker.io/library/alpine',
        image_tag: '3.12',
        operating_system_name: 'Alpine',
        operating_system_version: '3.12')
    ]
  end

  def dependency_component_source(package_name, version, path)
    [
      create(:ci_reports_sbom_component, name: package_name, version: version),
      create(:ci_reports_sbom_source, :dependency_scanning, input_file_path: path)
    ]
  end
end
