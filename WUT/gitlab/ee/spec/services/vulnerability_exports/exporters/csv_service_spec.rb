# frozen_string_literal: true

require 'spec_helper'

RSpec.describe VulnerabilityExports::Exporters::CsvService, feature_category: :vulnerability_management do
  include VulnerabilityExportsHelpers

  let_it_be(:group) { create(:group) }
  let_it_be(:project) { project_with_valid_findings(group: group) }
  let_it_be(:user) { create(:user, maintainer_of: project) }
  let(:vulnerabilities) { ::Vulnerabilities::Read.all }
  let(:export_csv_service) { described_class.new(vulnerabilities) }

  subject(:csv) { CSV.parse(export_csv_service.generate, headers: true) }

  describe '#header' do
    subject { export_csv_service.header }

    let(:csv_headers) { "Group Name,Project Name,Tool,Scanner Name,Status,Vulnerability,Details,Additional Info,Severity,CVE,CWE,Other Identifiers,Detected At,Location,Activity,Comments,Full Path,CVSS Vectors,Dismissal Reason,Vulnerability ID\n" }

    it { is_expected.to eq(csv_headers) }
  end

  context 'when block is not given' do
    it 'renders csv to string' do
      expect(export_csv_service.generate).to be_a String
    end
  end

  context 'when block is given' do
    it 'returns handle to Tempfile' do
      expect(export_csv_service.generate { |file| file }).to be_a Tempfile
    end
  end

  it 'includes the columns required for import' do
    expect(csv.headers).to contain_exactly(*csv_headers)
  end

  describe 'CSV content' do
    # the CSV service works with Vulnerabilities::Read as input
    let(:vulnerabilities) { [vulnerability.vulnerability_read] }

    context 'with valid findings' do
      before do
        vulnerability.finding.identifiers << create(:vulnerabilities_identifier, external_type: 'GSO', name: 'GSO-1234;1234')
        vulnerability.finding.identifiers << create(:vulnerabilities_identifier, external_type: 'TSO', name: 'TSO-1234')
      end

      context 'when a project belongs to a group' do
        let_it_be_with_refind(:vulnerability) { create(:vulnerability, :with_findings, project: project) }
        let_it_be(:note) { create(:note, project: project, noteable: vulnerability, note: "a\nb") }

        it 'includes proper values for each column type', :aggregate_failures do
          expect(csv[0]['Group Name']).to eq group.name
          expect(csv[0]['Project Name']).to eq project.name
          expect(csv[0]['Tool']).to eq vulnerability.report_type
          expect(csv[0]['Scanner Name']).to eq vulnerability.finding_scanner_name
          expect(csv[0]['Status']).to eq vulnerability.state
          expect(csv[0]['Vulnerability']).to eq vulnerability.title
          expect(csv[0]['Details']).to eq vulnerability.finding_description
          expect(csv[0]['Additional Info']).to be_nil
          expect(csv[0]['Severity']).to eq vulnerability.severity
          expect(csv[0]['CVE']).to eq vulnerability.cve_value
          expect(csv[0]['CWE']).to eq vulnerability.cwe_value
          expect(csv[0]['Other Identifiers']).to eq other_identifiers
          expect(csv[0]['Detected At']).to eq vulnerability.created_at.to_s
          expect(csv[0]['Location']).to eq vulnerability.location.to_s
          expect(csv[0]['Activity']).to eq vulnerability.resolved_on_default_branch.to_s
          expect(csv[0]['Comments']).to include('a\nb')
          expect(csv[0]['Full Path']).to eq vulnerability.full_path
          expect(csv[0]['CVSS Vectors']).to eq "GitLab=CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N"
          expect(csv[0]['Dismissal Reason']).to be_nil
          expect(csv[0]['Vulnerability ID']).to eq vulnerability.id.to_s
        end
      end

      context 'when a project belongs to a user' do
        let_it_be(:project) { project_with_valid_findings(namespace: user.namespace) }
        let_it_be(:vulnerability) { create(:vulnerability, :with_findings, project: project) }
        let_it_be(:note) { create(:note, project: project, noteable: vulnerability, note: "a\nb") }

        it 'includes proper values for each column except group name' do
          expect(csv[0]['Group Name']).to be_nil
          expect(csv[0]['Project Name']).to eq project.name
          expect(csv[0]['Tool']).to eq vulnerability.report_type
          expect(csv[0]['Scanner Name']).to eq vulnerability.finding_scanner_name
          expect(csv[0]['Status']).to eq vulnerability.state
          expect(csv[0]['Vulnerability']).to eq vulnerability.title
          expect(csv[0]['Details']).to eq vulnerability.finding_description
          expect(csv[0]['Additional Info']).to be_nil
          expect(csv[0]['Severity']).to eq vulnerability.severity
          expect(csv[0]['CVE']).to eq vulnerability.cve_value
          expect(csv[0]['CWE']).to eq vulnerability.cwe_value
          expect(csv[0]['Other Identifiers']).to eq other_identifiers
          expect(csv[0]['Detected At']).to eq vulnerability.created_at.to_s
          expect(csv[0]['Location']).to eq vulnerability.location.to_s
          expect(csv[0]['Activity']).to eq vulnerability.resolved_on_default_branch.to_s
          expect(csv[0]['Comments']).to include('a\nb')
          expect(csv[0]['Full Path']).to eq vulnerability.full_path
          expect(csv[0]['CVSS Vectors']).to eq "GitLab=CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N"
          expect(csv[0]['Dismissal Reason']).to be_nil
          expect(csv[0]['Vulnerability ID']).to eq vulnerability.id.to_s
        end
      end
    end

    context 'when a vulnerability is missing a finding' do
      let_it_be(:vulnerability) { create(:vulnerability, :with_read, project: project) }

      it 'includes proper values for each column except Other Identifiers' do
        expect(csv[0]['Group Name']).to eq group.name
        expect(csv[0]['Project Name']).to eq project.name
        expect(csv[0]['Tool']).to eq vulnerability.report_type
        expect(csv[0]['Scanner Name']).to eq vulnerability.finding_scanner_name
        expect(csv[0]['Status']).to eq vulnerability.state
        expect(csv[0]['Vulnerability']).to eq vulnerability.title
        expect(csv[0]['Details']).to eq vulnerability.finding_description
        expect(csv[0]['Additional Info']).to be_nil
        expect(csv[0]['Severity']).to eq vulnerability.severity
        expect(csv[0]['CVE']).to eq vulnerability.cve_value
        expect(csv[0]['CWE']).to eq vulnerability.cwe_value
        expect(csv[0]['Other Identifiers']).to be_nil
        expect(csv[0]['Detected At']).to eq vulnerability.created_at.to_s
        expect(csv[0]['Location']).to be_nil
        expect(csv[0]['Activity']).to eq vulnerability.resolved_on_default_branch.to_s
        expect(csv[0]['Comments']).to be_empty
        expect(csv[0]['Full Path']).to eq vulnerability.full_path
        expect(csv[0]['CVSS Vectors']).to eq "GitLab=CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N"
        expect(csv[0]['Dismissal Reason']).to be_nil
        expect(csv[0]['Vulnerability ID']).to eq vulnerability.id.to_s
      end
    end
  end

  context 'when a vulnerability is dismissed with a dismissal reason' do
    let_it_be(:vulnerability) do
      create(:vulnerability, :with_read, :dismissed, project: project) do |vulnerability|
        vulnerability.vulnerability_read.dismissal_reason = 3
      end
    end

    let_it_be(:vulnerabilities) { [vulnerability.vulnerability_read] }

    it 'populates the dismissal reason column' do
      expect(csv[0]['Status']).to eq 'dismissed'
      expect(csv[0]['Dismissal Reason']).to eq 'Used in tests'
    end
  end

  context 'when a vulnerability was dismissed and then un-dismissed' do
    let_it_be(:vulnerability) { create(:vulnerability, :dismissed, project: project) }
    let_it_be(:vulnerability_read) { create(:vulnerability_read, :used_in_tests, vulnerability: vulnerability, project: project) }

    before do
      vulnerability.update!(state: :detected)
    end

    it 'does NOT populate the dismissal reason column' do
      expect(csv[0]['Status']).to eq 'detected'
      expect(csv[0]['Dismissal Reason']).to be_nil
    end
  end

  describe 'with Active Record relation' do
    before do
      create(:vulnerability, :with_read)
    end

    it 'generates the CSV content for records returned by the relation' do
      expect(csv.length).to be(1)
    end
  end

  describe 'CSV headers' do
    context 'with en locale' do
      let_it_be(:vulnerability) { create(:vulnerability, project: project) }

      it 'returns English headers' do
        ::Gitlab::I18n.with_locale('en') do
          expect(csv.headers).to eq(export_csv_service.send(:mapping).keys)
        end
      end
    end
  end

  it 'avoids N+1 queries' do
    def generate
      described_class.new(vulnerabilities).generate
    end

    create(:vulnerability, :with_finding, :with_notes)

    control = ActiveRecord::QueryRecorder.new { generate }

    create(:vulnerability, :with_finding, :with_notes)

    expect { generate }.not_to exceed_query_limit(control)
  end
end
