# frozen_string_literal: true

require 'spec_helper'

RSpec.describe VulnerabilityExports::CreateService, feature_category: :vulnerability_management do
  include AccessMatchersGeneric

  before do
    stub_licensed_features(security_dashboard: true)
  end

  let_it_be(:user) { create(:user, :auditor, :with_namespace) }

  let_it_be(:group) { create(:group) }
  let_it_be(:project) { create(:project, :public, group: group) }

  let(:export_format) { 'csv' }
  let(:params) { { export_format: } }

  subject(:result) { described_class.new(project, user, params).execute }

  shared_examples 'returns an in-progress error' do
    it 'rejects export creation request' do
      expect(result).not_to be_success
      expect(result.message).to eq("Export already in progress. Please retry after the current export completes.")
      expect(result.reason).to eq(:too_many_requests)
      expect(::VulnerabilityExports::ExportWorker).not_to have_received(:perform_async)
    end
  end

  shared_examples 'creates export successfully' do
    it 'creates a new export and schedules the worker' do
      expect { result }.to change { Vulnerabilities::Export.count }.by(1)
      expect(::VulnerabilityExports::ExportWorker).to have_received(:perform_async).with(recent_vulnerability_export.id)
    end
  end

  describe '#execute' do
    context 'when security dashboard feature is disabled' do
      before do
        stub_licensed_features(security_dashboard: false)
      end

      it 'raises an "access denied" error' do
        expect { result }.to raise_error(Gitlab::Access::AccessDeniedError)
      end
    end

    context 'when security dashboard feature is enabled' do
      let(:recent_vulnerability_export) { Vulnerabilities::Export.last }
      let(:params) { { export_format:, send_email: } }
      let(:send_email) { false }

      before do
        allow(::VulnerabilityExports::ExportWorker).to receive(:perform_async)
      end

      it 'does not raise an "access denied" error' do
        expect { result }.not_to raise_error
      end

      it 'creates a new Vulnerabilities::Export' do
        expect { result }.to change { Vulnerabilities::Export.count }.from(0).to(1)
      end

      it 'schedules ::VulnerabilityExports::ExportWorker background job' do
        result
        expect(::VulnerabilityExports::ExportWorker).to have_received(:perform_async).with(recent_vulnerability_export.id)
      end

      it 'returns a new Vulnerabilities::Export with correct attributes' do
        expect(result.payload[:vulnerability_export]).to have_attributes(
          project_id: project.id,
          format: export_format,
          send_email: send_email,
          status: 'created'
        )
      end

      context 'when send_email is true' do
        let(:send_email) { true }

        it "sets the export send_email to true" do
          result

          expect(recent_vulnerability_export.send_email).to eq(send_email)
        end
      end

      context 'when report_data is provided' do
        let(:params) { super().merge(report_data: report_data) }
        let(:report_data) { { project_vulnerabilities_history: { svg: 'svg' } } }

        it "sets the export\'s report_data field" do
          result

          expect(recent_vulnerability_export.report_data).to eq(report_data.as_json)
        end

        context 'when provided nil for report_data' do
          let(:report_data) { nil }

          it "results in noop" do
            result

            expect(recent_vulnerability_export.report_data).to eq({})
          end
        end
      end

      context 'when the export fails to persist' do
        before do
          allow(Vulnerabilities::Export).to receive(:create).and_return(
            build(:vulnerability_export, project: project, author: user, format: export_format).tap do |export|
              allow(export).to receive(:persisted?).and_return(false)
              export.errors.add(:base, 'Export creation failed')
            end
          )
        end

        it 'returns an error response with the export errors' do
          expect(result).not_to be_success
          expect(result.message).to include('Export creation failed')
          expect(result.reason).to eq(:unprocessable_entity)
          expect(::VulnerabilityExports::ExportWorker).to have_received(:perform_async)
        end
      end

      shared_examples 'handles existing export based on status' do
        context 'when there is an export in progress' do
          where(:status) { %i[created running] }

          with_them do
            let!(:existing_export) do
              create(:vulnerability_export, :with_csv_file, status: status, author: user, **export_association)
            end

            it_behaves_like 'returns an in-progress error'

            context 'when export was created outside the window' do
              before do
                existing_export.update!(created_at: 1.minute.before(Vulnerabilities::Export::RECENT_WINDOW.ago))
              end

              it_behaves_like 'creates export successfully'
            end
          end
        end

        context 'when there is a finished export' do
          where(:status) { %i[failed finished] }

          with_them do
            let!(:existing_export) do
              create(:vulnerability_export, :with_csv_file, status: status, author: user, **export_association)
            end

            it_behaves_like 'creates export successfully'
          end
        end
      end

      context "for an instance export" do
        before_all do
          create(:users_security_dashboard_project, project: project, user: user)
        end

        let(:export_association) { { project: nil, group: nil } }

        subject(:result) { described_class.new(user.security_dashboard, user, params).execute }

        it_behaves_like 'handles existing export based on status'
      end

      context "for a project export" do
        let(:export_association) { { project: project, group: nil } }

        it_behaves_like 'handles existing export based on status'
      end

      context "for a group export" do
        let(:export_association) { { group: group, project: nil } }

        subject(:result) { described_class.new(group, user, params).execute }

        it_behaves_like 'handles existing export based on status'
      end
    end
  end
end
