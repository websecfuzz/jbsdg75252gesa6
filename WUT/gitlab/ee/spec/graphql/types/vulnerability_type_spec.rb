# frozen_string_literal: true

require 'spec_helper'

RSpec.describe GitlabSchema.types['Vulnerability'], feature_category: :vulnerability_management do
  let_it_be(:project) { create(:project) }
  let_it_be(:user) { create(:user) }
  let_it_be_with_reload(:vulnerability) { create(:vulnerability, :with_remediation, project: project) }
  let(:vulnerabilities) { graphql_response.dig('data', 'project', 'vulnerabilities', 'nodes') }
  let(:query) do
    %(
      query {
        project(fullPath: "#{project.full_path}") {
          vulnerabilities {
            nodes {
              #{query_field}
            }
          }
        }
      }
    )
  end

  let_it_be(:fields) do
    %i[
      userPermissions
      id
      uuid
      title
      description
      descriptionHtml
      solution
      user_notes_count
      state
      severity
      severity_overrides
      cve_enrichment
      report_type
      resolved_on_default_branch
      vulnerability_path
      name
      web_url
      location
      scanner
      primary_identifier
      identifiers
      project
      issueLinks
      detected_at
      confirmed_at
      resolved_at
      dismissed_at
      updated_at
      notes
      external_issue_links
      links
      dependencies
      has_remediations
      false_positive
      state_comment
      merge_request
      discussions
      confirmed_by
      resolved_by
      dismissed_by
      details
      commenters
      state_transitions
      dismissal_reason
      present_on_default_branch
      cvss
      aiResolutionAvailable
      aiResolutionEnabled
      representationInformation
      reachability
      archivalInformation
      findingTokenStatus
      initialDetectedPipeline
      latestDetectedPipeline
    ]
  end

  RSpec.shared_examples "N+1 queries" do |single_query_count|
    it 'avoids N+1 database queries', :request_store do
      GitlabSchema.execute(query, context: { current_user: user })

      control_count = ActiveRecord::QueryRecorder.new { GitlabSchema.execute(query, context: { current_user: user }) }.count
      expect(control_count <= single_query_count).to be_truthy

      create_three_vulnerabilities = create_list(:vulnerability, 3, :with_finding, :with_state_transition, :with_remediation, project: project)
      create_three_vulnerabilities.each do |v|
        occurrence = create(:sbom_occurrence, reachability: :in_use)
        create(:sbom_occurrences_vulnerability, vulnerability: v, occurrence: occurrence)

        create(:vulnerabilities_external_issue_link, vulnerability: v, author: user)
        create(:finding_link, finding: v.finding)
      end

      expect { GitlabSchema.execute(query, context: { current_user: user }) }.not_to exceed_query_limit(single_query_count)
    end
  end

  before do
    stub_licensed_features(security_dashboard: true, sast_fp_reduction: true, dependency_scanning: true)

    project.add_developer(user)
  end

  subject(:graphql_response) { GitlabSchema.execute(query, context: { current_user: user }).as_json }

  it { expect(described_class.interfaces).to include(Types::TodoableInterface) }
  it { expect(described_class).to have_graphql_fields(fields) }
  it { expect(described_class).to require_graphql_authorizations(:read_vulnerability) }

  describe 'vulnerability_path' do
    let(:query_field) { 'vulnerabilityPath' }

    it "is the path to the vulnerability's detail page" do
      expect(vulnerabilities.first['vulnerabilityPath']).to match(%r{^/#{project.full_path}/-/security/vulnerabilities/[0-9]+})
    end
  end

  describe 'stateComment' do
    let(:query_field) { 'stateComment' }
    let(:state_comment) { subject.dig(*%w[data project vulnerabilities nodes]).first["stateComment"] }

    let_it_be(:state_transition) { create(:vulnerability_state_transition, :from_detected, :to_dismissed, vulnerability: vulnerability) }

    it 'returns the comment for the latest state transition' do
      expect(state_comment).to eq(state_transition.comment)
    end

    context 'N+1 queries' do
      single_query_count = 14

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'web_url' do
    let(:query_field) { 'webUrl' }

    it "is the URL to the vulnerability's detail page" do
      vulnerabilities = subject.dig('data', 'project', 'vulnerabilities', 'nodes')

      expect(vulnerabilities.first['webUrl']).to match(%r{^http://localhost/#{project.full_path}/-/security/vulnerabilities/[0-9]+})
    end
  end

  describe 'has_remediations' do
    let(:query_field) { 'hasRemediations' }

    context 'N+1 queries' do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'false_positive' do
    let_it_be(:vulnerability_with_finding) { create(:vulnerability, :with_findings, project: project) }
    let(:query_field) { 'falsePositive' }

    context 'when the vulnerability has a false-positive flag' do
      before do
        create(:vulnerabilities_flag, finding: vulnerability_with_finding.finding)
      end

      it 'returns true for false positive field', quarantine: 'https://gitlab.com/gitlab-org/gitlab/-/issues/338073' do
        expect(vulnerabilities.first['falsePositive']).to be(true)
      end
    end

    context 'when the license is missing' do
      before do
        stub_licensed_features(security_dashboard: true, sast_fp_reduction: false)
      end

      it 'returns nil' do
        expect(vulnerabilities.first['falsePositive']).to be_nil
      end
    end

    context 'when the vulnerability does not have any false positive flag' do
      it 'returns false for false-positive field' do
        expect(vulnerabilities.first['falsePositive']).to be(false)
      end
    end
  end

  describe '#description' do
    let_it_be_with_reload(:vulnerability_with_finding) { create(:vulnerability, :with_findings, project: project) }
    let(:query_field) { 'description' }

    context 'when the vulnerability description field is populated' do
      it 'returns the description for the vulnerability' do
        expect(vulnerabilities.first['description']).to eq(vulnerability_with_finding.description)
      end
    end

    context 'when the vulnerability description field is empty' do
      before do
        vulnerability_with_finding.description = nil
        vulnerability_with_finding.save!
      end

      it 'returns the description for the vulnerability finding' do
        expect(vulnerabilities.first['description']).to eq(vulnerability_with_finding.finding.description)
      end
    end
  end

  describe '#descriptionHtml' do
    let_it_be(:vulnerability_with_finding) { create(:vulnerability, :with_findings, project: project) }
    let(:query_field) { 'descriptionHtml' }

    context 'when the vulnerability descriptionHtml field is populated' do
      it 'returns the description for the vulnerability' do
        expect(vulnerabilities.first['descriptionHtml']).to eq(vulnerability_with_finding.description_html)
      end
    end

    context 'when the vulnerability descriptionHtml field is empty' do
      before do
        vulnerability_with_finding.description_html = nil
        vulnerability_with_finding.save!
      end

      it 'returns the descriptionHtml for the vulnerability finding' do
        expect(vulnerabilities.first['descriptionHtml']).to eq(vulnerability_with_finding.description_html)
      end
    end
  end

  describe "#primary_identifier" do
    let(:vulnerability) { create(:vulnerability, :with_finding, project: project) }
    let(:query_field) { 'primaryIdentifier { externalId }' }

    it "returns the primary identifier" do
      expect(vulnerabilities.first['primaryIdentifier']['externalId']).to eq(vulnerability.finding.primary_identifier.external_id)
    end

    context "N+1 issues" do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe '#identifiers' do
    let(:project) { create(:project) }
    let(:query_field) { 'identifiers { externalId }' }
    let(:identifiers) { vulnerabilities.flat_map { |v| v['identifiers'] } }

    context 'when the vulnerability is missing identifiers' do
      before do
        vulnerability = create(:vulnerability, :with_finding, project: project)
        vulnerability.findings.update_all(vulnerability_id: nil)
      end

      it 'defaults to an empty array' do
        expect(identifiers).to eq []
      end
    end
  end

  describe 'dismissal_reason' do
    let(:query_field) { 'dismissalReason' }
    let_it_be(:state_transition) { create(:vulnerability_state_transition, :from_detected, :to_dismissed, :used_in_tests, vulnerability: vulnerability) }

    context 'when vulnerability_read is present' do
      before do
        # This simulates Vulnerabilities::DismissService
        vulnerability.update!(state: :dismissed, dismissed_by_id: user.id, dismissed_at: Time.current)
        vulnerability.vulnerability_read.update!(dismissal_reason: state_transition.dismissal_reason)
      end

      it 'is populated from Vulnerabilities::Read object' do
        expect(vulnerabilities.first['dismissalReason']).to eq("USED_IN_TESTS")
      end
    end

    context 'when vulnerability_read is nil' do
      before do
        allow_next_instance_of(::Types::VulnerabilityType) do |instance|
          allow(instance).to receive(:object).and_return(vulnerability)
        end

        allow(vulnerability).to receive(:vulnerability_read).and_return(nil)
      end

      it 'returns nil and does not raise an error' do
        expect(vulnerabilities.first['dismissalReason']).to be_nil
      end
    end
  end

  describe 'merge_request' do
    let_it_be(:vulnerability_with_finding) { create(:vulnerability, :with_finding, project: project) }
    let_it_be(:merge_request) { create(:merge_request, source_project: project, description: 'Description for test') }
    let(:query_field) { 'mergeRequest { id }' }

    subject(:returned_mr_id) { vulnerabilities.first['mergeRequest']['id'] }

    before do
      create(:vulnerabilities_merge_request_link, vulnerability: vulnerability_with_finding, merge_request: merge_request)
    end

    it 'returns the merge request through merge_request_link' do
      expect(returned_mr_id).to eq(merge_request.to_global_id.uri.to_s)
    end
  end

  describe 'present_on_default_branch' do
    let_it_be(:vulnerability_with_finding) { create(:vulnerability, :with_finding, project: project) }
    let(:query_field) { 'presentOnDefaultBranch' }

    context 'when vulnerability is present on default branch' do
      it 'returns true for presentOnDefaultBranch field' do
        expect(vulnerabilities.first['presentOnDefaultBranch']).to be(true)
      end
    end

    context 'when vulnerability is not present on default branch' do
      before do
        vulnerability_with_finding.update!(present_on_default_branch: false)
      end

      it 'returns false for presentOnDefaultBranch field' do
        expect(vulnerabilities.first['presentOnDefaultBranch']).to be(false)
      end
    end
  end

  describe 'cvss' do
    let(:query_field) { 'cvss { vendor vector version baseScore overallScore severity }' }

    subject(:cvss) { vulnerabilities.first['cvss'] }

    before do
      vulnerability.update!(cvss: cvss_data)
    end

    context 'when vulnerability has cvss data' do
      let(:cvss_data) { [{ vendor: 'GitLab', vector: 'CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N' }] }

      it 'returns all attributes' do
        data = cvss.first

        expect(data['vendor']).to eq('GitLab')
        expect(data['vector']).to eq('CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N')
        expect(data['version']).to eq(3.1)
        expect(data['baseScore']).to eq(3.8)
        expect(data['overallScore']).to eq(3.8)
        expect(data['severity']).to eq('LOW')
      end
    end

    context 'when vulnerability does not have cvss data' do
      let(:cvss_data) { [] }

      it 'returns an empty array' do
        expect(cvss).to be_empty
      end
    end
  end

  describe 'aiResolutionAvailable' do
    let(:query_field) { 'aiResolutionAvailable' }

    subject { vulnerabilities.first['aiResolutionAvailable'] }

    context 'when the vulnerability is of type SAST' do
      it { is_expected.to be true }
    end

    context 'when the vulnerability is not of type SAST' do
      before do
        vulnerability.finding.update!(report_type: 'dast')
      end

      it { is_expected.to be false }
    end
  end

  describe 'aiResolutionEnabled' do
    let(:query_field) { 'aiResolutionEnabled' }

    subject { vulnerabilities.first['aiResolutionEnabled'] }

    context 'when the vulnerability is of a supported CWE' do
      before do
        vulnerability.vulnerability_read.update!(has_vulnerability_resolution: true)
      end

      it { is_expected.to be true }
    end

    context 'when the vulnerability is not of a supported CWE' do
      before do
        vulnerability.vulnerability_read.update!(has_vulnerability_resolution: false)
      end

      it { is_expected.to be false }
    end

    context 'when vulnerability_read is nil' do
      before do
        allow_next_instance_of(::Types::VulnerabilityType) do |instance|
          allow(instance).to receive(:object).and_return(vulnerability)
        end

        allow(vulnerability).to receive(:vulnerability_read).and_return(nil)
      end

      it { is_expected.to be_nil }
    end
  end

  describe 'reachability' do
    let(:query_field) { 'reachability' }

    subject { vulnerabilities.first['reachability'] }

    it { is_expected.to be_nil }

    context 'with report type set to dependency scanning' do
      let_it_be_with_reload(:vulnerability) { create(:vulnerability, :with_remediation, project: project, report_type: :dependency_scanning) }

      it { is_expected.to eq 'UNKNOWN' }

      %i[in_use not_found].each do |reachability|
        context "when the vulnerability has related sbom_occurrences record with reachability set to `#{reachability}`" do
          let_it_be(:occurrence) { create(:sbom_occurrence, reachability: reachability) }
          let_it_be(:sbom_occurrences_vulnerability) { create(:sbom_occurrences_vulnerability, vulnerability: vulnerability, occurrence: occurrence) }

          it { is_expected.to eq reachability.to_s.upcase }
        end
      end
    end

    context 'N+1 queries' do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'external_issue_links' do
    let(:query_field) { 'externalIssueLinks {edges{node{id}}}' }

    let_it_be(:external_issue_link) { create(:vulnerabilities_external_issue_link, vulnerability: vulnerability, author: user) }

    it 'returns the external issue link' do
      expect(vulnerabilities.first.dig('externalIssueLinks', 'edges').first.dig('node', 'id')).to eq(external_issue_link.to_global_id.to_s)
    end

    context 'N+1 queries' do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'links' do
    let(:query_field) { 'links {name}' }

    let_it_be(:finding_link) { create(:finding_link, finding: vulnerability.finding) }

    it 'returns the finding link' do
      expect(vulnerabilities.first['links'].first['name']).to eq(finding_link.name)
    end

    context 'N+1 queries' do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe '.authorization_scopes' do
    it 'includes :ai_workflows' do
      expect(described_class.authorization_scopes).to include(:ai_workflows)
    end
  end

  describe 'field scopes' do
    {
      'id' => %i[api read_api ai_workflows],
      'title' => %i[api read_api ai_workflows],
      'description' => %i[api read_api ai_workflows],
      'state' => %i[api read_api ai_workflows],
      'severity' => %i[api read_api ai_workflows],
      'reportType' => %i[api read_api ai_workflows],
      'resolvedOnDefaultBranch' => %i[api read_api ai_workflows],
      'location' => %i[api read_api ai_workflows],
      'scanner' => %i[api read_api ai_workflows],
      'identifiers' => %i[api read_api ai_workflows],
      'project' => %i[api read_api ai_workflows],
      'confirmedAt' => %i[api read_api ai_workflows],
      'dismissedAt' => %i[api read_api ai_workflows],
      'updatedAt' => %i[api read_api ai_workflows],
      'dismissedBy' => %i[api read_api ai_workflows]
    }.each do |field, scopes|
      it "includes the correct scopes for #{field}" do
        expect(described_class.fields[field].instance_variable_get(:@scopes)).to include(*scopes)
      end
    end
  end

  describe 'initialDetectedPipeline' do
    let(:query_field) { 'initialDetectedPipeline { id }' }

    context 'when there is an initial pipeline' do
      let_it_be(:initial_pipeline) { create(:ci_pipeline, project: project) }
      let_it_be(:vulnerability_with_initial_pipeline) do
        finding = create(:vulnerabilities_finding, project: project, pipeline: initial_pipeline)
        create(:vulnerability, project: project, findings: [finding])
      end

      it 'returns the pipeline in which the vulnerability was first detected' do
        expect(vulnerabilities.first['initialDetectedPipeline']['id']).to eq(initial_pipeline.to_global_id.to_s)
      end
    end

    context 'when there is no initial pipeline' do
      it 'returns nil' do
        expect(vulnerabilities.first['initialDetectedPipeline']).to be_nil
      end
    end

    context 'N+1 queries' do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'latestDetectedPipeline' do
    let(:query_field) { 'latestDetectedPipeline { id }' }
    let_it_be(:latest_pipeline) { create(:ci_pipeline, project: project) }

    before do
      vulnerability.finding.update!(latest_pipeline_id: latest_pipeline.id)
    end

    it 'returns the pipeline in which the vulnerability was last detected' do
      expect(vulnerabilities.first['latestDetectedPipeline']['id']).to eq(latest_pipeline.to_global_id.to_s)
    end

    context 'when there is no latest pipeline' do
      before do
        vulnerability.finding.update!(latest_pipeline_id: nil)
      end

      it 'returns nil' do
        expect(vulnerabilities.first['latestDetectedPipeline']).to be_nil
      end
    end

    context 'N+1 queries' do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end
end
