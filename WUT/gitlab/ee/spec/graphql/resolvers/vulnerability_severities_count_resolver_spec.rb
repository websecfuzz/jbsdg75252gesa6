# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Resolvers::VulnerabilitySeveritiesCountResolver, feature_category: :vulnerability_management do
  include GraphqlHelpers

  shared_context "with vulnerability dismissed with a reason" do
    let_it_be(:dismissed_vulnerability) { create(:vulnerability, :dismissed, severity: :low, project: project) }
    let_it_be(:dismissed_vulnerability_read) do
      create(
        :vulnerability_read,
        :used_in_tests,
        state: dismissed_vulnerability.state,
        severity: dismissed_vulnerability.severity,
        vulnerability: dismissed_vulnerability,
        project: project
      )
    end
  end

  describe '#resolve' do
    subject(:resolved) { resolve(described_class, obj: vulnerable, args: filters, ctx: { current_user: current_user }) }

    let_it_be(:group) { create(:group) }
    let_it_be(:project) { create(:project, :security_and_compliance_enabled, group: group) }
    let_it_be(:cluster_agent) { create(:cluster_agent, project: project) }
    let_it_be(:user) { create(:user, security_dashboard_projects: [project]) }

    let_it_be(:low_vulnerability) do
      create(:vulnerability, :with_findings, :detected, :low, :dast, project: project)
        .tap { |v| v.vulnerability_read.update!(traversal_ids: v.project&.namespace&.traversal_ids) }
    end

    let_it_be(:medium_vulnerability) do
      create(:vulnerability, :with_cluster_image_scanning_finding, :detected, :medium, project: project, agent_id: cluster_agent.id)
        .tap { |v| v.vulnerability_read.update!(traversal_ids: v.project&.namespace&.traversal_ids) }
    end

    let_it_be(:critical_vulnerability) do
      create(:vulnerability, :with_findings, :detected, :critical, :sast, :with_merge_request_links, project: project)
        .tap { |v| v.vulnerability_read.update!(has_vulnerability_resolution: true) }
        .tap { |v| v.vulnerability_read.update!(traversal_ids: v.project&.namespace&.traversal_ids) }
    end

    let_it_be(:high_vulnerability) do
      create(:vulnerability, :with_findings, :dismissed, :high, :container_scanning, :with_issue_links, resolved_on_default_branch: true, project: project)
        .tap { |v| v.vulnerability_read.update!(traversal_ids: v.project&.namespace&.traversal_ids) }
    end

    let(:current_user) { user }
    let(:filters) { {} }
    let(:vulnerable) { project }

    context 'when the user does not have access' do
      it 'is redacted' do
        is_expected.to be_nil
      end
    end

    context 'when the user has access' do
      before do
        stub_licensed_features(security_dashboard: true)
        project.add_developer(current_user)
      end

      it_behaves_like 'vulnerability filterable', :filters

      context 'when given severities' do
        let(:filters) { { severity: ['low'] } }

        it 'only returns count for low severity vulnerability' do
          is_expected.to eq('low' => 1)
        end
      end

      context 'when given states' do
        let(:filters) { { state: ['dismissed'] } }

        it 'only returns counts for vulnerabilities that match the given state' do
          is_expected.to eq('high' => 1)
        end

        context 'when filtering only by state' do
          let(:filters) { { state: %w[detected dismissed] } }

          # Here we WANT to match high_vulnerability because it does not have a dismissal_reason
          it 'only returns vulnerabilities with matching states' do
            is_expected.to eq('critical' => 1, 'high' => 1, 'medium' => 1, 'low' => 1)
          end
        end

        context 'when filtering with states and dismissal_reason' do
          include_context "with vulnerability dismissed with a reason"

          let(:filters) { { state: ["detected"], dismissal_reason: ["used_in_tests"] } }

          # Here we DON'T WANT to match high_vulnerability because it does not have a dismissal_reason
          it 'only returns counts vulnerabilities that match the filters' do
            is_expected.to eq('critical' => 1, 'medium' => 1, 'low' => 2)
          end
        end

        context 'when filtering with dismissal_reason' do
          include_context "with vulnerability dismissed with a reason"

          let(:filters) { { dismissal_reason: ["used_in_tests"] } }

          it 'only returns counts for vulnerabilities dismissed with the given reason' do
            is_expected.to eq('low' => 1)
          end
        end
      end

      context 'when given scanner' do
        let(:filters) { { scanner: [high_vulnerability.finding_scanner_external_id] } }

        it 'only returns count for high severity vulnerability' do
          is_expected.to eq('high' => 1)
        end
      end

      context 'when given image' do
        let(:filters) { { image: [medium_vulnerability.finding.image] } }

        it 'only returns count for medium severity vulnerability' do
          is_expected.to eq('medium' => 1)
        end
      end

      context 'when given cluster agent id' do
        let(:filters) { { cluster_agent_id: [cluster_agent.to_global_id.to_s] } }

        it 'only returns count for medium severity vulnerability' do
          is_expected.to eq('medium' => 1)
        end
      end

      context 'when given scanner ID' do
        let(:filters) { { scanner_id: [GitlabSchema.id_from_object(high_vulnerability.finding.scanner)] } }

        it 'only returns count for vulnerabilities with scanner ID' do
          is_expected.to eq('high' => 1)
        end
      end

      context 'when given report types' do
        let(:filters) { { report_type: %i[dast sast] } }

        it 'only returns count for vulnerabilities of the given report types' do
          is_expected.to eq('critical' => 1, 'low' => 1, 'medium' => 1)
        end
      end

      context 'when resolving vulnerabilities for a project' do
        it "returns the project's vulnerabilities" do
          is_expected.to eq('critical' => 1, 'high' => 1, 'low' => 1, 'medium' => 1)
        end
      end

      context 'when filtering vulnerabilities with issues' do
        let(:filters) { { has_issues: true } }

        it 'only returns count for vulnerabilities with issues' do
          is_expected.to eq('high' => 1)
        end
      end

      context 'when filtering vulnerabilities with issues' do
        let(:filters) { { has_issues: false } }

        it 'only returns count for vulnerabilities with issues' do
          is_expected.to eq('critical' => 1, 'low' => 1, 'medium' => 1)
        end
      end

      context 'when filtering resolved vulnerabilities' do
        let(:filters) { { has_resolution: true } }

        it 'only returns count for resolved vulnerabilities' do
          is_expected.to eq('high' => 1)
        end
      end

      context 'when filtering resolved vulnerabilities' do
        let(:filters) { { has_resolution: false } }

        it 'only returns count for resolved vulnerabilities' do
          is_expected.to eq('critical' => 1, 'low' => 1, 'medium' => 1)
        end
      end

      context 'when filtering vulnerabilities with merge request' do
        let(:filters) { { has_merge_request: true } }

        it 'only returns count for vulnerabilities with merge request' do
          is_expected.to eq('critical' => 1)
        end
      end

      context 'when filtering vulnerabilities with no merge request' do
        let(:filters) { { has_merge_request: false } }

        it 'only returns count for vulnerabilities with no merge request' do
          is_expected.to eq('high' => 1, 'low' => 1, 'medium' => 1)
        end
      end

      context 'when filtering vulnerabilities with AI resolution' do
        context 'when has_ai_resolution is set to true' do
          let(:filters) { { has_ai_resolution: true } }

          it 'only returns count for vulnerabilities with AI resolutions' do
            is_expected.to eq('critical' => 1)
          end
        end

        context 'when has_ai_resolution is set to false' do
          let(:filters) { { has_ai_resolution: false } }

          it 'only returns count for vulnerabilities without AI resolutions' do
            is_expected.to eq('high' => 1, 'low' => 1, 'medium' => 1)
          end
        end
      end

      context 'when filtering vulnerabilities with remediations' do
        let(:filters) { { has_remediations: true } }
        let_it_be(:vulnerability_read_with_remediations) { create(:vulnerability_read, :with_remediations, project: project) }

        it 'only returns count for vulnerabilities with remediations' do
          is_expected.to eq('high' => 1)
        end
      end

      context 'when filtering vulnerabilities with no remediations' do
        let(:filters) { { has_remediations: false } }

        it 'only returns count for vulnerabilities with no remediations' do
          is_expected.to eq('critical' => 1, 'high' => 1, 'low' => 1, 'medium' => 1)
        end
      end

      context 'when filtering vulnerabilities with owasp_top_10' do
        let(:filters) do
          { owasp_top_ten: ['A1:2017-Injection'] }
        end

        let_it_be(:vuln_read_with_owasp_top_10_first) do
          create(:vulnerability_read, :with_owasp_top_10, severity: :high, project: project)
        end

        let_it_be(:vuln_read) { create(:vulnerability_read, severity: :medium) }

        it 'only returns count for vulnerabilities with owasp_top_10' do
          is_expected.to eq('high' => 1)
        end
      end

      context 'when filtering vulnerabilities with owasp_top_10_2021', :elastic do
        let(:filters) do
          { owasp_top_ten_2021: ['A1:2021-Broken Access Control'] }
        end

        let_it_be(:vuln_read_with_owasp_top_10_first) do
          create(:vulnerability_read, :with_owasp_top_10, severity: :high, project: project,
            identifier_names: ['A1:2021-Broken Access Control'])
        end

        let_it_be(:vuln_read_with_owasp_top_10_second) do
          create(:vulnerability_read, :with_owasp_top_10,
            owasp_top_10: 'A1:2021-Broken Access Control', severity: :low, project: project,
            identifier_names: ['A1:2021-Broken Access Control'])
        end

        let_it_be(:vuln_read) { create(:vulnerability_read, severity: :medium) }

        context 'without elasticsearch' do
          before do
            allow(::Search::Elastic::VulnerabilityIndexingHelper).to receive(:vulnerability_indexing_allowed?).and_return(false)
          end

          it_behaves_like 'raises ES errors'
        end

        context 'with advanced_vulnerability_management FF disabled' do
          before do
            allow(::Search::Elastic::VulnerabilityIndexingHelper).to receive(:vulnerability_indexing_allowed?).and_return(true)
            stub_feature_flags(advanced_vulnerability_management: false)
          end

          it_behaves_like 'raises ES errors'
        end

        context 'with elastic search' do
          before do
            stub_ee_application_setting(elasticsearch_search: true, elasticsearch_indexing: true)

            Elastic::ProcessBookkeepingService.track!(
              low_vulnerability.vulnerability_read,
              medium_vulnerability.vulnerability_read,
              critical_vulnerability.vulnerability_read,
              high_vulnerability.vulnerability_read,
              vuln_read_with_owasp_top_10_first,
              vuln_read_with_owasp_top_10_second
            )
            ensure_elasticsearch_index!

            allow(::Search::Elastic::VulnerabilityIndexingHelper).to receive(:vulnerability_indexing_allowed?).and_return(true)

            allow(current_user).to receive(:can?).and_call_original
            allow(current_user).to receive(:can?).with(:access_advanced_vulnerability_management, vulnerable).and_return(true)
          end

          it 'only returns count for vulnerabilities with matching owasp_top_10_2021 values in dientifier_names' do
            expect(Gitlab::Search::Client).to receive(:execute_search).and_call_original
            is_expected.to eq('high' => 1, 'low' => 1)
          end

          context 'when owasp_top_ten_2021 includes "none" and other values' do
            it_behaves_like 'validates owasp_top_ten_2021 filter', :filters
          end

          context 'with reachability as parameter' do
            using RSpec::Parameterized::TableSyntax

            let_it_be(:vuln_read_without_occurrences) do
              [
                low_vulnerability.vulnerability_read,
                medium_vulnerability.vulnerability_read,
                critical_vulnerability.vulnerability_read,
                high_vulnerability.vulnerability_read,
                vuln_read_with_owasp_top_10_first,
                vuln_read_with_owasp_top_10_second
              ]
            end

            let_it_be(:vuln_read_in_use) do
              sbom_occurrence_in_use = create(:sbom_occurrence, reachability: :in_use)
              vuln_read = create(:vulnerability_read, report_type: :dependency_scanning, project: project, severity: :critical)
              create(:sbom_occurrences_vulnerability, occurrence: sbom_occurrence_in_use, vulnerability: vuln_read.vulnerability)

              vuln_read
            end

            let_it_be(:vuln_read_not_found) do
              sbom_occurrence_not_found = create(:sbom_occurrence, reachability: :not_found)
              vuln_read = create(:vulnerability_read, report_type: :dependency_scanning, project: project, severity: :high)
              create(:sbom_occurrences_vulnerability, occurrence: sbom_occurrence_not_found, vulnerability: vuln_read.vulnerability)

              vuln_read
            end

            before do
              Elastic::ProcessBookkeepingService.track!(
                vuln_read_in_use,
                vuln_read_not_found
              )
              ensure_elasticsearch_index!
            end

            where(:reachability, :expected_result) do
              :in_use | { 'critical' => 1 }
              :not_found | { 'high' => 1 }
              :unknown | { 'critical' => 1, 'high' => 2, 'medium' => 1, 'low' => 2 }
            end

            with_them do
              let(:filters) { { reachability: reachability } }

              it 'only considers vulnerabilities with matching reachability values' do
                expect(Gitlab::Search::Client).to receive(:execute_search).and_call_original

                is_expected.to eq(expected_result)
              end
            end
          end
        end
      end

      context 'when filtering vulnerabilities with identifier_name' do
        let!(:vul_read_with_identifier_name) do
          create(:vulnerability_read, :with_identifer_name, project: project, severity: :critical)
        end

        let(:filters) { { identifier_name: vul_read_with_identifier_name.identifier_names.first } }

        let_it_be(:vul_read_without_identifier_name) { create(:vulnerability_read, project: project, severity: :low) }

        shared_examples_for 'when elasticsearch is available', :elastic do
          before do
            stub_ee_application_setting(elasticsearch_search: true, elasticsearch_indexing: true)

            Elastic::ProcessBookkeepingService.track!(
              vul_read_with_identifier_name, vul_read_without_identifier_name
            )
            ensure_elasticsearch_index!

            allow(::Search::Elastic::VulnerabilityIndexingHelper).to receive(:vulnerability_indexing_allowed?).and_return(true)

            allow(current_user).to receive(:can?).and_call_original
            allow(current_user).to receive(:can?).with(:access_advanced_vulnerability_management, vulnerable).and_return(true)
          end

          it 'retuns counts from elasticsearch' do
            expect(Gitlab::Search::Client).to receive(:execute_search).and_call_original
            is_expected.to eq('critical' => 1)
          end
        end

        context 'when vulnerable is a project' do
          it 'only returns count for vulnerabilities with identifier_name' do
            is_expected.to eq('critical' => 1)
          end

          it_behaves_like 'when elasticsearch is available'
        end

        context 'when vulnerable is a group' do
          let(:vulnerable) { group }

          before_all do
            group.add_developer(user)
          end

          context 'when the group has more vulnerabilities than the max' do
            let(:error_msg) { 'Group has more than 20k vulnerabilities.' }
            let(:max) { group.vulnerabilities.count - 1 }

            before do
              stub_const(
                '::Security::GroupIdentifierSearch::MAX_VULNERABILITY_COUNT_GROUP_SUPPORT', max
              )
              allow(::Security::ProjectStatistics).to receive(:sum_vulnerability_count_for_group)
                                                        .with(group).and_return(group.vulnerabilities.count)
            end

            it 'raises an error' do
              expect_graphql_error_to_be_created(Gitlab::Graphql::Errors::ArgumentError, s_(error_msg)) do
                resolved
              end
              expect(::Security::ProjectStatistics).to have_received(:sum_vulnerability_count_for_group).once
            end

            it_behaves_like 'when elasticsearch is available'
          end

          context 'when the group has fewer vulnerabilities than the max' do
            it 'only returns count for vulnerabilities with identifier_name' do
              is_expected.to eq('critical' => 1)
            end
          end
        end

        context 'when filtering vulnerabilities with capped' do
          let_it_be(:stubbed_limit) { 1 }
          let_it_be(:over_limit) { stubbed_limit + 1 }
          let_it_be(:capped_group) { create(:group) }
          let_it_be(:capped_project) { create(:project, :security_and_compliance_enabled, namespace: capped_group) }

          let(:capped_flag) { nil }
          let(:filters) { { capped: capped_flag } }

          before_all do
            create_list(:vulnerability, over_limit, :with_read, :low, project: capped_project)
            create_list(:vulnerability, over_limit, :with_read, :high, project: capped_project)
          end

          before do
            stub_const("::Vulnerabilities::Read::SEVERITY_COUNT_LIMIT", stubbed_limit)
          end

          shared_examples_for 'capped tests' do
            context 'when capped is false' do
              let(:capped_flag) { false }

              it 'returns counts for vulnerabilities without cap' do
                is_expected.to eq('low' => over_limit, 'high' => over_limit)
              end
            end

            context 'when capped is true' do
              let(:capped_flag) { true }

              it 'returns counts for vulnerabilities with cap' do
                is_expected.to eq('low' => stubbed_limit, 'high' => stubbed_limit)
              end
            end
          end

          context 'when vulnerable is a project' do
            let(:vulnerable) { capped_project }

            before_all do
              capped_project.add_developer(user)
            end

            it_behaves_like 'capped tests'
          end

          context 'when vulnerable is a group' do
            let(:vulnerable) { capped_group }

            before_all do
              capped_group.add_developer(user)
            end

            it_behaves_like 'capped tests'
          end
        end
      end
    end

    context 'when resolving vulnerabilities for an instance security dashboard' do
      before do
        stub_licensed_features(security_dashboard: true)
        project.add_developer(user)
      end

      let(:vulnerable) { InstanceSecurityDashboard.new(current_user) }

      context 'when there is a current user' do
        it "returns vulnerabilities for all projects on the current user's instance security dashboard" do
          is_expected.to eq('critical' => 1, 'high' => 1, 'low' => 1, 'medium' => 1)
        end

        context 'when given a dismissal_reason' do
          include_context "with vulnerability dismissed with a reason"

          let(:filters) { { dismissal_reason: ["used_in_tests"] } }

          it "returns vulnerability counts that match the dismissal reason" do
            is_expected.to eq('low' => 1)
          end
        end

        context 'when filtering by state' do
          let(:filters) { { state: %w[detected dismissed] } }

          it 'only returns vulnerabilities with matching states' do
            is_expected.to eq('critical' => 1, 'high' => 1, 'medium' => 1, 'low' => 1)
          end
        end

        context 'when filtering by state and report type' do
          let(:filters) { { state: %w[detected dismissed], report_type: %w[dast] } }

          it 'only returns vulnerabilities with matching states' do
            is_expected.to eq('low' => 1)
          end
        end

        context 'when filtering by capped' do
          let(:stubbed_limit) { 2 }
          let(:over_limit) { stubbed_limit + 1 }
          let(:filters) { { capped: true } }

          before do
            stub_const("::Vulnerabilities::Read::SEVERITY_COUNT_LIMIT", stubbed_limit)
            create_list(:vulnerability, over_limit, :with_read, :low, project: project)
          end

          it 'returns count with limit applied' do
            is_expected.to eq('critical' => 1, 'high' => 1, 'medium' => 1, 'low' => stubbed_limit)
          end
        end

        context 'when has_ai_resolution is set to true' do
          let(:filters) { { has_ai_resolution: true } }

          it 'only returns count for vulnerabilities with AI resolutions' do
            is_expected.to eq('critical' => 1)
          end
        end

        context 'when has_ai_resolution is set to false' do
          let(:filters) { { has_ai_resolution: false } }

          it 'only returns count for vulnerabilities without AI resolutions' do
            is_expected.to eq('high' => 1, 'low' => 1, 'medium' => 1)
          end
        end

        context 'when filtering vulnerabilities with owasp_top_10_2021', :elastic do
          let(:filters) { { owasp_top_ten_2021: ['A1:2021-Broken Access Control'] } }
          let(:error_msg) { "Feature is not supported for InstanceSecurityDashboard" }

          it 'raises an error' do
            expect_graphql_error_to_be_created(Gitlab::Graphql::Errors::ArgumentError, s_(error_msg)) do
              resolved
            end
          end
        end

        it_behaves_like 'vulnerability filterable', :filters
      end

      context 'without a current user' do
        let(:current_user) { nil }

        it 'returns no vulnerabilities' do
          is_expected.to be_blank
        end
      end
    end
  end
end
