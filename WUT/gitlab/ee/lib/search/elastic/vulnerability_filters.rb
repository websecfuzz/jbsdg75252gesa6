# frozen_string_literal: true

module Search
  module Elastic
    module VulnerabilityFilters
      class << self
        include ::Elastic::Latest::QueryContext::Aware
        include Search::Elastic::Concerns::FilterUtils

        DISMISSED_STATE = 2
        # owasp 2017 will support both 2017 and 2021 identifiers for
        # backwards compatibility
        OWASP_REGEX_CONSTANTS_BY_YEAR = {
          "2017" => %r{A(0?[1-9]|10):(2017|2021)-.*},
          "2021" => %r{A(0?[1-9]|10):2021-.*}
        }.freeze

        def by_created_at(query_hash:, options:)
          return query_hash unless options[:created_after] && options[:created_before]

          unless options[:created_before] >= options[:created_after]
            raise ArgumentError, 'created_before must be >= created_after'
          end

          created_after = options[:created_after]
          created_before = options[:created_before]
          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              context.name(:range) do
                {
                  range: {
                    created_at: {
                      _name: context.name(:created_at),
                      gte: created_after,
                      lte: created_before
                    }
                  }
                }
              end
            end
          end
        end

        def by_archived_projects(query_hash:, options:)
          raise ArgumentError, 'search_level is a required option' unless options.key?(:search_level)

          search_level = options[:search_level].to_sym
          return query_hash if search_level == :project

          include_archived_projects = !!options[:include_archived_projects]
          return query_hash if include_archived_projects

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { archived: { _name: context.name(:archived_projects), value: false } } }
            end
          end
        end

        def by_cluster_agent_id(query_hash:, options:)
          cluster_agent_id = options[:cluster_agent_id]
          return query_hash if cluster_agent_id.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:cluster_agent_id),
                  cluster_agent_id: cluster_agent_id
                }
              }
            end
          end
        end

        def by_state_and_dismissal_reason(query_hash:, options:)
          dismissal_reason = options[:dismissal_reason]
          state = options[:state]
          return query_hash if dismissal_reason.blank? && state.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              if state.present? && dismissal_reason.present?
                {
                  bool: {
                    _name: context.name(:state_and_dismissal_reason),
                    should: [
                      { terms: { state: state } },
                      {
                        bool: {
                          must: [
                            {
                              terms: { state: [DISMISSED_STATE] }
                            },
                            {
                              terms: { dismissal_reason: dismissal_reason }
                            }
                          ]
                        }
                      }
                    ],
                    minimum_should_match: 1
                  }
                }
              elsif state.present?
                { terms: { _name: context.name(:state), state: state } }
              else
                {
                  bool: {
                    _name: context.name(:dismissal_reason),
                    must: [
                      {
                        terms: { state: [DISMISSED_STATE] }
                      },
                      {
                        terms: { dismissal_reason: dismissal_reason }
                      }
                    ]
                  }
                }
              end
            end
          end
        end

        def by_has_ai_resolution(query_hash:, options:)
          has_ai_resolution = options[:has_ai_resolution]
          return query_hash if has_ai_resolution.nil?
          return query_hash unless has_ai_resolution.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                term: {
                  has_vulnerability_resolution: {
                    _name: context.name(:has_ai_resolution),
                    value: has_ai_resolution
                  }
                }
              }
            end
          end
        end

        def by_has_issues(query_hash:, options:)
          has_issues = options[:has_issues]
          return query_hash if has_issues.nil?
          return query_hash unless has_issues.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { has_issues: { _name: context.name(:has_issues), value: has_issues } } }
            end
          end
        end

        def by_has_merge_request(query_hash:, options:)
          has_merge_request = options[:has_merge_request]
          return query_hash if has_merge_request.nil?
          return query_hash unless has_merge_request.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { has_merge_request: { _name: context.name(:has_merge_request), value: has_merge_request } } }
            end
          end
        end

        def by_has_remediations(query_hash:, options:)
          has_remediations = options[:has_remediations]
          return query_hash if has_remediations.nil?
          return query_hash unless has_remediations.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { has_remediations: { _name: context.name(:has_remediations), value: has_remediations } } }
            end
          end
        end

        def by_has_resolution(query_hash:, options:)
          has_resolution = options[:has_resolution]
          return query_hash if has_resolution.nil?
          return query_hash unless has_resolution.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { resolved_on_default_branch: { _name: context.name(:has_resolution), value: has_resolution } } }
            end
          end
        end

        def by_identifier_names(query_hash:, options:)
          identifier_name = options[:identifier_name]
          return query_hash if identifier_name.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { "identifier_names.keyword": { _name: context.name(:identifier_name),
                                                      value: identifier_name } } }
            end
          end
        end

        def by_partial_identifier_name(query_hash:, options:)
          partial_identifier_name = options[:partial_identifier_name]
          return query_hash if partial_identifier_name.nil?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                bool: {
                  must: {
                    simple_query_string: {
                      _name: context.name(:partial_identifier_name),
                      fields: [
                        "identifier_names",
                        "identifier_names.ngram"
                      ],
                      query: partial_identifier_name,
                      lenient: true,
                      default_operator: :and
                    }
                  }
                }
              }
            end
          end
        end

        def by_image(query_hash:, options:)
          image = options[:image]
          return query_hash if image.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:image),
                  location_image: image
                }
              }
            end
          end
        end

        def by_owasp_top_10_2017(query_hash:, options:)
          by_owasp_top_10(query_hash: query_hash, options: options, year: '2017')
        end

        def by_owasp_top_10_2021(query_hash:, options:)
          by_owasp_top_10(query_hash: query_hash, options: options, year: '2021')
        end

        def by_owasp_top_10(query_hash:, options:, year:)
          param_key = :"owasp_top_10_#{year}"
          owasp_values = options[param_key]
          return query_hash if owasp_values.blank?

          regex_constant = OWASP_REGEX_CONSTANTS_BY_YEAR[year]
          return query_hash unless valid_owasp_values?(owasp_values, regex_constant)

          owasp_keys_for_none_filter = case year
                                       when '2021'
                                         ::Enums::Vulnerability::OWASP_TOP_10_BY_YEAR[year].keys
                                       when '2017'
                                         ::Enums::Vulnerability::OWASP_TOP_10.keys
                                       end

          nested_query = if owasp_none_value?(owasp_values)
                           {
                             must_not: {
                               bool: {
                                 should: owasp_keys_for_none_filter.map do |k|
                                   formatted_key = k.split("-").first
                                   {
                                     prefix: {
                                       "identifier_names.keyword": {
                                         value: formatted_key
                                       }
                                     }
                                   }
                                 end,
                                 minimum_should_match: 1
                               }
                             }
                           }
                         else
                           {
                             must: {
                               bool: {
                                 should: owasp_values.map do |v|
                                   formatted_key = v.split("-").first
                                   {
                                     prefix: {
                                       "identifier_names.keyword": {
                                         value: formatted_key
                                       }
                                     }
                                   }
                                 end,
                                 minimum_should_match: 1
                               }
                             }
                           }
                         end

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                bool: {
                  _name: context.name(param_key),
                  **nested_query
                }
              }
            end
          end
        end

        def by_projects(query_hash:, options:)
          project_id = options[:project_id]
          return query_hash if project_id.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:project_id),
                  project_id: project_id
                }
              }
            end
          end
        end

        def by_report_type(query_hash:, options:)
          report_type = options[:report_type]
          return query_hash if report_type.blank?
          return query_hash unless (report_type - ::Vulnerability.report_types.values).empty?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:report_type),
                  report_type: report_type
                }
              }
            end
          end
        end

        def by_scanner_external_ids(query_hash:, options:)
          scanner_external_id = options[:scanner_external_id]
          return query_hash if scanner_external_id.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:scanner_external_id),
                  scanner_external_id: scanner_external_id
                }
              }
            end
          end
        end

        def by_scanner_ids(query_hash:, options:)
          scanner_id = options[:scanner_id]
          return query_hash if scanner_id.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:scanner_id),
                  scanner_id: scanner_id
                }
              }
            end
          end
        end

        def by_severities(query_hash:, options:)
          severity = options[:severity]
          return query_hash if severity.blank?
          return query_hash unless (severity - ::Vulnerability.severities.values).empty?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:severity),
                  severity: severity
                }
              }
            end
          end
        end

        def by_reachability(query_hash:, options:)
          reachability = options[:reachability]
          return query_hash if reachability.blank?
          return query_hash unless reachability.to_set.subset?(::Sbom::Occurrence.reachabilities.values.to_set)

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:reachability),
                  reachability: reachability
                }
              }
            end
          end
        end

        private

        def valid_owasp_values?(owasp_values, regex_constant)
          owasp_none_value?(owasp_values) || owasp_values.all? do |v|
            regex_constant.match?(v)
          end
        end

        def owasp_none_value?(owasp_values)
          owasp_values&.join&.casecmp("none") == 0
        end
      end
    end
  end
end
