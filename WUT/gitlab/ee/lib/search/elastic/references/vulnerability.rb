# frozen_string_literal: true

module Search
  module Elastic
    module References
      class Vulnerability < Reference
        include Search::Elastic::Concerns::DatabaseReference
        include ::Gitlab::Utils::StrongMemoize

        SCHEMA_VERSION = 25_26
        DOC_TYPE = 'vulnerability'
        INDEX_NAME = 'vulnerabilities'

        DIRECT_FIELDS = %w[
          vulnerability_id project_id scanner_id uuid location_image
          cluster_agent_id casted_cluster_agent_id has_issues
          resolved_on_default_branch has_merge_request
          has_remediations archived has_vulnerability_resolution auto_resolved
          identifier_names
        ].freeze

        DIRECT_TYPECAST_FIELDS = %w[report_type severity state dismissal_reason].freeze

        DEFAULT_SOURCE_FIELDS = %w[vulnerability_id].freeze

        # Create a new reference string from a vulnerability record
        override :serialize
        def self.serialize(record)
          new(record.vulnerability_id, record.es_parent).serialize
        end

        # Parse a reference string into a new instance
        override :instantiate
        def self.instantiate(string)
          _, id, routing = delimit(string)
          new(id, routing)
        end

        # Efficiently preload data for a batch of references to avoid N+1 queries
        override :preload_indexing_data
        def self.preload_indexing_data(refs)
          ids = refs.map(&:identifier)
          records = model_klass.preload_indexing_data.by_vulnerabilities(ids)

          ::Search::Elastic::Preloaders::Vulnerability::EnhancedProxy.new(refs, records).preload_and_enhance!

          preload_epss_scores(refs, records)

          refs
        end

        def self.index
          environment_specific_index_name(INDEX_NAME)
        end

        def self.model_klass
          ::Vulnerabilities::Read
        end

        attr_reader :identifier, :routing

        def initialize(identifier, routing)
          @identifier = identifier.to_i
          @routing = routing
        end

        # Convert this reference to a string
        override :serialize
        def serialize
          self.class.join_delimited([klass, identifier, routing].compact)
        end

        # Generate the JSON representation for elasticsearch indexing
        override :as_indexed_json
        def as_indexed_json
          fields = {}

          DIRECT_FIELDS.each { |field| fields[field] = database_record.read_attribute(field) }

          DIRECT_TYPECAST_FIELDS.each do |field|
            fields[field] = database_record.method(:"#{field}_before_type_cast").call
          end

          # Add other fields
          fields["scanner_external_id"] = database_record.scanner&.external_id
          fields["created_at"] = database_record.vulnerability.created_at
          fields["updated_at"] = database_record.vulnerability.updated_at
          fields["traversal_ids"] = database_record.project.namespace.elastic_namespace_ancestry
          fields["epss_scores"] = fetch_record_attribute(database_record, :epss_scores)

          if reachability_migration_finished?
            fields["reachability"] = fetch_record_attribute(database_record, :reachability)
          end

          internal_es_fields.merge(fields)
        end

        override :index_name
        def index_name
          self.class.index
        end

        # Get the actual vulnerability record from the database
        # The primary key is `vulnerability_id` and in the original method we are using `find_by_id`
        override :database_record
        def database_record
          model_klass.find_by(vulnerability_id: identifier) # rubocop: disable CodeReuse/ActiveRecord -- One off case.
        end
        strong_memoize_attr :database_record

        private

        def fetch_record_attribute(record, attribute)
          return record.method(attribute).call if record.respond_to?(attribute)

          # Fallback for records not processed through our preloading
          []
        end

        # Get the model class for database operations
        def model_klass
          self.class.model_klass
        end

        def internal_es_fields
          {
            schema_version: fetch_schema_version,
            type: DOC_TYPE
          }
        end

        def fetch_schema_version
          if reachability_migration_finished?
            SCHEMA_VERSION
          else
            25_25 # Previous stable version until migration completes
          end
        end

        def reachability_migration_finished?
          ::Elastic::DataMigrationService.migration_has_finished?(
            :add_rechability_field_to_vulnerability)
        end

        #
        # Private class methods for implementation details
        #

        class << self
          private

          # TODO: Move this logic to ::Search::Elastic::Preloaders::Vulnerability::EnhancedProxy
          def preload_epss_scores(refs, records)
            records_array = Array(records)

            records_by_id = records_array.index_by(&:vulnerability_id)

            cve_map = extract_cve_values(records_array)
            enrichments_by_cve = preload_cve_enrichments(cve_map.values)

            assign_epss_scores_to_records(refs, records_by_id, cve_map, enrichments_by_cve)
          end

          # Extract CVE values from records in a single pass to avoid N+1 queries
          def extract_cve_values(records)
            cve_map = {}
            records.each do |record|
              cve = record.cve_value
              cve_map[record.id] = cve if cve.present?
            end
            cve_map
          end

          # Preload all CVE enrichments in a single query
          def preload_cve_enrichments(cve_values)
            unique_cves = cve_values.uniq
            return {} if unique_cves.empty?

            cve_enrichments = ::PackageMetadata::CveEnrichment.by_cves(unique_cves)
            cve_enrichments.group_by(&:cve)
          end

          # Assign epss_scores to records from the preloaded cve enrichments
          def assign_epss_scores_to_records(refs, records_by_id, cve_map, enrichments_by_cve)
            refs.each do |ref|
              record = records_by_id[ref.identifier]
              next unless record

              cve = cve_map[record.id]
              enrichments = enrichments_by_cve[cve] || []

              if ref.database_record.present?
                ref.database_record.enhance_with_data({ epss_scores: enrichments.map(&:epss_score) })
              end
            end
          end
        end
      end
    end
  end
end
