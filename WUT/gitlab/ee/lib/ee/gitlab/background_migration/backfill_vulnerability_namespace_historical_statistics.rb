# frozen_string_literal: true

module EE
  module Gitlab
    module BackgroundMigration
      module BackfillVulnerabilityNamespaceHistoricalStatistics
        extend ActiveSupport::Concern
        extend ::Gitlab::Utils::Override

        class Namespace < ::Gitlab::Database::Migration[2.2]::MigrationRecord
          self.table_name = 'namespaces'
        end

        class Project < ::Gitlab::Database::Migration[2.2]::MigrationRecord
          self.table_name = 'projects'
          belongs_to :namespace
          scope :joins_namespace, -> { joins(:namespace) }
          # rubocop: disable CodeReuse/ActiveRecord -- redefining to avoid using application code in migration
          scope :namespace_and_traversal_ids, ->(project_ids) {
            where(id: project_ids).joins_namespace.limit(project_ids.length)
              .pluck(:id, :namespace_id, :traversal_ids)
          }
          # rubocop: enable CodeReuse/ActiveRecord
        end

        prepended do
          operation_name :fill_vulnerability_namespace_historical_statistics
          feature_category :vulnerability_management
        end

        override :perform

        def perform
          each_sub_batch do |sub_batch|
            # rubocop:disable CodeReuse/ActiveRecord -- specific for this backfill
            historical_statistics_ids = sub_batch.pluck(:id).map { |id| Integer(id) }.join(', ')
            affected_project_ids = sub_batch.pluck(:project_id)
            # rubocop:enable CodeReuse/ActiveRecord
            project_to_namespace_traversal_ids = project_to_namespace_traversal_ids(affected_project_ids)

            next if project_to_namespace_traversal_ids.blank?

            ::SecApplicationRecord.connection.execute(upsert_sql(historical_statistics_ids,
              project_to_namespace_traversal_ids))
          end
        end

        STATS_SQL = <<~SQL
        WITH project_to_namespace_traversal_ids (project_id, namespace_id, traversal_ids) AS (
            %{with_values}
        )
          SELECT
            SUM(total) AS total,
            SUM(info) AS info,
            SUM(unknown) AS unknown,
            SUM(low) AS low,
            SUM(medium) AS medium,
            SUM(high) AS high,
            SUM(critical) AS critical,
            MAX(letter_grade) AS letter_grade,
            project_to_namespace_traversal_ids.traversal_ids as traversal_ids,
            project_to_namespace_traversal_ids.namespace_id as namespace_id,
            date as date,
            MIN(vulnerability_historical_statistics.created_at) AS created_at,
            MAX(vulnerability_historical_statistics.updated_at) AS updated_at,
            true as migrating
          FROM vulnerability_historical_statistics
          INNER JOIN project_to_namespace_traversal_ids ON project_to_namespace_traversal_ids.project_id = vulnerability_historical_statistics.project_id
          WHERE vulnerability_historical_statistics.id IN (%{historical_statistics_ids})
          GROUP BY traversal_ids, namespace_id, date
        SQL

        UPSERT_SQL = <<~SQL
          INSERT INTO vulnerability_namespace_historical_statistics
            (total, info, unknown, low, medium, high, critical, letter_grade, traversal_ids, namespace_id, date, created_at, updated_at, migrating)
            (%{stats_sql})
          ON CONFLICT (traversal_ids, date)
          DO UPDATE SET
            migrating = true,
            total = CASE WHEN vulnerability_namespace_historical_statistics.migrating IS FALSE THEN EXCLUDED.total
              ELSE vulnerability_namespace_historical_statistics.total + EXCLUDED.total
              END,
            info = CASE WHEN vulnerability_namespace_historical_statistics.migrating IS FALSE THEN EXCLUDED.info
              ELSE vulnerability_namespace_historical_statistics.info + EXCLUDED.info
              END,
            unknown = CASE WHEN vulnerability_namespace_historical_statistics.migrating IS FALSE THEN EXCLUDED.unknown
              ELSE vulnerability_namespace_historical_statistics.unknown + EXCLUDED.unknown
              END,
            low = CASE WHEN vulnerability_namespace_historical_statistics.migrating IS FALSE THEN EXCLUDED.low
              ELSE vulnerability_namespace_historical_statistics.low + EXCLUDED.low
              END,
            medium = CASE WHEN vulnerability_namespace_historical_statistics.migrating IS FALSE THEN EXCLUDED.medium
              ELSE vulnerability_namespace_historical_statistics.medium + EXCLUDED.medium
              END,
            high = CASE WHEN vulnerability_namespace_historical_statistics.migrating IS FALSE THEN EXCLUDED.high
              ELSE vulnerability_namespace_historical_statistics.high + EXCLUDED.high
              END,
            critical = CASE WHEN vulnerability_namespace_historical_statistics.migrating IS FALSE THEN EXCLUDED.critical
              ELSE vulnerability_namespace_historical_statistics.critical + EXCLUDED.critical
              END,
            letter_grade = CASE WHEN vulnerability_namespace_historical_statistics.migrating IS FALSE THEN EXCLUDED.letter_grade
              ELSE GREATEST(vulnerability_namespace_historical_statistics.letter_grade, EXCLUDED.letter_grade)
              END,
            updated_at = CASE WHEN vulnerability_namespace_historical_statistics.migrating IS FALSE THEN EXCLUDED.updated_at
              ELSE EXCLUDED.updated_at
              END
        SQL

        def stats_sql(historical_statistics_ids, with_project_information)
          format(STATS_SQL, historical_statistics_ids: historical_statistics_ids,
            with_values: with_project_information)
        end

        def upsert_sql(historical_statistics_ids, with_project_information)
          format(UPSERT_SQL, stats_sql: stats_sql(historical_statistics_ids, with_project_information))
        end

        def project_to_namespace_traversal_ids(project_ids)
          # Query main DB for namespace and traversal_ids for affected projects by id
          project_info = Project.namespace_and_traversal_ids(project_ids)
          return if project_info.blank?

          values = project_info.map do |row|
            [
              row[0],
              row[1],
              Arel.sql("ARRAY#{row[2]}::bigint[]")
            ]
          end

          Arel::Nodes::ValuesList.new(values).to_sql
        end
      end
    end
  end
end
