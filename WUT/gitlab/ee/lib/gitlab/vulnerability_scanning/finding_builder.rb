# frozen_string_literal: true

module Gitlab
  module VulnerabilityScanning
    class FindingBuilder
      ERROR_SBOM_MISSING_PIPELINE = 'SBOM occurrence must have a pipeline.'
      ERROR_SBOM_MISSING_SOURCE_ARG = 'Missing SBOM source argument.'
      ERROR_PIPELINE_USER_NIL = 'Pipeline must have a corresponding user to use as vulnerability author.'
      UNKNOWN_VENDOR = 'Unknown'

      Error = Class.new(StandardError)
      ArgumentError = Class.new(Error)
      MissingPropertiesError = Class.new(Error)

      include Gitlab::Utils::StrongMemoize

      def self.for_report_type(report_type)
        case report_type.to_s
        when "dependency_scanning"
          ::Gitlab::VulnerabilityScanning::DependencyScanning::FindingBuilder
        when "container_scanning", "container_scanning_for_registry"
          ::Gitlab::VulnerabilityScanning::ContainerScanning::FindingBuilder
        end
      end

      # .for_purl_type will return a builder for the given purl type if it exists.
      def self.for_purl_type(purl_type)
        if Enums::Sbom.dependency_scanning_purl_type?(purl_type)
          ::Gitlab::VulnerabilityScanning::DependencyScanning::FindingBuilder
        elsif Enums::Sbom.container_scanning_purl_type?(purl_type)
          ::Gitlab::VulnerabilityScanning::ContainerScanning::FindingBuilder
        end
      end

      # .for_purl_type! is exactly like .for_purl_type but will raise an error
      # if a builder does not exist for the purl type.
      def self.for_purl_type!(purl_type)
        builder_class = for_purl_type(purl_type)

        if builder_class.blank?
          Gitlab::ErrorTracking.track_and_raise_exception(
            StandardError.new(
              "No finding builder found for component"),
            purl_type: purl_type
          )
        end

        builder_class
      end

      def initialize(project:, pipeline:, sbom_source:, scanner:, advisory:, affected_component:)
        @project = project
        @pipeline = pipeline
        @sbom_source = sbom_source
        @scanner = scanner
        @advisory = advisory
        @affected_component = affected_component
      end

      def finding
        validate!

        ::Gitlab::Ci::Reports::Security::Finding.new(
          uuid: uuid,
          report_type: report_type,
          name: title,
          location: location,
          evidence: nil,
          severity: ::Enums::Vulnerability.parse_severity_level(severity),
          confidence: 'unknown',
          scanner: scanner,
          scan: nil,
          identifiers: identifiers,
          links: links,
          cvss: cvss_vectors_with_vendor,
          original_data: original_data,
          metadata_version: metadata_version,
          details: details,
          project_id: project.id,
          found_by_pipeline: pipeline)
      end
      strong_memoize_attr :finding

      private

      attr_reader :project, :pipeline, :sbom_source, :scanner, :advisory, :affected_component

      def validate!
        raise ArgumentError, ERROR_SBOM_MISSING_SOURCE_ARG if sbom_source.nil?
        raise ArgumentError, ERROR_SBOM_MISSING_PIPELINE if pipeline.nil?

        return unless pipeline.user.nil?

        raise ArgumentError, ERROR_PIPELINE_USER_NIL
      end

      def report_type
        raise NoMethodError, "#{self.class}#report_type is not implemented"
      end

      def uuid
        uuid_v5_name_components = {
          report_type: report_type,
          primary_identifier_fingerprint: primary_identifier&.fingerprint,
          location_fingerprint: location_fingerprint,
          project_id: project.id
        }

        # Inline the comparison to squeeze out some performance
        if primary_identifier&.fingerprint.nil? ||
            location_fingerprint.nil?
          Gitlab::AppJsonLogger.warn(message: "One or more UUID name components are nil",
            components: uuid_v5_name_components)
          return
        end

        ::Security::VulnerabilityUUID.generate(
          report_type: uuid_v5_name_components[:report_type],
          primary_identifier_fingerprint: uuid_v5_name_components[:primary_identifier_fingerprint],
          location_fingerprint: uuid_v5_name_components[:location_fingerprint],
          project_id: uuid_v5_name_components[:project_id]
        )
      end

      def primary_identifier
        identifiers.first
      end

      def location_fingerprint
        location&.fingerprint
      end

      def identifiers
        advisory.identifiers.map do |identifier|
          ::Gitlab::Ci::Reports::Security::Identifier.new(
            external_type: identifier['type'],
            external_id: identifier['value'],
            name: identifier['name'],
            url: identifier['url'])
        end
      end
      strong_memoize_attr :identifiers

      def title
        identifier = identifiers.find(&:cve?) || identifiers.find(&:cwe?) || identifiers.first

        if location&.fingerprint_path
          "#{identifier.name} in #{location.fingerprint_path}"
        else
          identifier.name.to_s
        end
      end
      strong_memoize_attr :title

      def default_title(affected_location:)
        "#{affected_component.name} in #{affected_location} is vulnerable " \
          "to #{advisory.identifiers.first['name']}".freeze
      end

      def links
        advisory.urls.map { |url| ::Gitlab::Ci::Reports::Security::Link.new(name: nil, url: url) }
      end

      def cvss_vectors_with_vendor
        [advisory.cvss_v3, advisory.cvss_v2].compact.map do |cvss|
          {
            'vendor' => vendor_from_identifiers,
            'vector' => cvss.vector
          }
        end
      end

      def vendor_from_identifiers
        identifier = identifiers.find { |identifier| identifier.vendor != UNKNOWN_VENDOR }

        identifier&.vendor || UNKNOWN_VENDOR
      end
      strong_memoize_attr :vendor_from_identifiers

      def severity
        advisory.cvss_v3&.severity&.downcase || advisory.cvss_v2&.severity&.downcase
      end
      strong_memoize_attr :severity

      def details
        {}
      end

      def location
        raise NoMethodError, "#{self.class}#location is not implemented"
      end

      def original_data
        raise NoMethodError, "#{self.class}#original_data is not implemented"
      end

      def metadata_version
        "0.0.0"
      end
      strong_memoize_attr :metadata_version
    end
  end
end
