# frozen_string_literal: true

module Gitlab
  module VulnerabilityScanning
    module ContainerScanning
      class FindingBuilder < VulnerabilityScanning::FindingBuilder
        include Gitlab::Utils::StrongMemoize

        EXPIRATION_TIME = 5.minutes

        private

        def validate!
          super

          return unless sbom_source.image_name.nil? || sbom_source.image_tag.nil?

          raise Gitlab::VulnerabilityScanning::FindingBuilder::MissingPropertiesError,
            'Missing required gitlab:container_scanning CycloneDX properties'
        end

        def report_type
          sbom_source.source_type&.to_s
        end

        def title
          advisory.title.presence || default_title(affected_location: operating_system_name_and_version)
        end
        strong_memoize_attr :title

        def details
          {
            vulnerable_package: {
              name: "Vulnerable Package",
              type: "text",
              value: "#{affected_component.name}:#{affected_component.version}"
            }
          }.with_indifferent_access.freeze
        end

        def image_and_tag
          "#{sbom_source.image_name}:#{sbom_source.image_tag}"
        end
        strong_memoize_attr :image_and_tag

        def operating_system_name_and_version
          "#{sbom_source.operating_system_name} #{sbom_source.operating_system_version}"
        end
        strong_memoize_attr :operating_system_name_and_version

        def location
          ::Gitlab::Ci::Reports::Security::Locations::ContainerScanning.new(
            image: image_and_tag,
            operating_system: operating_system_name_and_version,
            package_name: affected_component.name,
            package_version: affected_component.version
          )
        end
        strong_memoize_attr :location

        def original_data
          data = {
            message: title,
            description: advisory.description,
            solution: advisory.solution,
            location: {
              image: image_and_tag,
              operating_system: operating_system_name_and_version,
              dependency: {
                package: { name: affected_component.name },
                version: affected_component.version
              }
            }
          }

          data[:location][:container_repository_url] = container_repository_url if container_repository_url
          data.with_indifferent_access.freeze
        end

        def container_repository_url
          cache_key = ["container_repository_url", project.id, sbom_source.image_name]

          Rails.cache.fetch(cache_key, expires_in: EXPIRATION_TIME) do
            fetch_repository_url
          end
        end
        strong_memoize_attr :container_repository_url

        def fetch_repository_url
          host_port, path = sbom_source.image_name.split('/', 2)
          return unless valid_host_port?(host_port)

          container_repository_id = find_container_repository_id(path)
          build_registry_url(container_repository_id) if container_repository_id
        end

        # In staging or production environments, `Gitlab.config.registry.host_port` does not return the port,
        # whereas it does provide the port in local environments, making it ideal for this use case.
        def valid_host_port?(host_port)
          host_port == Gitlab.config.registry.host_port
        end

        def find_container_repository_id(path)
          container_path = ContainerRegistry::Path.new(path, project: project)
          return unless container_path.valid?

          ::ContainerRepository.find_by_path(container_path)&.id
        end

        def build_registry_url(container_repository_id)
          Rails.application.routes.url_helpers.project_container_registry_url(project, container_repository_id)
        end
      end
    end
  end
end
