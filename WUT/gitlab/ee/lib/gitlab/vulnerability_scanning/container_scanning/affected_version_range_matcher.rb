# frozen_string_literal: true

module Gitlab
  module VulnerabilityScanning
    module ContainerScanning
      class AffectedVersionRangeMatcher
        include Gitlab::Utils::StrongMemoize

        attr_reader :purl_type, :range

        def initialize(purl_type:, range:)
          @purl_type = purl_type
          @range = range
        end

        def affected?(distro, source, version_string)
          return false unless distro_matches?(distro, source)

          # a wildcard range means that all versions are affected
          return true if range == '*'

          version_from_string(version_string) < upper_bound
        end

        private

        # if a given version of ubuntu does not belong to this set, we can still determine vulnerabilities for it,
        # however, we can perform _more accurate_ lookups in the case of `-ESM` versions if we keep this list
        # up-to-date.
        #
        # This list is taken from https://github.com/aquasecurity/trivy/blob/05df24477/pkg/detector/ospkg/ubuntu/ubuntu.go#L20-63
        UBUNTU_VERSIONS = Set.new([
          '4.10', '5.04', '5.10', '6.06', '6.10', '7.04', '7.10', '8.04', '8.10', '9.04', '9.10', '10.04',
          '10.10', '11.04', '11.10', '12.04', '12.04-ESM', '12.10', '13.04', '13.10', '14.04', '14.04-ESM',
          '14.10', '15.04', '15.10', '16.04', '16.04-ESM', '16.10', '17.04', '17.10', '18.04', '18.04-ESM',
          '18.10', '19.04', '19.10', '20.04', '20.10', '21.04', '21.10', '22.04', '22.10', '23.04'
        ]).freeze

        def distro_matches?(distro, source)
          distro_name, distro_version = name_and_version_for(distro)

          distro_name == source&.operating_system_name &&
            distro_version == sanitize_operating_system_version(source&.operating_system_version,
              source&.operating_system_name)
        end

        # Sanitize the operating system version provided in the SBOM, to a trivy-db bucket version.
        #
        # See https://gitlab.com/gitlab-org/gitlab/-/issues/427953#operating-system-version-sanitizing-logic
        # for the logic behind the following method.
        #
        # @param version [String] The original version string to be sanitized.
        # @param os_name [String] The name of the operating system for which the version is being sanitized.
        #
        # @return [String] The sanitized version string.
        #
        # @example
        #   sanitize_operating_system_version("9.4", "alma")
        #   # => "9"
        #
        #   sanitize_operating_system_version("3.19_alpha20230901", "alpine")
        #   # => "edge"
        #
        #   sanitize_operating_system_version("Amazon Linux 2 (Karoo)", "amazon linux")
        #   # => "2"
        def sanitize_operating_system_version(version, os_name)
          case os_name
          when 'CBL-Mariner'
            minor(version)
          when 'alma', 'debian', 'rocky', 'Oracle Linux'
            major(version)
          when 'Red Hat', 'wolfi'
            ''
          when 'alpine'
            # The logic used by trivy to detect the edge version is much more complicated and involves parsing the
            # /etc/apk/repositories file on the Docker container (https://github.com/aquasecurity/trivy/blob/05df24477/pkg/fanal/analyzer/repo/apk/apk.go#L26-26).
            # Since we don't have access to the Docker container, we use a simple heuristic to convert versions
            # such as `3.19_alpha20230901` to `edge`. This might produce inaccurate results.
            return 'edge' if version.include?('_')

            minor(version)
          when 'amazon linux'
            # see https://github.com/aquasecurity/trivy/blob/05df24477/pkg/detector/ospkg/amazon/amazon.go#L67-L70
            amazon_version = version.split(' ')[0]

            return '1' unless %w[2 2022 2023].include?(amazon_version)

            amazon_version
          when 'ubuntu'
            # If the given version of ubuntu is included in the UBUNTU_VERSIONS set, then we return the version as-is.
            # Example: 19.10 -> 19.10.
            #
            # If the given version is _not_ included in the set, then we strip the `-ESM` suffix and check if a version
            # exists in the UBUNTU_VERSIONS _without_ this suffix, and if so, we return the version without the `-ESM`
            # suffix. Example: 19.04-ESM -> 19.04.
            #
            # Finally, if the given version doesn't match any entries in the UBUNTU_VERSIONS set, we return the version
            # as-is. Example: 19.123 -> 19.123 or 19.15-ESM -> 19.15-ESM.
            #
            # see https://github.com/aquasecurity/trivy/blob/05df24477/pkg/detector/ospkg/ubuntu/ubuntu.go#L156-172
            [version, version.delete_suffix('-ESM')].each do |ver|
              return ver if UBUNTU_VERSIONS.include?(ver)
            end

            version
          else
            # return the version as-is for 'SUSE Linux Enterprise', 'openSUSE Leap', 'Photon OS'
            version
          end
        end

        # Extract the distro name and version from the distro string (aka a trivy-db bucket name)
        #
        # @param distro [String] The distribution information to be parsed.
        # @return [Array<String>] An array containing the distribution name and version.
        #
        # @example
        #   name_and_version_for("Ubuntu 20.04")
        #   # => ["Ubuntu", "20.04"]
        #
        #   name_and_version_for("SUSE Linux Enterprise 15.1")
        #   # => ["SUSE Linux Enterprise", "15.1"]
        #
        #   name_and_version_for("Red Hat")
        #   # => ["Red Hat", ""]
        #
        #   name_and_version_for("wolfi")
        #   # => ["wolfi", ""]
        #
        # @note This method assumes that the distribution information follows the common
        #   convention of having the distribution name followed by the version separated by a space.
        #
        def name_and_version_for(distro)
          # Red Hat and wolfi do not have version values
          return [distro, ''] if ['Red Hat', 'wolfi'].include?(distro)

          distro_name_and_version = distro.rpartition(' ')
          distro_name = distro_name_and_version.first
          distro_version = distro_name_and_version.last
          [distro_name, distro_version]
        end

        # returns the major version
        # Example: 9.4 -> 9
        def major(os_ver)
          os_ver.split('.')[0]
        end

        # returns the major and minor version
        # e.g. 3.17.1 => 3.17
        def minor(os_ver)
          major, minor = os_ver.split('.')

          return os_ver unless minor

          "#{major}.#{minor}"
        end

        def version_from_string(version)
          strong_memoize_with(:version_from_string, version) do
            SemverDialects.parse_version(purl_type, version)
          end
        end

        def upper_bound
          # we only support the less than operator, because that's the only one currently output
          # by the advisory exporter for operating system packages.
          raise SemverDialects::InvalidConstraintError, range unless range[0] == '<'

          # Remove the leading operator from the version range string
          SemverDialects.parse_version(purl_type, range[1..])
        end
        strong_memoize_attr :upper_bound
      end
    end
  end
end
