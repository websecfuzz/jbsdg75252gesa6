# frozen_string_literal: true

module Gitlab
  module VulnerabilityScanning
    module AdvisoryUtils
      include Gitlab::Utils::StrongMemoize

      def occurrence_is_affected?(purl_type:, range:, version:, distro:, source:, project_id:, xid:, source_xid:)
        matcher = build_matcher(purl_type: purl_type, range: range)
        if Enums::Sbom.container_scanning_purl_type?(purl_type)
          matcher.affected?(distro, source, version)
        else
          matcher.affected?(version)
        end
      rescue SemverDialects::Error => error
        track_indetermined_if_occurence_is_affected(error: error, purl_type: purl_type, version: version,
          project_id: project_id, xid: xid, source_xid: source_xid)
        raise
      end

      def build_matcher(purl_type:, range:)
        strong_memoize_with(:build_matcher, purl_type, range) do
          if Enums::Sbom.container_scanning_purl_type?(purl_type)
            Gitlab::VulnerabilityScanning::ContainerScanning::AffectedVersionRangeMatcher.new(
              purl_type: purl_type, range: range)
          else
            Gitlab::VulnerabilityScanning::DependencyScanning::AffectedVersionRangeMatcher.new(
              purl_type: purl_type, range: range)
          end
        end
      end

      def track_indetermined_if_occurence_is_affected(error:, purl_type:, version:, project_id:, xid:, source_xid:)
        # OPS flag to avoid flooding sentry
        return unless Feature.enabled?(:track_semver_dialect_errors_for_cvs_in_sentry, :instance)

        ::Gitlab::ErrorTracking.track_exception(
          error,
          message: 'Cannot determine if component is affected',
          purl_type: purl_type,
          version: version,
          project_id: project_id,
          advisory_xid: xid,
          source_xid: source_xid)
      end

      def create_vulnerabilities(findings)
        response = ::Security::VulnerabilityScanning::CreateVulnerabilityService.execute(
          findings)

        project_ids_with_upsert = response.payload[:project_ids_with_upsert]

        if response.success?
          log_success(project_ids_with_upsert: project_ids_with_upsert)
        else
          log_error(response.payload[:error], project_ids_with_upsert: project_ids_with_upsert)
        end

        response.payload[:vulnerability_ids] || []
      end

      def log_success(project_ids_with_upsert:)
        Gitlab::AppJsonLogger.debug(message: "Successfully created vulnerabilities on advisory ingestion",
          project_ids_with_upsert: project_ids_with_upsert)
      end

      def log_error(error, project_ids_with_upsert:)
        Gitlab::AppJsonLogger.error(message: "Failed to create vulnerabilities on advisory ingestion", error: error,
          project_ids_with_upsert: project_ids_with_upsert)
      end
    end
  end
end
