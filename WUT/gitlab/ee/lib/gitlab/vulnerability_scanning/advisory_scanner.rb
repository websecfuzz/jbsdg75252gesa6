# frozen_string_literal: true

module Gitlab
  module VulnerabilityScanning
    class AdvisoryScanner
      include Gitlab::Utils::StrongMemoize
      include Gitlab::VulnerabilityScanning::AdvisoryUtils

      # Scans eligible projects that contain software components affected
      # by an advisory. If affected, it creates new vulnerabilities in the
      # project.
      #
      # @param advisory [PackageMetadata::Advisory] advisory
      def self.scan_projects_for(advisory)
        new(advisory).execute
      end

      # Create a new advisory scanner instance.
      #
      # @param advisory [PackageMetadata::Advisory] advisory
      #
      # @return [Gitlab::VulnerabilityScanning::AdvisoryScanner]
      def initialize(advisory)
        @advisory = advisory
        @possibly_affected_sbom_occurrences_count = 0
        @known_affected_sbom_occurrences_count = 0
        @sbom_occurrences_semver_dialects_errors_count = 0
        @possibly_affected_projects = {}
        @known_affected_projects = {}
      end

      def execute
        start_time = current_time

        affected_packages.each do |affected_package|
          advisory_data_object = Gitlab::VulnerabilityScanning::Advisory.from_affected_package(
            affected_package: affected_package, advisory: advisory)
          purl_type = affected_package.purl_type
          package_name = affected_package.package_name
          ::Sbom::PossiblyAffectedOccurrencesFinder.new(
            purl_type: purl_type,
            package_name: package_name
          ).execute_in_batches do |batch|
            bulk_vulnerability_ingestion(affected_package, advisory_data_object, batch)
          end
        end

        Gitlab::VulnerabilityScanning::TrackCvsService.new(
          advisory: advisory,
          start_time: start_time,
          end_time: current_time,
          counts: {
            possibly_affected_projects: possibly_affected_projects_count,
            known_affected_projects: known_affected_projects_count,
            possibly_affected_sbom_occurrences: possibly_affected_sbom_occurrences_count,
            known_affected_sbom_occurrences: known_affected_sbom_occurrences_count,
            sbom_occurrences_semver_dialects_errors_count: sbom_occurrences_semver_dialects_errors_count
          }
        ).execute
      end

      private

      SUPPORTED_CONTAINER_SCANNING_PURL_TYPES = %w[deb rpm apk].freeze

      attr_reader :advisory, :possibly_affected_sbom_occurrences_count, :known_affected_sbom_occurrences_count,
        :sbom_occurrences_semver_dialects_errors_count

      def affected_packages
        if advisory.from_container_scanning?
          return advisory.affected_packages.filter do |affected_package|
            SUPPORTED_CONTAINER_SCANNING_PURL_TYPES.include?(affected_package.purl_type)
          end
        end

        advisory.affected_packages
      end
      strong_memoize_attr :affected_packages

      def bulk_vulnerability_ingestion(affected_package, advisory_data_object, occurrences_batch)
        # Ensure project still exists for matching occurrences
        valid_occurrences = occurrences_batch.reject { |o| o.project.nil? }

        finding_maps = valid_occurrences.filter_map do |occurrence|
          count_possibly_affected_sbom_occurrence(occurrence)

          next unless affected_occurrence?(occurrence, affected_package, advisory_data_object)

          count_known_affected_sbom_occurrence(occurrence)

          affected_component = Gitlab::VulnerabilityScanning::PossiblyAffectedComponent
            .from_sbom_occurrence(occurrence)

          ::Security::VulnerabilityScanning::BuildFindingMapService.execute(
            advisory: advisory_data_object,
            affected_component: affected_component,
            source: affected_component.source,
            pipeline: affected_component.pipeline,
            project: affected_component.project,
            purl_type: affected_component.purl_type,
            scanner: scanner)
        end.compact

        return if finding_maps.empty?

        create_vulnerabilities(finding_maps)
      end

      def affected_occurrence?(occurrence, affected_package, advisory_data_object)
        occurrence_is_affected?(
          xid: advisory_data_object.xid,
          purl_type: affected_package.purl_type,
          range: affected_package.affected_range,
          version: occurrence.version,
          distro: affected_package.distro_version,
          source: occurrence.source,
          project_id: occurrence.project_id,
          source_xid: advisory_data_object.source_xid
        )
      rescue SemverDialects::Error
        @sbom_occurrences_semver_dialects_errors_count += 1
        false
      end

      def count_possibly_affected_sbom_occurrence(occurrence)
        @possibly_affected_sbom_occurrences_count += 1
        @possibly_affected_projects[occurrence.project.id] = true
      end

      def count_known_affected_sbom_occurrence(occurrence)
        @known_affected_sbom_occurrences_count += 1
        @known_affected_projects[occurrence.project.id] = true
      end

      def possibly_affected_projects_count
        @possibly_affected_projects.keys.size
      end

      def known_affected_projects_count
        @known_affected_projects.keys.size
      end

      def scanner
        ::Gitlab::VulnerabilityScanning::SecurityScanner.fabricate
      end
      strong_memoize_attr :scanner

      def current_time
        # WARNING: The .utc method is called here to normalize the format.
        # It's possible that someone may configure the timezone for a GitLab
        # installation. In such cases, Time.current.iso8601 will return
        # a string with a timezone that will not pass the Snowplow event schema.
        # See https://gitlab.com/gitlab-data/analytics/-/issues/23964#note_2528947112
        Time.current.utc.iso8601
      end
    end
  end
end
