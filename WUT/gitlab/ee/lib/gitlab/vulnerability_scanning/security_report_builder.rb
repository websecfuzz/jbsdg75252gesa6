# frozen_string_literal: true

module Gitlab
  module VulnerabilityScanning
    class SecurityReportBuilder
      include Gitlab::Utils::StrongMemoize
      include Gitlab::VulnerabilityScanning::AdvisoryUtils

      SECURITY_REPORT_VERSION = "0.0.0"

      def initialize(project:, pipeline:, sbom_reports:)
        @project = project
        @pipeline = pipeline
        @sbom_reports = sbom_reports
        @report = ::Gitlab::Ci::Reports::Security::Report.new(:dependency_scanning, pipeline, Time.zone.now)
        report.version = SECURITY_REPORT_VERSION
        report.scanner = scanner
      end

      def execute
        return unless filtered_sbom_reports.present?

        scan_sbom_report_occurrences

        report
      end
      strong_memoize_attr :execute # This is an expensive method to call, so we memoize it.

      private

      attr_reader :sbom_reports, :project, :pipeline, :report

      def scanner
        VulnerabilityScanning::SecurityScanner.fabricate
      end
      strong_memoize_attr :scanner

      def should_execute?(sbom_report)
        sbom_report_valid?(sbom_report) &&
          supported_source_type?(sbom_report) &&
          supported_dependency_scanning_sbom?(sbom_report)
      end

      def sbom_report_valid?(sbom_report)
        sbom_report.valid? && source_type_present?(sbom_report)
      end

      def supported_source_type?(sbom_report)
        sbom_report.source&.source_type == :dependency_scanning
      end

      def source_type_present?(sbom_report)
        sbom_report.source&.source_type
      end

      def supported_dependency_scanning_sbom?(sbom_report)
        sbom_report.source&.input_file_path.present? || sbom_report.source&.source_file_path.present?
      end

      def filtered_sbom_reports
        sbom_reports.reports.select { |report| should_execute?(report) }
      end
      strong_memoize_attr :filtered_sbom_reports

      def scan_sbom_report_occurrences
        filtered_sbom_reports.each do |sbom_report|
          sbom_report.components.each_slice(::Security::IngestionConstants::COMPONENTS_BATCH_SIZE) do |occurrence_batch|
            affected_packages(occurrence_batch).each_batch do |affected_package_batch|
              affected_package_batch.each do |affected_package|
                occurrence_batch.each do |occurrence|
                  next unless affected_package.package_name == occurrence.name

                  next unless affected_occurrence?(occurrence, sbom_report.source, affected_package)

                  advisory_data_object = Gitlab::VulnerabilityScanning::Advisory.from_affected_package(
                    affected_package: affected_package, advisory: affected_package.advisory)

                  finding = build_finding(advisory_data_object, occurrence, affected_package, sbom_report.source)

                  next unless finding

                  report.add_finding(finding)
                  finding.identifiers.each { |ident| report.add_identifier(ident) }
                end
              end
            end
          end
        end
      end

      def affected_packages(occurrence_batch)
        ::PackageMetadata::AffectedPackage.for_occurrences(occurrence_batch).with_advisory
      end

      def affected_occurrence?(occurrence, source, affected_package)
        advisory = affected_package.advisory
        occurrence_is_affected?(
          xid: advisory.advisory_xid,
          purl_type: affected_package.purl_type,
          range: affected_package.affected_range,
          version: occurrence.version,
          distro: affected_package.distro_version,
          source: source,
          project_id: pipeline.project_id,
          source_xid: advisory.source_xid
        )
      rescue SemverDialects::Error
        false
      end

      def build_finding(advisory_data_object, affected_occurrence, affected_package, source)
        ::Security::VulnerabilityScanning::BuildFindingMapService
          .execute(
            advisory: advisory_data_object,
            affected_component: affected_occurrence,
            source: source,
            pipeline: pipeline,
            project: project,
            purl_type: affected_package.purl_type,
            scanner: scanner
          )&.report_finding
      end
    end
  end
end
