# frozen_string_literal: true

module Gitlab
  module Llm
    module AiGateway
      module Completions
        class ResolveVulnerability < Base
          extend ::Gitlab::Utils::Override
          include Gitlab::Utils::StrongMemoize
          include Gitlab::Llm::Completions::ResolveVulnerability::Helpers
          include Gitlab::InternalEventsTracking

          RESPONSE_MODIFIER = ResponseModifiers::ResolveVulnerability

          EmptyResponseError = Class.new(StandardError)

          DEV_PROMPT = "^1.0.1"

          override :execute
          def execute
            return unless valid?

            response_modifier = begin
              ensure_eligible_code!

              response = request!

              modify_response(post_process(response))

            rescue Templates::Vulnerabilities::CodeLengthError => error
              handle_warn(error, 'error_building_request')
            rescue EmptyResponseError => error
              handle_warn(error, 'error_response_received')
            rescue StandardError => error
              handle_error(error)
            end

            ::Gitlab::Llm::GraphqlSubscriptionResponseService.new(
              user, resource, response_modifier, options: response_options
            ).execute
          end

          override :inputs
          def inputs
            {
              name: resource.title,
              filename: File.basename(resource.file),
              identifiers: formatted_identifiers,
              vulnerable_code: vulnerable_code,
              source_code: finding.source_code,
              vulnerability_description: resource.description || resource.finding_description
            }
          end

          override :root_namespace
          def root_namespace
            resource.project.try(:root_ancestor)
          end

          private

          override :prompt_version
          def prompt_version
            '1.0.1'
          end

          def request!
            response = perform_ai_gateway_request!(user: user, tracking_context: tracking_context)

            raise EmptyResponseError, "Empty response from LLM" if response.blank?

            response
          end

          override :post_process
          def post_process(response)
            ai_response, diff_extracted, description_options = extract_llm_change(response)

            perform_action(ai_response, diff_extracted, description_options)
          end

          def perform_action(ai_response, diff_extracted, description_options)
            return ai_response unless diff_extracted

            vulnerable_merge_request_id = merge_request_gid(@options[:vulnerable_merge_request_id])
            create_merge_request_with_resolution(
              user,
              vulnerability,
              ai_response,
              description_options,
              vulnerable_merge_request_id: vulnerable_merge_request_id
            )
          end

          def modify_response(response)
            RESPONSE_MODIFIER.new(response)
          end

          def parse_ai_response(response)
            raise EmptyResponseError, "Empty response from LLM" if response.blank?

            response
          end

          def finding
            resource.finding
          end
          strong_memoize_attr :finding

          def formatted_identifiers
            identifiers = finding.identifier_names

            return '' if identifiers.empty?

            names = identifiers.join("\n* ")
            "<report_identifiers>\n * #{names}\n</report_identifiers>"
          end

          def max_code_length
            Templates::Vulnerabilities::VulnerabilityTemplate::MAX_CHARACTERS / 10
          end

          def vulnerable_code
            finding.vulnerable_code.chomp
          end

          def error_response(error)
            response = formatted_error_response(error_message(error))
            self.class::RESPONSE_MODIFIER.new(response)
          end

          def ensure_eligible_code!
            if vulnerable_code.length > max_code_length
              raise Templates::Vulnerabilities::CodeLengthError,
                "Vulnerable code exceeds maximum length (#{max_code_length})"
            end

            unless finding.source_code?
              raise Gitlab::Llm::Templates::Vulnerabilities::PromptError,
                "Unable to locate source code for vulnerability"
            end

            return unless resource.secret_detection?

            raise Gitlab::Llm::Templates::Vulnerabilities::PromptError,
              "Refusing to send possible secrets in AI prompt"
          end
        end
      end
    end
  end
end
