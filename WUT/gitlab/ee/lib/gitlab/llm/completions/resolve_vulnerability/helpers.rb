# frozen_string_literal: true

module Gitlab
  module Llm
    module Completions
      class ResolveVulnerability
        module Helpers
          include Gitlab::InternalEventsTracking

          DEFAULT_ERROR = 'An unexpected error has occurred.'
          CLIENT_TIMEOUT_ERROR = 'The upstream AI provider request timed out without responding.'
          FORBIDDEN_ERROR = "Unfortunately, you don't have access to vulnerability resolution."
          RESOLUTION_FAILURE_ERROR = 'Something went wrong while attempting to apply the ' \
            'AI resolution to a merge request.'
          MR_LINK_ERROR = 'An error occurred while attempting to link the MR to the vulnerability.'
          RESPONSE_FAILURE_ERROR = 'Response from AI is unreadable. Please try again.'
          START_CODE = "<fixed_code>\n"
          END_CODE = "</fixed_code>"
          START_ANALYSIS = "<analysis>\n"
          END_ANALYSIS = "</analysis>"
          START_SUMMARY = "<summary>\n"
          END_SUMMARY = "</summary>"
          START_IS_FALSE_POSITIVE = "<is_false_positive>\n"
          END_IS_FALSE_POSITIVE = "</is_false_positive>"

          private

          def language_from_filename(filename)
            ::CodeSuggestions::ProgrammingLanguage.detect_from_filename(filename).name if filename
          end

          def extract_llm_change(ai_response)
            content = parse_ai_response(ai_response)

            fixed_code = get_fixed_code(content)

            description_options = {}
            description_options[:analysis_data] = get_analysis_data(content)
            description_options[:summary_data] = get_summary_data(content)

            return [{ false_positive: true }, false, description_options] if false_positive?(content, fixed_code)

            [fixed_code, true, description_options]
          end

          def create_merge_request_with_resolution(
            user, vulnerability, response, description_options = {},
            vulnerable_merge_request_id: nil)
            return unless response.present?

            # create a merge request that contains an llm generated
            # patch for a vulnerability. This MR could be a standalone
            # MR, which means it was generated from clicking the
            # resolve button on the vulnerability detail page. In this
            # case, the target branch for the MR will be
            # project.default_branch
            #
            # It is also possible this MR was triggered from the
            # security widget on a pre-existing MR. In this case, the
            # pre-existing MR (i.e. vulnerable_mr) will be used as the
            # source for the llm-generated mr (i.e. resolution_mr)
            #
            # This security-widget based workflow has the additional
            # steps of creating a note on the vulnerable_mr that links
            # to the resolution_mr

            vulnerable_mr = MergeRequest.find(vulnerable_merge_request_id) if vulnerable_merge_request_id
            params = {
              llm_patch: response,
              description_options: description_options.merge(vulnerable_mr: vulnerable_mr),
              target_branch: vulnerable_mr&.source_branch
            }.compact

            service_response = ::MergeRequests::CreateFromVulnerabilityDataService.new(
              vulnerability.project,
              vulnerability,
              user,
              params
            ).execute

            unless service_response[:status] == :success
              return error_with_cache_invalidation(service_response)
                       .tap { track_mr_creation_event(vulnerable_mr, user, vulnerability, nil, :error) }
            end

            # At this point, we have created a merge request that is
            # either standalone, or is pointing a pre-exisiting MR
            # (determined by whether target_branch was nil or not
            merge_request = service_response[:merge_request]

            # We need to generate a merge request link between the
            # vulnerability and the MR, which is used to create a link
            # UI element in various places.
            #
            # TODO: This could probably be done async, as an error in
            # link creation still leaves the MR in a usable state
            mr_link_result = VulnerabilityMergeRequestLinks::CreateService.new(
              project: vulnerability.project,
              current_user: user,
              params: {
                vulnerability: vulnerability,
                merge_request: merge_request
              }
            ).execute

            unless mr_link_result[:status] == :success
              return formatted_error_response(MR_LINK_ERROR, context: mr_link_result)
            end

            track_mr_creation_event(vulnerable_mr, user, vulnerability, merge_request, :success)

            # At this point, either we are done generating a
            # standalone MR, and can return the link to the new MR
            #
            # OR
            #
            # We have created a resolution_mr that points at an
            # existing MR, and need to generate the note on the
            # original vulnerable_mr mentioning the resolution_mr
            mr_url = Gitlab::Routing.url_helpers.project_merge_request_url(
              merge_request.project,
              merge_request
            )

            if vulnerable_mr
              note = Vulnerabilities::Remediations::NoteService.new(
                vulnerable_mr, merge_request, vulnerability, user).execute
            end

            note_url = Gitlab::UrlBuilder.note_url(note) if note

            {
              merge_request_url: note_url || mr_url,
              resolution_merge_request_id: note&.id || merge_request.id
            }
          end

          def merge_request_gid(merge_request_id)
            return unless merge_request_id

            GitlabSchema.parse_gid(merge_request_id).model_id
          end

          def error_with_cache_invalidation(service_response)
            message = RESOLUTION_FAILURE_ERROR

            if service_response[:unreadable_response]
              message = RESPONSE_FAILURE_ERROR
              invalidate_cache!
            end

            error = StandardError.new(message)
            track_and_log_error(error)

            formatted_error_response(message, context: service_response)
          end

          def track_mr_creation_event(vulnerable_mr, user, vulnerability, merge_request, status)
            event_name = vulnerable_mr ? "track_mr_creation_from_vr_in_mr_request" : "track_mr_creation_from_vr"
            project = vulnerability.project

            track_internal_event(
              event_name,
              user: user,
              project: project,
              namespace: project&.namespace,
              additional_properties: {
                label: "resolve_vulnerability",
                property: status.to_s,
                vulnerability_id: vulnerability&.id,
                internal_merge_request_id: merge_request&.id,
                language: language_from_filename(vulnerability&.finding&.file)
              }
            )
          end

          def error_message(error)
            case error
            when Gitlab::Llm::Templates::Vulnerabilities::PromptError
              error.message
            when Net::ReadTimeout
              CLIENT_TIMEOUT_ERROR
            when Gitlab::AiGateway::ForbiddenError
              FORBIDDEN_ERROR
            when Gitlab::Llm::AiGateway::Completions::ResolveVulnerability::EmptyResponseError
              RESPONSE_FAILURE_ERROR
            when EmptyResponseError
              RESPONSE_FAILURE_ERROR
            else
              DEFAULT_ERROR
            end
          end

          def formatted_error_response(message, context = {})
            { error: { message: message, context: context } }.to_json
          end

          def request(user, prompt)
            ::Gitlab::Llm::ResolveVulnerability::Client.new(user,
              unit_primitive: 'resolve_vulnerability',
              tracking_context: tracking_context
            ).messages_complete(**prompt)
          end

          def cache_key(user, vulnerability)
            [user.id, vulnerability.cache_key, 'resolve'].join('/')
          end

          def vulnerability
            resource
          end

          def get_fixed_code(content)
            regex = /(?<=#{Regexp.escape(START_CODE)}).*?(?=#{Regexp.escape(END_CODE)})/mo

            match_data = content.match(regex)
            match_data[0] if match_data
          end

          def get_analysis_data(content)
            analysis_regex = /(?<=#{Regexp.escape(START_ANALYSIS)}).*?(?=#{Regexp.escape(END_ANALYSIS)})/mo

            analysis_match_data = content.match(analysis_regex)
            analysis_match_data[0] if analysis_match_data
          end

          def get_summary_data(content)
            summary_regex = /(?<=#{Regexp.escape(START_SUMMARY)}).*?(?=#{Regexp.escape(END_SUMMARY)})/mo

            summary_match_data = content.match(summary_regex)
            summary_match_data[0] if summary_match_data
          end

          def false_positive?(content, fixed_code)
            return true if fixed_code.nil? || fixed_code.blank?

            is_false_positive_regex = %r{
              (?<=#{Regexp.escape(START_IS_FALSE_POSITIVE)})
              .*?
              (?=#{Regexp.escape(END_IS_FALSE_POSITIVE)})
            }xmo

            is_false_positive_match_data = content.match(is_false_positive_regex)
            is_false_positive_match_data[0].strip.casecmp?('true') if is_false_positive_match_data
          end

          def track_and_log_error(error)
            log_local_error(error)
            Gitlab::ErrorTracking.track_exception(error)
          end

          def invalidate_cache!
            Rails.cache.delete(cache_key(user, vulnerability))
          end

          def handle_error(error)
            Gitlab::ErrorTracking.track_exception(error)
            log_local_error(error)
            error_response(error)
          end

          def handle_warn(error, event_name)
            log_warn(
              message: "LLM completion error",
              event_name: event_name,
              ai_component: 'resolve_vulnerability',
              error_message: error.to_s
            )

            error_response(error)
          end
        end
      end
    end
  end
end
