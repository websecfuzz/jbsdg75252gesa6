# frozen_string_literal: true

module QA
  RSpec.describe 'Security Risk Management', :external_api_calls, :external_ai_provider,
    only: { pipeline: %i[staging staging-canary] }, product_group: :security_insights,
    quarantine: {
      issue: 'https://gitlab.com/gitlab-org/gitlab/-/issues/518624',
      type: :investigating
    } do
    describe 'Merge Request' do
      let(:vuln_name) { "Relative Path Traversal" }
      let(:vuln_name_as_branch_name) { vuln_name.downcase.tr(' ', '-') }
      let(:mr_comment_text) { "Vulnerability Resolution has generated a fix in an MR for this vulnerability." }
      let(:ai_mr_relative_path) { "#{project.full_path}/-/merge_requests/2" }
      let!(:sast_report) { EE::Runtime::Path.fixture('secure_premade_reports', 'gl-sast-report.json') }

      let!(:source_file) do
        EE::Runtime::Path.fixture('source_files', 'java-groovy-cmdi-groovyshell-taint.java')
      end

      let!(:project) do
        create(:project,
          name: 'resolve-this-vulnerability-in-mr',
          description: 'To check resolve this vulnerability AI feature in merge request')
      end

      let!(:runner) do
        create(:project_runner, project: project, name: "runner-for-#{project.name}", tags: ['secure_report'])
      end

      let!(:ci_yaml) do
        <<~YAML
          sast:
            tags: [secure_report]
            only: null # Template defaults to feature branches only
            script:
              - echo "Skipped"
            artifacts:
              reports:
                sast: gl-sast-report.json
        YAML
      end

      let!(:default_branch_commit) do
        create(:commit, project: project, commit_message: 'First commit default branch',
          actions: [{ action: 'create', file_path: 'test.txt', content: 'foo' }])
      end

      let(:source_branch_commit) do
        create(:commit,
          project: project,
          start_branch: project.default_branch,
          branch: 'test-resolve-this-vulnerability',
          commit_message: 'new SAST findings report in yml file',
          actions: [
            { action: 'create', file_path: '.gitlab-ci.yml', content: ci_yaml },
            { action: 'create', file_path: 'gl-sast-report.json', content: File.read(sast_report) },
            { action: 'create', file_path: 'java-groovy-cmdi-groovyshell-taint.java', content: File.read(source_file) }
          ])
      end

      let(:source_branch) { 'test-resolve-this-vulnerability' }

      let(:merge_request) do
        create(:merge_request,
          project: project,
          source: source_branch_commit,
          source_branch: source_branch,
          target_branch: project.default_branch)
      end

      before do
        Flow::Login.sign_in
        project.visit!
        merge_request
      end

      after do
        runner.remove_via_api!
      end

      it 'checks resolve vulnerability with MR AI feature', :aggregate_failures,
        testcase: 'https://gitlab.com/gitlab-org/gitlab/-/quality/test_cases/506826' do
        Flow::Pipeline.wait_for_pipeline_creation_via_api(project: project)
        QA::Support::Waiter.wait_until(sleep_interval: 0.5, message: "Waiting for MR pipeline to succeed") do
          project.pipelines.first[:status] == "success"
        end
        merge_request.visit!

        Page::MergeRequest::Show.perform do |mr|
          mr.expand_vulnerability_report
          mr.click_vulnerability(vuln_name)
          mr.click_resolve_with_ai
        end

        mr_notes = merge_request_notes
        expect(note_found_in_merge_request?(mr_notes, mr_comment_text)).to be_truthy
        expect(note_found_in_merge_request?(mr_notes, ai_mr_relative_path)).to be_truthy

        Page::MergeRequest::Show.perform do |mr|
          mr.expand_vulnerability_report
          mr.click_vulnerability(vuln_name)
          mr.click_finding_resolution_mr_link
        end

        expect(page).to have_content("Resolve vulnerability: #{vuln_name}")
        expect(page).to have_content(%r{requested to merge remediate/#{vuln_name_as_branch_name}.*})
        expect(page).to have_content(/into #{source_branch}/)
        expect(page).to have_content("AI GENERATED FIX")
        expect(page).to have_content("Description")
        expect(page).to have_content("Summary")
      end

      private

      def merge_request_notes
        merge_request.notes
      end

      def note_found_in_merge_request?(mr_notes, note)
        mr_notes.find { |mr_note| mr_note[:body].include?(note) }
      end
    end
  end
end
